{"meta":{"title":"紫依卓兰","subtitle":"","description":"","author":"紫依卓兰","url":"https://eriecorner.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-04-20T08:37:17.000Z","updated":"2020-04-20T12:56:03.600Z","comments":false,"path":"categories/index.html","permalink":"https://eriecorner.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-20T08:37:17.000Z","updated":"2020-04-20T12:56:27.177Z","comments":false,"path":"tags/index.html","permalink":"https://eriecorner.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"9. 两个栈实现一个队列","slug":"9. 两个栈实现一个队列","date":"2020-04-17T16:00:00.000Z","updated":"2020-04-21T03:50:53.250Z","comments":true,"path":"2020/04/18/9.liang-ge-zhan-shi-xian-yi-ge-dui-lie/","link":"","permalink":"https://eriecorner.github.io/2020/04/18/9.liang-ge-zhan-shi-xian-yi-ge-dui-lie/","excerpt":"","text":"题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 题解栈是先进后出，队列是先进先出。即一序列元素入栈后，出站顺序被翻转，则一个栈（暂且称为inStack）中的元素出站时先放入另一个栈(暂且称为outStack)），然后outStack栈的出站顺序和inStack的入栈顺序一致，就是队列的入队出队顺序。 代码实现java实现 定义队列及其入队出队的方法 123456789101112131415161718192021222324252627282930313233343536373839class Queue &#123; private Stack&lt;Integer&gt; inStack &#x3D; new Stack&lt;&gt;(); private Stack&lt;Integer&gt; outStack &#x3D; new Stack&lt;&gt;(); &#x2F;** * @param node * 进栈操作 *&#x2F; public void push(int node) &#123; inStack.push(node); &#125; &#x2F;** * @return 队列中是否有元素 *&#x2F; public boolean hasElement() &#123; if (outStack.isEmpty() &amp;&amp; inStack.isEmpty()) &#123; return false; &#125; return true; &#125; &#x2F;** * @return 出栈操作 * @throws Exception *&#x2F; public int pop() throws Exception &#123; if (outStack.isEmpty()) &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()); &#125; &#125; if (outStack.isEmpty()) &#123; throw new Exception(&quot;queue is empty&quot;); &#125; return outStack.pop(); &#125; &#125; 测试 123456789101112 @Test public void getResult() throws Exception &#123; Queue queue &#x3D; new Queue(); for (int i &#x3D; 0; i &lt; 5; i++) &#123; queue.push(i); &#125; while (queue.hasElement()) &#123; System.out.println(queue.pop()); &#125; &#125;&#x2F;&#x2F;输出01234 Kotlin 实现 构造队列并实现入队出队操作 12345678910111213141516171819202122232425262728class Queue &#123; val inStack &#x3D; Stack&lt;Int&gt;(); val outStack &#x3D; Stack&lt;Int&gt;(); &#x2F;&#x2F;入栈操作 fun push(node: Int) &#123; inStack.push(node) &#125; &#x2F;&#x2F;出站操作 fun pop(): Int &#123; if (outStack.isEmpty()) &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()) &#125; &#125; if (outStack.isEmpty()) &#123; throw Exception(&quot;queue is empty!&quot;) &#125; return outStack.pop() &#125; fun hasElement(): Boolean &#123; if (inStack.isEmpty() &amp;&amp; outStack.isEmpty()) &#123; return false &#125; return true &#125; &#125; 测试 123456789101112@Test fun getResult() &#123; val queue &#x3D; Queue() for (i:Int in 0..4)&#123; queue.push(i) &#125; while (queue.hasElement())&#123; print(queue.pop()) &#125; &#125; &#x2F;&#x2F;输出 01234","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"队列","slug":"队列","permalink":"https://eriecorner.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"https://eriecorner.github.io/tags/%E6%A0%88/"}]},{"title":"1.1 斐波那契数列","slug":" 1.1 斐波那契数列","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-21T03:46:44.114Z","comments":true,"path":"2020/04/14/1.1-fei-bo-na-qi-shu-lie/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/1.1-fei-bo-na-qi-shu-lie/","excerpt":"","text":"题目描述：现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。n&lt;=39 题解：斐波那契数列如：1,1,2,3,5,8,13…；所以得知F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）。 代码实现 递归实现 —— 时间复杂度O(2^n）123456789public long fibonacci(int n) &#123; if (n &lt; 0) &#123; return 0; &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123; return 1; &#125; else &#123; return fibonacci(n - 1) + fibonacci(n - 2); &#125; &#125; 顺序求法——时间复杂度O(n）1234567891011121314151617public long fibonacci2(int n) &#123; long result &#x3D; 0; long preOne &#x3D; 1; long preTwo &#x3D; 1; if (n &lt; 0) &#123; return 0; &#125; if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123; return 1; &#125; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; result &#x3D; preOne + preTwo; preTwo &#x3D; preOne; preOne &#x3D; result; &#125; return result; &#125; 状态矩阵相乘法——时间复杂度O(log n）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 public long fibonacci3(int n) &#123; if (n &lt; 0) &#123; return 0; &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123; return 1; &#125; &#x2F;&#x2F;状态矩阵 int[][] base &#x3D; &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;; &#x2F;&#x2F;最后的结果需要求矩阵的n-2次 int[][] res &#x3D; matrixPower(base, n - 2); return res[0][0] + res[1][0]; &#125; &#x2F;&#x2F;求矩阵m的p次幂的值 private int[][] matrixPower(int[][] m, int p) &#123; int[][] res &#x3D; new int[m.length][m[0].length]; &#x2F;&#x2F;先把res设为单位矩阵，相当于整数中的1 for (int i &#x3D; 0; i &lt; res.length; i++) &#123; res[i][i] &#x3D; 1; &#125; &#x2F;&#x2F;临时矩阵 int[][] tmp &#x3D; m; for (; p !&#x3D; 0; p &gt;&gt;&#x3D; 1) &#123; if ((p &amp; 1) !&#x3D; 0) &#123;&#x2F;&#x2F;按位与操作，其实也就是位置为1的乘把这个矩阵乘一下 res &#x3D; muliMatrix(res, tmp); &#125; &#x2F;&#x2F; &#x2F;&#x2F;等于0 的时候我临时矩阵自己乘一下 tmp &#x3D; muliMatrix(tmp, tmp); &#125; return res; &#125; private int[][] muliMatrix(int[][] m1, int[][] m2) &#123; &#x2F;&#x2F;构造出一个m1行和m2列的矩阵（矩阵相乘规则） int[][] res &#x3D; new int[m1.length][m2[0].length]; &#x2F;&#x2F;给我们要得到的矩阵的每一个元素的值进行赋值操作 for (int i &#x3D; 0; i &lt; m1.length; i++) &#123; for (int j &#x3D; 0; j &lt; m2[0].length; j++) &#123; for (int k &#x3D; 0; k &lt; m2.length; k++) &#123;&#x2F;&#x2F;i，j位置元素的值就是i行元素和j行元素乘积的加和 res[i][j] +&#x3D; m1[i][k] * m2[k][j]; &#125; &#125; &#125; return res; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"算法/递归","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"1.2 矩形覆盖问题","slug":"1.2 矩形覆盖问题","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-21T03:50:47.683Z","comments":true,"path":"2020/04/14/1.2-ju-xing-fu-gai-wen-ti/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/1.2-ju-xing-fu-gai-wen-ti/","excerpt":"","text":"题目描述：我们可以用 21 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 21 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ 题解：f(1) = 1; f(2) = 2; n&gt;2则f(n) = f(n-1)+f(n-2) 代码实现：123456789101112public int coverRect(int n) &#123; if (n &lt;&#x3D; 2) &#123; return n; &#125; int preOne &#x3D; 2, preTwo &#x3D; 1, result &#x3D; 0; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; result &#x3D; preOne + preTwo; preTwo &#x3D; preOne; preOne &#x3D; result; &#125; return result; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"算法/递归","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Hello World11111","slug":"hello-world","date":"2019-12-31T16:00:00.000Z","updated":"2020-04-20T13:04:53.653Z","comments":true,"path":"2020/01/01/hello-world/","link":"","permalink":"https://eriecorner.github.io/2020/01/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Android","slug":"Android","permalink":"https://eriecorner.github.io/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"https://eriecorner.github.io/categories/Android/View/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://eriecorner.github.io/tags/hexo/"},{"name":"hello","slug":"hello","permalink":"https://eriecorner.github.io/tags/hello/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"递归","slug":"算法/递归","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/"},{"name":"Android","slug":"Android","permalink":"https://eriecorner.github.io/categories/Android/"},{"name":"View","slug":"Android/View","permalink":"https://eriecorner.github.io/categories/Android/View/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"队列","slug":"队列","permalink":"https://eriecorner.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"https://eriecorner.github.io/tags/%E6%A0%88/"},{"name":"hexo","slug":"hexo","permalink":"https://eriecorner.github.io/tags/hexo/"},{"name":"hello","slug":"hello","permalink":"https://eriecorner.github.io/tags/hello/"}]}