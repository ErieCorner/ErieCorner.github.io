{"meta":{"title":"紫依卓兰","subtitle":"","description":"","author":"紫依卓兰","url":"https://eriecorner.github.io","root":"/"},"pages":[{"title":"标签","date":"2020-04-20T08:37:17.000Z","updated":"2020-04-20T12:56:27.177Z","comments":false,"path":"tags/index.html","permalink":"https://eriecorner.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-04-20T08:37:17.000Z","updated":"2020-04-20T12:56:03.600Z","comments":false,"path":"categories/index.html","permalink":"https://eriecorner.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"【LeetCode】152. 乘积最大子数组","slug":"算法/LeetCode/152. 乘积最大子数组","date":"2020-05-17T16:00:00.000Z","updated":"2020-05-18T14:19:10.311Z","comments":true,"path":"2020/05/18/suan-fa/leetcode/152.cheng-ji-zui-da-zi-shu-zu/","link":"","permalink":"https://eriecorner.github.io/2020/05/18/suan-fa/leetcode/152.cheng-ji-zui-da-zi-shu-zu/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述： 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1. 123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 2. 12输入: [-1,-2,-9,-6]输出: 108 解题思路 代码实现 JAVA实现12 kotlin实现12 复杂度分析 时间复杂度$O()$： 空间复杂度$O()$：","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"【LeetCode】53. 最大子序和","slug":"算法/LeetCode/53. 最大子序和","date":"2020-05-17T16:00:00.000Z","updated":"2020-05-18T14:20:14.448Z","comments":true,"path":"2020/05/18/suan-fa/leetcode/53.zui-da-zi-xu-he/","link":"","permalink":"https://eriecorner.github.io/2020/05/18/suan-fa/leetcode/53.zui-da-zi-xu-he/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述： 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 解题思路 代码实现 JAVA实现12 kotlin实现12 复杂度分析 时间复杂度$O()$： 空间复杂度$O()$：","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"OkHttp源码解析（Kotlin版）","slug":"三方框架源码解析/OkHttp  Kotlin版 源码解析","date":"2020-05-17T13:34:27.475Z","updated":"2020-05-18T13:26:55.419Z","comments":true,"path":"2020/05/17/san-fang-kuang-jia-yuan-ma-jie-xi/okhttp-kotlin-ban-yuan-ma-jie-xi/","link":"","permalink":"https://eriecorner.github.io/2020/05/17/san-fang-kuang-jia-yuan-ma-jie-xi/okhttp-kotlin-ban-yuan-ma-jie-xi/","excerpt":"","text":"前言OkHttp 是一款非常优秀的网络请求框架，随着Kotlin语言的不断完善，OkHttp 自 4.0 版本开始使用Kotlin编写，对于巩固Kotlin语法知识及实践，研读OkHttp 4.0及以上版本的源码是一个不错的选择。 首先列出一些前置知识点： Kotlin基础知识 Kotlin学习平台 网络请求响应码含义123451xx：信息，请求收到，继续处理2xx：成功，行为被成功地接受、理解和采纳3xx：重定向，为了完成请求，必须进一步执行的动作4xx：客户端错误，请求包含语法错误或者请求无法实现5xx：服务器错误，服务器不能实现一种明显无效的请求 Http缓存机制 OkHttp的基本使用 首先添加依赖库（去官网找最新的或想要的版本） Http 请求有多种类型，常用的分为 Get 和 Post，而 POST 又分为 Form 和 Multiple 等，下面我们以Get请求为例：1234567891011121314151617181920212223&#x2F;&#x2F; 1.创建OkHttpClient 对象，&#x2F;&#x2F; var client &#x3D; OkHttpClient();&#x2F;&#x2F;方式一 &#x2F;&#x2F;方式二： val client &#x3D; OkHttpClient.Builder().readTimeout(5, TimeUnit.SECONDS).build() &#x2F;&#x2F;2.创建请求对象并添加请求参数信息 val request &#x3D; Request.Builder().url(&quot;&quot;).build() &#x2F;&#x2F;3.构建进行请求操作的call对象 val call &#x3D; client.newCall(request) &#x2F;&#x2F;同步请求 Call （RealCall）—&gt;execute() 返回response &#x2F;&#x2F; val response &#x3D; client.newCall(request).execute() &#x2F;&#x2F;异步请求 Call （RealCall）—&gt;enqueue() call.enqueue( object : Callback &#123; override fun onFailure(call: Call, e: IOException) &#123; println(e.stackTrace.toString()) &#125; @Throws(IOException::class) override fun onResponse(call: Call, response: Response) &#123; println(response.body.toString()) &#125; &#125;) 首先使用OkHttpClint的构造OkHttpClient()或者Build模式构建一个OkHttpClint的对象实例； 使用构建者模式构建一个Request对象，通过OkHttpClient和Request对象，构建出Call对象； 执行call的enqueue()或者execute()。 注意：在实际开发中建议将OkHttpClint对象的创建封装成单列， 因为每个 OkHttpClient 对象都管理自己独有的线程池和连接池，复用连接池和线程池能够减少延迟、节省内存。 OkHttp 源码分析一. OkHttpClient12345678910111213141516171819202122232425262728293031323334constructor() : this(Builder())&#x2F;&#x2F;这里是默认的参数设置class Builder constructor() &#123; internal var dispatcher: Dispatcher &#x3D; Dispatcher()&#x2F;&#x2F;调度器，通过双端队列保存Calls（同步&amp;异步Call） internal var connectionPool: ConnectionPool &#x3D; ConnectionPool()&#x2F;&#x2F;链接池 internal val interceptors: MutableList&lt;Interceptor&gt; &#x3D; mutableListOf()&#x2F;&#x2F;拦截器 internal val networkInterceptors: MutableList&lt;Interceptor&gt; &#x3D; mutableListOf()&#x2F;&#x2F;网络拦截器 internal var eventListenerFactory: EventListener.Factory &#x3D; EventListener.NONE.asFactory()&#x2F;&#x2F;一个Call的状态监听器 internal var retryOnConnectionFailure &#x3D; true internal var authenticator: Authenticator &#x3D; Authenticator.NONE internal var followRedirects &#x3D; true internal var followSslRedirects &#x3D; true internal var cookieJar: CookieJar &#x3D; CookieJar.NO_COOKIES&#x2F;&#x2F;默认没有Cookie internal var cache: Cache? &#x3D; null internal var dns: Dns &#x3D; Dns.SYSTEM&#x2F;&#x2F;域名解析系统 domain name -&gt; ip address internal var proxy: Proxy? &#x3D; null internal var proxySelector: ProxySelector? &#x3D; null&#x2F;&#x2F;使用默认的代理选择器 internal var proxyAuthenticator: Authenticator &#x3D; Authenticator.NONE internal var socketFactory: SocketFactory &#x3D; SocketFactory.getDefault()&#x2F;&#x2F;默认的Socket 工厂生产Socket internal var sslSocketFactoryOrNull: SSLSocketFactory? &#x3D; null internal var x509TrustManagerOrNull: X509TrustManager? &#x3D; null internal var connectionSpecs: List&lt;ConnectionSpec&gt; &#x3D; DEFAULT_CONNECTION_SPECS&#x2F;&#x2F;OKHttp连接（Connection）配置 internal var protocols: List&lt;Protocol&gt; &#x3D; DEFAULT_PROTOCOLS internal var hostnameVerifier: HostnameVerifier &#x3D; OkHostnameVerifier internal var certificatePinner: CertificatePinner &#x3D; CertificatePinner.DEFAULT internal var certificateChainCleaner: CertificateChainCleaner? &#x3D; null internal var callTimeout &#x3D; 0 internal var connectTimeout &#x3D; 10_000 internal var readTimeout &#x3D; 10_000 internal var writeTimeout &#x3D; 10_000 internal var pingInterval &#x3D; 0&#x2F;&#x2F;和WebSocket有关,为了保持长连接，我们必须间隔一段时间发送一个ping指令进行保活 internal var minWebSocketMessageToCompress &#x3D; RealWebSocket.DEFAULT_MINIMUM_DEFLATE_SIZE internal var routeDatabase: RouteDatabase? &#x3D; null connectionSpecs： OKHttp连接（Connection）配置 1234567891011121314151617181920212223companion object &#123; internal val DEFAULT_PROTOCOLS &#x3D; immutableListOf(HTTP_2, HTTP_1_1) internal val DEFAULT_CONNECTION_SPECS &#x3D; immutableListOf( ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT) &#125; &#x2F;** * A modern TLS configuration that works on most client platforms and can connect to most servers. * This is OkHttp&#39;s default configuration. *&#x2F; &#x2F;&#x2F;针对TLS的， 是OkHttp 的默认配置 @JvmField val MODERN_TLS &#x3D; Builder(true) .cipherSuites(*APPROVED_CIPHER_SUITES) .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2) .supportsTlsExtensions(true) .build() &#x2F;** URL的未经加密，未经身份验证的连接 *&#x2F; @JvmField val CLEARTEXT &#x3D; Builder(false).build() 二. 同步请求流程分析以下代码为同步请求流程中的核心代码，按照调用次序呈现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129 &#x2F;&#x2F; 1. val response &#x3D; client.newCall(request).execute() &#x2F;&#x2F; 2. &#x2F;** Prepares the [request] to be executed at some point in the future. *&#x2F; override fun newCall(request: Request): Call &#x3D; RealCall(this, request, forWebSocket &#x3D; false) &#x2F;&#x2F;RealCall的execute() &#x2F;&#x2F; 3. 真正执行请求的是在call的实现类 RealCall的execute()中 override fun execute(): Response &#123; &#x2F;&#x2F;标记请求执行状态：一个请求只能执行一次 synchronized(this) &#123; check(!executed) &#123; &quot;Already Executed&quot; &#125; executed &#x3D; true &#125; timeout.enter() callStart() try &#123; &#x2F;&#x2F; 4. 通知dispatcher已经进入执行状态 client.dispatcher.executed(this) &#x2F;&#x2F; 5. 通过连接器的链式调用进行请求处理并返回最终响应结果 return getResponseWithInterceptorChain() &#125; finally &#123; &#x2F;&#x2F; 6. 通知dispatcher自己已执行完毕 client.dispatcher.finished(this) &#125; &#125; &#x2F;&#x2F;4 . dispatcher.executed() &#x2F;** Used by &#96;Call#execute&#96; to signal it is in-flight. *&#x2F; @Synchronized internal fun executed(call: RealCall) &#123; runningSyncCalls.add(call) &#125; &#x2F;&#x2F;Dispatcher中维护的ArrayDeque &#x2F;** 准备执行的异步请求队列. *&#x2F; private val readyAsyncCalls &#x3D; ArrayDeque&lt;AsyncCall&gt;() &#x2F;** 正在执行的异步请求队列 *&#x2F; private val runningAsyncCalls &#x3D; ArrayDeque&lt;AsyncCall&gt;() &#x2F;** 正在执行的同步请求队列 *&#x2F; private val runningSyncCalls &#x3D; ArrayDeque&lt;RealCall&gt;() &#x2F;&#x2F;5 .RealCall的getResponseWithInterceptorChain() @Throws(IOException::class) internal fun getResponseWithInterceptorChain(): Response &#123; &#x2F;&#x2F; Build a full stack of interceptors. val interceptors &#x3D; mutableListOf&lt;Interceptor&gt;() interceptors +&#x3D; client.interceptors&#x2F;&#x2F;用户在构建OkHttpClient是配置的连接器 interceptors +&#x3D; RetryAndFollowUpInterceptor(client)&#x2F;&#x2F;负责请求失败后的重试和重定向 interceptors +&#x3D; BridgeInterceptor(client.cookieJar)&#x2F;&#x2F;对请求和响应的参数进行必要的处理 interceptors +&#x3D; CacheInterceptor(client.cache)&#x2F;&#x2F;读取缓存数据返回、更新缓存 interceptors +&#x3D; ConnectInterceptor&#x2F;&#x2F;负责跟服务器的链接操作 if (!forWebSocket) &#123; &#x2F;&#x2F;创建OkHttpClient时设置的networkInterceptor interceptors +&#x3D; client.networkInterceptors &#125; &#x2F;&#x2F;向服务器发送请求数据，读取响应数据 interceptors +&#x3D; CallServerInterceptor(forWebSocket) &#x2F;&#x2F;将请求对象及OkHttpClient的一些配置封装在RealInterceptorChain中 val chain &#x3D; RealInterceptorChain( call &#x3D; this, interceptors &#x3D; interceptors, index &#x3D; 0, exchange &#x3D; null, request &#x3D; originalRequest, connectTimeoutMillis &#x3D; client.connectTimeoutMillis, readTimeoutMillis &#x3D; client.readTimeoutMillis, writeTimeoutMillis &#x3D; client.writeTimeoutMillis ) var calledNoMoreExchanges &#x3D; false try &#123; &#x2F;&#x2F;开启链式调用 val response &#x3D; chain.proceed(originalRequest) if (isCanceled()) &#123; response.closeQuietly() throw IOException(&quot;Canceled&quot;) &#125; return response &#125; catch (e: IOException) &#123; calledNoMoreExchanges &#x3D; true throw noMoreExchanges(e) as Throwable &#125; finally &#123; if (!calledNoMoreExchanges) &#123; noMoreExchanges(null) &#125; &#125; &#125;&#x2F;&#x2F;7. RealInterceptorChain的proceed()@Throws(IOException::class) override fun proceed(request: Request): Response &#123; check(index &lt; interceptors.size) calls++ if (exchange !&#x3D; null) &#123; check(exchange.finder.sameHostAndPort(request.url)) &#123; &quot;network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port&quot; &#125; check(calls &#x3D;&#x3D; 1) &#123; &quot;network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once&quot; &#125; &#125; &#x2F;&#x2F; Call the next interceptor in the chain. 实例化下一个拦截器 val next &#x3D; copy(index &#x3D; index + 1, request &#x3D; request) &#x2F;&#x2F;获取当前拦截器 val interceptor &#x3D; interceptors[index] &#x2F;&#x2F;调用当前拦截器的intercept(),并将下一个拦截器的RealIterceptorChain对象传递下去,最后返回响应结果 @Suppress(&quot;USELESS_ELVIS&quot;) val response &#x3D; interceptor.intercept(next) ?: throw NullPointerException( &quot;interceptor $interceptor returned null&quot;) if (exchange !&#x3D; null) &#123; check(index + 1 &gt;&#x3D; interceptors.size || next.calls &#x3D;&#x3D; 1) &#123; &quot;network interceptor $interceptor must call proceed() exactly once&quot; &#125; &#125; check(response.body !&#x3D; null) &#123; &quot;interceptor $interceptor returned a response with no body&quot; &#125; return response &#125; 三. 异步请求流程分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 &#x2F;&#x2F;1. 异步请求 Call （RealCall）—&gt;enqueue() client.newCall(request).enqueue( object : Callback &#123; override fun onFailure(call: Call, e: IOException) &#123; println(e.stackTrace.toString()) &#125; @Throws(IOException::class) override fun onResponse(call: Call, response: Response) &#123; println(response.body.toString()) &#125; &#125;) &#x2F;&#x2F;2. RealCall 的enqueue() override fun enqueue(responseCallback: Callback) &#123; synchronized(this) &#123; check(!executed) &#123; &quot;Already Executed&quot; &#125; executed &#x3D; true &#125; callStart() client.dispatcher.enqueue(AsyncCall(responseCallback)) &#125; &#x2F;&#x2F;3. dispatcher 的enqueue() internal fun enqueue(call: AsyncCall) &#123; synchronized(this) &#123; &#x2F;&#x2F;将请求添加到等待执行的异步请求队列中 readyAsyncCalls.add(call) &#x2F;&#x2F; Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to &#x2F;&#x2F; the same host. if (!call.call.forWebSocket) &#123; val existingCall &#x3D; findExistingCallWithHost(call.host) if (existingCall !&#x3D; null) call.reuseCallsPerHostFrom(existingCall) &#125; &#125; promoteAndExecute() &#125; &#x2F;** * Promotes eligible calls from [readyAsyncCalls] to [runningAsyncCalls] and runs them on the * executor service. Must not be called with synchronization because executing calls can call * into user code. * * @return true if the dispatcher is currently running calls. *&#x2F; &#x2F;&#x2F;4. 不断从readyAsyncCalls中取出要执行的请求放到runningAsyncCalls中，并将readyAsyncCalls中的移除 private fun promoteAndExecute(): Boolean &#123; this.assertThreadDoesntHoldLock() val executableCalls &#x3D; mutableListOf&lt;AsyncCall&gt;() val isRunning: Boolean synchronized(this) &#123; val i &#x3D; readyAsyncCalls.iterator() while (i.hasNext()) &#123; val asyncCall &#x3D; i.next() &#x2F;&#x2F; 如果其中的runningAsynCalls不满，且call占用的host小于最大数量，则将call加入到runningAsyncCalls中执行， if (runningAsyncCalls.size &gt;&#x3D; this.maxRequests) break &#x2F;&#x2F; Max capacity. if (asyncCall.callsPerHost.get() &gt;&#x3D; this.maxRequestsPerHost) continue &#x2F;&#x2F; Host max capacity. i.remove() asyncCall.callsPerHost.incrementAndGet() executableCalls.add(asyncCall) runningAsyncCalls.add(asyncCall) &#125; isRunning &#x3D; runningCallsCount() &gt; 0 &#125; for (i in 0 until executableCalls.size) &#123; val asyncCall &#x3D; executableCalls[i] &#x2F;&#x2F; 利用线程池执行call asyncCall.executeOn(executorService) &#125; return isRunning &#125; 异步请求的dispatcher.enqueue(AsyncCall)中传入是call 是一个AsyncCall，接下来看AsyncCall的实现.它是RealCall的内部类，实际是一个Runnable。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273internal inner class AsyncCall( private val responseCallback: Callback) : Runnable &#123; @Volatile var callsPerHost &#x3D; AtomicInteger(0) private set fun reuseCallsPerHostFrom(other: AsyncCall) &#123; this.callsPerHost &#x3D; other.callsPerHost &#125; val host: String get() &#x3D; originalRequest.url.host val request: Request get() &#x3D; originalRequest val call: RealCall get() &#x3D; this@RealCall &#x2F;** * Attempt to enqueue this async call on [executorService]. This will attempt to clean up * if the executor has been shut down by reporting the call as failed. *&#x2F; fun executeOn(executorService: ExecutorService) &#123; client.dispatcher.assertThreadDoesntHoldLock() var success &#x3D; false try &#123; &#x2F;&#x2F;在线程迟中执行 executorService.execute(this) success &#x3D; true &#125; catch (e: RejectedExecutionException) &#123; val ioException &#x3D; InterruptedIOException(&quot;executor rejected&quot;) ioException.initCause(e) noMoreExchanges(ioException) responseCallback.onFailure(this@RealCall, ioException) &#125; finally &#123; if (!success) &#123; client.dispatcher.finished(this) &#x2F;&#x2F; This call is no longer running! &#125; &#125; &#125; override fun run() &#123; threadName(&quot;OkHttp $&#123;redactedUrl()&#125;&quot;) &#123; var signalledCallback &#x3D; false timeout.enter() try &#123; &#x2F;&#x2F;最终进行拦截器的链式调用来处理请求并返回最终的响应结果 val response &#x3D; getResponseWithInterceptorChain() signalledCallback &#x3D; true responseCallback.onResponse(this@RealCall, response) &#125; catch (e: IOException) &#123; if (signalledCallback) &#123; &#x2F;&#x2F; Do not signal the callback twice! Platform.get().log(&quot;Callback failure for $&#123;toLoggableString()&#125;&quot;, Platform.INFO, e) &#125; else &#123; responseCallback.onFailure(this@RealCall, e) &#125; &#125; catch (t: Throwable) &#123; cancel() if (!signalledCallback) &#123; val canceledException &#x3D; IOException(&quot;canceled due to $t&quot;) canceledException.addSuppressed(t) responseCallback.onFailure(this@RealCall, canceledException) &#125; throw t &#125; finally &#123; client.dispatcher.finished(this) &#125; &#125; &#125;&#125; 通过源码看到Dispatcher维护了三个ArrayDeque，一个保存了正在执行的同步任务；一个保存异步正在执行的请求，另一个是异步等待执行的请求，异步右两个ArrayDeque是因为Dispatcher默认支持最大的并发请求是64个，单个Host最多执行5个并发请求，如果超过，则Call会先被放入到readyAsyncCall中，当出现空闲的线程时，再将readyAsyncCall中的线程移入到runningAsynCalls中，执行请求。 通过拦截器链处理，得到响应结果后执行finally中的代码dispatcher.finished(this)，现在来看下这个方法，走到这，一个请求流程就结束了。 12345678910111213141516171819202122232425262728&#x2F;** Used by [AsyncCall.run] to signal completion. *&#x2F;&#x2F;&#x2F;异步请求时调用 internal fun finished(call: AsyncCall) &#123; call.callsPerHost.decrementAndGet() finished(runningAsyncCalls, call) &#125; &#x2F;** Used by [Call.execute] to signal completion. *&#x2F; &#x2F;&#x2F;同步请求时调用 internal fun finished(call: RealCall) &#123; finished(runningSyncCalls, call) &#125; &#x2F;&#x2F;最终都调用这个方法 private fun &lt;T&gt; finished(calls: Deque&lt;T&gt;, call: T) &#123; val idleCallback: Runnable? synchronized(this) &#123; &#x2F;&#x2F;将当前call从其队列中移除 if (!calls.remove(call)) throw AssertionError(&quot;Call wasn&#39;t in-flight!&quot;) idleCallback &#x3D; this.idleCallback &#125; val isRunning &#x3D; promoteAndExecute() if (!isRunning &amp;&amp; idleCallback !&#x3D; null) &#123; idleCallback.run() &#125; &#125; 总结：网络请求是从OkHttpClient().newCall(request)开始的，通过创建的OkHttpClient对象和Request对象，构建出一个RealCall对象来执行网络请求，同步请求是在RealCall的execute()方法中，异步请求是在enqueue()中，在这两个方法中都用OkHttpClient对象的dispatcher执行对应的请求方法。对于同步请求，dispatcher的execute()就是将请求加入到runningSyncCalls这个双端队列中；对于异步请求，dispatcher进行请求的分发执行。在dispatcher将请求分发后调用getResponseWithInterceptorChain()方法，在这里，==依次==将client.interceptorsRetryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor、ConnectInterceptor、client.networkInterceptors和CallServerInterceptor添加到一个集合中，并创建出一个拦截器链RealInterceptorChain，通过RealInterceptorChain.proceed()使每一个拦截器执行完毕之后会调用下一个拦截器或者不调用并返回结果。显然，我们最终拿到的响应就是这个链条执行之后返回的结果。 整体的请求流程图如下： 四.OkHttp内置拦截器源码分析1. RetryAndFollowUpInterceptor这个拦截器负责重试和重定向，当一个请求由于各种原因失败了，如果是路由或者连接异常，则尝试恢复，否则，根据响应码（ResponseCode）,followup方法会对Request进行再处理以得到新的Request，然后沿着拦截器链继续新的Request；当尝试次数超过最大次数就抛出异常。代码逻辑相对比较简单，这里就不贴出来了。 2. BridgeInterceptor负责将用户请求转换为网络请求，也就是根据 Request 信息组建请求 Header 以及设置响应数据，包括设置 Cookie 以及gzip。源码就不贴出来了。 3. CacheInterceptor负责根据请求的信息和缓存的响应的信息来判断是否存在可用的缓存，读取缓存直接返回、否则就继续使用责任链模式来从服务器中获取响应。当获取到响应的时候，更新缓存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200@Throws(IOException::class)override fun intercept(chain: Interceptor.Chain): Response &#123; &#x2F;&#x2F;从缓存中获取 val cacheCandidate &#x3D; cache?.get(chain.request()) val now &#x3D; System.currentTimeMillis() &#x2F;&#x2F;缓存策略，决定使用缓存还是从网络获取 val strategy &#x3D; CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute() val networkRequest &#x3D; strategy.networkRequest val cacheResponse &#x3D; strategy.cacheResponse &#x2F;&#x2F;根据缓存策略，更新统计指标：请求次数、使用网络请求次数、使用缓存次数 cache?.trackResponse(strategy) &#x2F;&#x2F;若缓存不可用，关闭 if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it. cacheCandidate.body?.closeQuietly() &#125; &#x2F;&#x2F; If we&#39;re forbidden from using the network and the cache is insufficient, fail. &#x2F;&#x2F;如果既无网络请求可用，又没有缓存，则返回504错误 if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123; return Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(HTTP_GATEWAY_TIMEOUT) .message(&quot;Unsatisfiable Request (only-if-cached)&quot;) .body(EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build() &#125; &#x2F;&#x2F; If we don&#39;t need the network, we&#39;re done. &#x2F;&#x2F;缓存可用，则返回缓存中数据 if (networkRequest &#x3D;&#x3D; null) &#123; return cacheResponse!!.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build() &#125; var networkResponse: Response? &#x3D; null try &#123; &#x2F;&#x2F;进行网络请求，返回请求结果 networkResponse &#x3D; chain.proceed(networkRequest) &#125; finally &#123; &#x2F;&#x2F; If we&#39;re crashing on I&#x2F;O or otherwise, don&#39;t leak the cache body. if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123; cacheCandidate.body?.closeQuietly() &#125; &#125; &#x2F;&#x2F; If we have a cache response too, then we&#39;re doing a conditional get. &#x2F;&#x2F;HTTP_NOT_MODIFIED缓存有效，合并网络请求和缓存 if (cacheResponse !&#x3D; null) &#123; if (networkResponse?.code &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123; val response &#x3D; cacheResponse.newBuilder() .headers(combine(cacheResponse.headers, networkResponse.headers)) .sentRequestAtMillis(networkResponse.sentRequestAtMillis) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build() networkResponse.body!!.close() &#x2F;&#x2F; Update the cache after combining headers but before stripping the &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()). cache!!.trackConditionalCacheHit() cache.update(cacheResponse, response)&#x2F;&#x2F;更新缓存 return response &#125; else &#123; cacheResponse.body?.closeQuietly() &#125; &#125; val response &#x3D; networkResponse!!.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build() &#x2F;&#x2F;允许缓存且请求结果不为空，则写入缓存 if (cache !&#x3D; null) &#123; if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; &#x2F;&#x2F; Offer this request to the cache. val cacheRequest &#x3D; cache.put(response) return cacheWritingResponse(cacheRequest, response) &#125; if (HttpMethod.invalidatesCache(networkRequest.method)) &#123; try &#123; cache.remove(networkRequest) &#125; catch (_: IOException) &#123; &#x2F;&#x2F; The cache cannot be written. &#125; &#125; &#125; return response&#125; &#x2F;&#x2F; CacheStrategy中的核心方法 computeCandidate() &#x2F;** Returns a strategy to use assuming the request can use the network. *&#x2F; private fun computeCandidate(): CacheStrategy &#123; &#x2F;&#x2F; No cached response. 没有缓存，直接进行网络请求 if (cacheResponse &#x3D;&#x3D; null) &#123; return CacheStrategy(request, null) &#125; &#x2F;&#x2F; Drop the cached response if it&#39;s missing a required handshake. 是https请求，但是没有握手，进行网络请求 if (request.isHttps &amp;&amp; cacheResponse.handshake &#x3D;&#x3D; null) &#123; return CacheStrategy(request, null) &#125; &#x2F;&#x2F; If this response shouldn&#39;t have been stored, it should never be used as a response source. &#x2F;&#x2F; This check should be redundant as long as the persistence store is well-behaved and the &#x2F;&#x2F; rules are constant. &#x2F;&#x2F;不能进行缓存 if (!isCacheable(cacheResponse, request)) &#123; return CacheStrategy(request, null) &#125; val requestCaching &#x3D; request.cacheControl &#x2F;&#x2F;请求头nocache或者请求头包含If-Modified-Since或者If-None-Match(意味着本地缓存过期，需要服务器验证本地缓存是不是还能继续使用) if (requestCaching.noCache || hasConditions(request)) &#123; return CacheStrategy(request, null) &#125; val responseCaching &#x3D; cacheResponse.cacheControl val ageMillis &#x3D; cacheResponseAge() var freshMillis &#x3D; computeFreshnessLifetime() if (requestCaching.maxAgeSeconds !&#x3D; -1) &#123; freshMillis &#x3D; minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong())) &#125; var minFreshMillis: Long &#x3D; 0 if (requestCaching.minFreshSeconds !&#x3D; -1) &#123; minFreshMillis &#x3D; SECONDS.toMillis(requestCaching.minFreshSeconds.toLong()) &#125; var maxStaleMillis: Long &#x3D; 0 if (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds !&#x3D; -1) &#123; maxStaleMillis &#x3D; SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong()) &#125; &#x2F;&#x2F;缓存过期了，但仍然可用，给相应头中添加了Warning，使用缓存 if (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123; val builder &#x3D; cacheResponse.newBuilder() if (ageMillis + minFreshMillis &gt;&#x3D; freshMillis) &#123; builder.addHeader(&quot;Warning&quot;, &quot;110 HttpURLConnection \\&quot;Response is stale\\&quot;&quot;) &#125; val oneDayMillis &#x3D; 24 * 60 * 60 * 1000L if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123; builder.addHeader(&quot;Warning&quot;, &quot;113 HttpURLConnection \\&quot;Heuristic expiration\\&quot;&quot;) &#125; return CacheStrategy(null, builder.build())&#x2F;&#x2F;使用缓存 &#125; &#x2F;&#x2F; Find a condition to add to the request. If the condition is satisfied, the response body &#x2F;&#x2F; will not be transmitted. val conditionName: String val conditionValue: String? &#x2F;&#x2F;流程走到这，说明缓存已经过期了 &#x2F;&#x2F;添加请求头：If-Modified-Since或者If-None-Match &#x2F;&#x2F;etag与If-None-Match配合使用 &#x2F;&#x2F;lastModified与If-Modified-Since配合使用 &#x2F;&#x2F;前者和后者的值是相同的 &#x2F;&#x2F;区别在于前者是响应头，后者是请求头。 &#x2F;&#x2F;后者用于服务器进行资源比对，看看是资源是否改变了。 &#x2F;&#x2F; 如果没有，则本地的资源虽过期还是可以用的 when &#123; etag !&#x3D; null -&gt; &#123; conditionName &#x3D; &quot;If-None-Match&quot; conditionValue &#x3D; etag &#125; lastModified !&#x3D; null -&gt; &#123; conditionName &#x3D; &quot;If-Modified-Since&quot; conditionValue &#x3D; lastModifiedString &#125; servedDate !&#x3D; null -&gt; &#123; conditionName &#x3D; &quot;If-Modified-Since&quot; conditionValue &#x3D; servedDateString &#125; else -&gt; return CacheStrategy(request, null) &#x2F;&#x2F; No condition! Make a regular request. &#125; val conditionalRequestHeaders &#x3D; request.headers.newBuilder() conditionalRequestHeaders.addLenient(conditionName, conditionValue!!) val conditionalRequest &#x3D; request.newBuilder() .headers(conditionalRequestHeaders.build()) .build() return CacheStrategy(conditionalRequest, cacheResponse) &#125; 从上述CatchStragety.computeCandidate()方法可知，缓存策略如下： 1. 没有缓存，直接网络请求； 2. 如果是Https，没有进行握手，则进行网络请求； 3. 设置了不可缓存，则进行网络请求； 4. 请求头nocache或者请求头包含If-Modified-Since或者If-None-Match，则需要服务器验证本地缓存是不是还能继续使用，进行网络请求； 5. 可以缓存，并且缓存过期过期了但是还可以使用，这时给响应头添加Warning后，使用缓存； 6. 缓存已经过期，添加请求头：If-Modified-Since或者If-None-Match，进行网络请求；整个CatcheIncepter的执行依靠CatchStragety的缓存策略，代码中添加了注释，这里整理下流程如下： 1. 如果网络不可用并且无可用的有效缓存，则返回504错误； 2. 如果禁止了网络请求，则直接使用缓存； 3. 如果没有缓存且网络请求可用，则进行网络请求； 4. 如果此时有缓存，并且网络请求返回HTTP_NOT_MODIFIED（304），说明缓存还是有效的，则合并网络响应和缓存结果。同时更新缓存； 5. 如果没有缓存，则将请求回来的结果写入新的缓存中； 6. 返回响应数据。可以看到，缓存的获取、添加、更新等操作都是在Catche中初始化了一个DiskLruCache来完成的，具体方法如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&#x2F;&#x2F;获取缓存 internal fun get(request: Request): Response? &#123; val key &#x3D; key(request.url) val snapshot: DiskLruCache.Snapshot &#x3D; try &#123; cache[key] ?: return null &#125; catch (_: IOException) &#123; return null &#x2F;&#x2F; Give up because the cache cannot be read. &#125; val entry: Entry &#x3D; try &#123; Entry(snapshot.getSource(ENTRY_METADATA)) &#125; catch (_: IOException) &#123; snapshot.closeQuietly() return null &#125; val response &#x3D; entry.response(snapshot) if (!entry.matches(request, response)) &#123; response.body?.closeQuietly() return null &#125; return response &#125;&#x2F;&#x2F;添加缓存 internal fun put(response: Response): CacheRequest? &#123; val requestMethod &#x3D; response.request.method if (HttpMethod.invalidatesCache(response.request.method)) &#123; try &#123; remove(response.request) &#125; catch (_: IOException) &#123; &#x2F;&#x2F; The cache cannot be written. &#125; return null &#125; if (requestMethod !&#x3D; &quot;GET&quot;) &#123; &#x2F;&#x2F; Don&#39;t cache non-GET responses. We&#39;re technically allowed to cache HEAD requests and some &#x2F;&#x2F; POST requests, but the complexity of doing so is high and the benefit is low. return null &#125; if (response.hasVaryAll()) &#123; return null &#125; val entry &#x3D; Entry(response) var editor: DiskLruCache.Editor? &#x3D; null try &#123; editor &#x3D; cache.edit(key(response.request.url)) ?: return null entry.writeTo(editor) return RealCacheRequest(editor) &#125; catch (_: IOException) &#123; abortQuietly(editor) return null &#125; &#125;&#x2F;&#x2F;更新缓存 internal fun update(cached: Response, network: Response) &#123; val entry &#x3D; Entry(network) val snapshot &#x3D; (cached.body as CacheResponseBody).snapshot var editor: DiskLruCache.Editor? &#x3D; null try &#123; editor &#x3D; snapshot.edit() ?: return &#x2F;&#x2F; edit() returns null if snapshot is not current. entry.writeTo(editor) editor.commit() &#125; catch (_: IOException) &#123; abortQuietly(editor) &#125; &#125; 4. ConnectInterceptor这个拦截器打开与目标服务器的链接并进入下一个拦截器。通过RealCall的initExchange(chain)创建一个Exchange对象，并调用 Chain.proceed()方法。initExchange（）方法中会先通过 ExchangeFinder 尝试去 RealConnectionPool 中寻找已存在的连接，未找到则会重新创建一个RealConnection 并开始连接，然后将其存入RealConnectionPool，现在已经准备好了RealConnection 对象，然后通过请求协议创建不同的ExchangeCodec 并返回，返回的ExchangeCodec正是创建Exchange对象的一个参数。 下面说一下在建立连接过程中涉及到的几个重要类： Route:是连接到服务器的具体路由。其中包含了 IP 地址、端口、代理等参数。由于存在代理或者 DNS 可能返回多个 IP 地址的情况，所以同一个接口地址可能会对应多个 route。在创建 Connection 时将会使用 Route 而不是直接用 IP 地址。 RouteSelector：路由选择器，其中存储了所有可用的 route，在准备连接时时会通过 RouteSelector.next() 方法获取下一个 Route。值得注意的是，RouteSelector中包含了一个 routeDatabase 对象，其中存放着连接失败的Route，RouteSelector 会将其中存储的上次连接失败的route 放在最后，以此提高连接速度。 RealConnection:RealConnection 实现了 Connection接口，其中使用 Socket建立HTTP/HTTPS连接,并且获取 I/O 流，同一个 Connection 可能会承载多个 HTTP 的请求与响应。 RealConnectionPool:这是用来存储 RealConnection 的池子，内部使用一个双端队列来进行存储。在 OkHttp 中，一个连接（RealConnection）用完后不会立马被关闭并释放掉，而且是会存储到连接池（RealConnectionPool）中。除了缓存连接外，缓存池还负责定期清理过期的连接，在 RealConnection 中会维护一个用来描述该连接空闲时间的字段，每添加一个新的连接到连接池中时都会进行一次检测，遍历所有的连接，找出当前未被使用且空闲时间最长的那个连接，如果该连接空闲时长超出阈值，或者连接池已满，将会关闭该连接。 ExchangeCodec：ExchangeCodec 负责对Request 编码及解码 Response，也就是写入请求及读取响应，我们的请求及响应数据都通过它来读写。其实现类有两个：Http1ExchangeCodec 及 Http2ExchangeCodec，分别对应两种协议版本。 Exchange：功能类似 ExchangeCodec，但它是对应的是单个请求，其在 ExchangeCodec 基础上担负了一些连接管理及事件分发的作用。具体而言，Exchange 与 Request 一一对应，新建一个请求时就会创建一个 Exchange，该 Exchange 负责将这个请求发送出去并读取到响应数据，而发送与接收数据使用的是 ExchangeCodec。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132override fun intercept(chain: Interceptor.Chain): Response &#123; val realChain &#x3D; chain as RealInterceptorChain val exchange &#x3D; realChain.call.initExchange(chain) val connectedChain &#x3D; realChain.copy(exchange &#x3D; exchange) return connectedChain.proceed(realChain.request) &#125; &#x2F;&#x2F;RealCall 中的initExchange（）初始化Exchange对象 &#x2F;** Finds a new or pooled connection to carry a forthcoming request and response. *&#x2F; internal fun initExchange(chain: RealInterceptorChain): Exchange &#123; synchronized(connectionPool) &#123; check(!noMoreExchanges) &#123; &quot;released&quot; &#125; check(exchange &#x3D;&#x3D; null) &#125; val codec &#x3D; exchangeFinder!!.find(client, chain) val result &#x3D; Exchange(this, eventListener, exchangeFinder!!, codec) this.interceptorScopedExchange &#x3D; result synchronized(connectionPool) &#123; this.exchange &#x3D; result this.exchangeRequestDone &#x3D; false this.exchangeResponseDone &#x3D; false return result &#125; &#125; &#x2F;&#x2F;找到可用的resultConnection后根据协议创建ExchangeCodec并返回 fun find( client: OkHttpClient, chain: RealInterceptorChain ): ExchangeCodec &#123; try &#123; val resultConnection &#x3D; findHealthyConnection( connectTimeout &#x3D; chain.connectTimeoutMillis, readTimeout &#x3D; chain.readTimeoutMillis, writeTimeout &#x3D; chain.writeTimeoutMillis, pingIntervalMillis &#x3D; client.pingIntervalMillis, connectionRetryEnabled &#x3D; client.retryOnConnectionFailure, doExtensiveHealthChecks &#x3D; chain.request.method !&#x3D; &quot;GET&quot; ) return resultConnection.newCodec(client, chain) &#125; catch (e: RouteException) &#123; trackFailure(e.lastConnectException) throw e &#125; catch (e: IOException) &#123; trackFailure(e) throw RouteException(e) &#125; &#125; &#x2F;&#x2F;ExchangeFinder的findConnection方法中找已经存在的可用的链接 &#x2F;** * Returns a connection to host a new stream. This prefers the existing connection if it exists, * then the pool, finally building a new connection. *&#x2F; @Throws(IOException::class) private fun findConnection( connectTimeout: Int, readTimeout: Int, writeTimeout: Int, pingIntervalMillis: Int, connectionRetryEnabled: Boolean ): RealConnection &#123; var foundPooledConnection &#x3D; false var result: RealConnection? &#x3D; null var selectedRoute: Route? &#x3D; null var releasedConnection: RealConnection? val toClose: Socket? synchronized(connectionPool) &#123; ………… &#x2F;&#x2F; Attempt to get a connection from the pool. &#x2F;&#x2F;从connectPool中找可用的链接并返回 if (connectionPool.callAcquirePooledConnection(address, call, null, false)) &#123; foundPooledConnection &#x3D; true result &#x3D; call.connection &#125; else if (nextRouteToTry !&#x3D; null) &#123; selectedRoute &#x3D; nextRouteToTry nextRouteToTry &#x3D; null &#125; &#125; &#125; toClose?.closeQuietly() if (releasedConnection !&#x3D; null) &#123; eventListener.connectionReleased(call, releasedConnection!!) &#125; if (foundPooledConnection) &#123; eventListener.connectionAcquired(call, result!!) &#125; if (result !&#x3D; null) &#123; &#x2F;&#x2F; If we found an already-allocated or pooled connection, we&#39;re done. return result!! &#125; ………… &#x2F;&#x2F; Create a connection and assign it to this allocation immediately. This makes it possible &#x2F;&#x2F; for an asynchronous cancel() to interrupt the handshake we&#39;re about to do. &#x2F;&#x2F;创建一个新的RealConnection result &#x3D; RealConnection(connectionPool, selectedRoute!!) connectingConnection &#x3D; result var socket: Socket? &#x3D; null synchronized(connectionPool) &#123; connectingConnection &#x3D; null &#x2F;&#x2F; Last attempt at connection coalescing, which only occurs if we attempted multiple &#x2F;&#x2F; concurrent connections to the same host. if (connectionPool.callAcquirePooledConnection(address, call, routes, true)) &#123; &#x2F;&#x2F; We lost the race! Close the connection we created and return the pooled connection. result!!.noNewExchanges &#x3D; true socket &#x3D; result!!.socket() result &#x3D; call.connection &#x2F;&#x2F; It&#39;s possible for us to obtain a coalesced connection that is immediately unhealthy. In &#x2F;&#x2F; that case we will retry the route we just successfully connected with. nextRouteToTry &#x3D; selectedRoute &#125; else &#123; connectionPool.put(result!!)&#x2F;&#x2F;将新创建的RealConnection添加到connectPool中 call.acquireConnectionNoEvents(result!!) &#125; &#125; socket?.closeQuietly() eventListener.connectionAcquired(call, result!!) return result!! &#125; 5. CallServerInterceptor这是OkHttp 的连接器链中的最后一个拦截器，负责利用exchange把Request中的数据发送给服务端，并获取到数据写入到Response中。 到这里，OkHttp框架的核心逻辑已经梳理完了，回顾一下整体的架构实现，用到的设计模式有：Builder模式（OKHttpClient的构建）、工厂方法模式（Call接口提供了内部接口Factory、责任链模式（拦截器链）、享元模式（在Dispatcher的线程池）、策略模式（CacheInterceptor中数据选择等。 参考资源 OkHttp 4.6源码 okhttp源码解析 OkHttp 源码分析 感谢您阅读这篇文章，若有不正确的地方，欢迎指正!","categories":[{"name":"Android进阶","slug":"Android进阶","permalink":"https://eriecorner.github.io/categories/Android%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"三方框架源码解析","slug":"三方框架源码解析","permalink":"https://eriecorner.github.io/tags/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}]},{"title":"【LeetCode】236. 二叉树的最近公共祖先","slug":"算法/LeetCode/236. 二叉树的最近公共祖先","date":"2020-05-16T16:00:00.000Z","updated":"2020-05-18T14:19:33.472Z","comments":true,"path":"2020/05/17/suan-fa/leetcode/236.er-cha-shu-de-zui-jin-gong-gong-zu-xian/","link":"","permalink":"https://eriecorner.github.io/2020/05/17/suan-fa/leetcode/236.er-cha-shu-de-zui-jin-gong-gong-zu-xian/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述： 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 1234567 3 &#x2F; \\ 5 1 &#x2F; \\ &#x2F; \\6 2 8 &#x2F; \\ 7 4 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 示例 1. 123输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 2. 123输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 解题思路 我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。 从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。 从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。 同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。 代码实现JAVA实现12345678910111213141516171819202122232425262728293031323334class Solution &#123; Map&lt;Integer, TreeNode&gt; parent &#x3D; new HashMap&lt;Integer, TreeNode&gt;(); Set&lt;Integer&gt; visited &#x3D; new HashSet&lt;Integer&gt;();public void addParentNode(TreeNode node)&#123; if(node.left!&#x3D;null)&#123; parent.put(node.left.val,node); addParentNode(node.left); &#125; if(node.right!&#x3D;null)&#123; parent.put(node.right.val,node); addParentNode(node.right); &#125;&#125; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; addParentNode(root); while(p!&#x3D;null)&#123; visited.add(p.val); p &#x3D; parent.get(p.val); &#125; while(q!&#x3D;null)&#123; if(visited.contains(q.val))&#123; return q; &#125; q &#x3D; parent.get(q.val); &#125; return null; &#125;&#125; kotlin实现1234567891011121314151617181920212223242526272829303132class Solution &#123; var parent: MutableMap&lt;Int, TreeNode?&gt; &#x3D; HashMap() var visited: MutableSet&lt;Int&gt; &#x3D; HashSet() fun addParentNode(node: TreeNode?) &#123; if (node!!.left !&#x3D; null) &#123; parent[node.left.&#96;val&#96;] &#x3D; node addParentNode(node.left) &#125; if (node.right !&#x3D; null) &#123; parent[node.right.&#96;val&#96;] &#x3D; node addParentNode(node.right) &#125; &#125; fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? &#123; var p &#x3D; p var q &#x3D; q addParentNode(root) while (p !&#x3D; null) &#123; visited.add(p.&#96;val&#96;) p &#x3D; parent[p.&#96;val&#96;] &#125; while (q !&#x3D; null) &#123; if (visited.contains(q.&#96;val&#96;)) &#123; return q &#125; q &#x3D; parent[q.&#96;val&#96;] &#125; return null &#125; &#125; 复杂度分析 时间复杂度$O(N)$：其中 NN 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，从 p 和 q 节点往上跳经过的祖先节点个数不会超过 N，因此总的时间复杂度为 O(N)。 空间复杂度$O(N$：递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)，哈希表存储每个节点的父节点也需要 O(N) 的空间复杂度，因此最后总的空间复杂度为 O(N)。","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【LeetCode】283. 移动零","slug":"算法/LeetCode/283. 移动零","date":"2020-05-16T16:00:00.000Z","updated":"2020-05-18T14:19:23.593Z","comments":true,"path":"2020/05/17/suan-fa/leetcode/283.yi-dong-ling/","link":"","permalink":"https://eriecorner.github.io/2020/05/17/suan-fa/leetcode/283.yi-dong-ling/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述： 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 说明:必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。 示例12输入: [0,1,0,3,12]输出: [1,3,12,0,0] 解题思路 双指针法，用记录不是0的元素下标，i遍历数组，当nums[i]!=0的时候，将nums[i]的值给nums[j];并把0 给nums[i]; 代码实现JAVA实现12345678910111213public void moveZeroes(int[] nums) &#123; int j &#x3D; 0; for(int i &#x3D; 0;i&lt;nums.length;i++)&#123; if(nums[i]!&#x3D;0)&#123; if(i!&#x3D;j)&#123; nums[j] &#x3D; nums[i]; nums[i] &#x3D;0; &#125; j++; &#125; &#125; &#125; kotlin实现1234567891011fun moveZeroes(nums: IntArray) &#123; var j &#x3D; 0 for (i in nums.indices) &#123; if (nums[i] !&#x3D; 0) &#123; if (i !&#x3D; j) &#123; nums[j] &#x3D; nums[i] nums[i] &#x3D; 0 &#125; j++ &#125; &#125; 复杂度分析 时间复杂度$O(N)$：N是数组的长度，只需要遍历一遍 空间复杂度$O(1)$：","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"【LeetCode】155. 最小栈","slug":"算法/LeetCode/155. 最小栈","date":"2020-05-15T16:00:00.000Z","updated":"2020-05-18T14:18:55.077Z","comments":true,"path":"2020/05/16/suan-fa/leetcode/155.zui-xiao-zhan/","link":"","permalink":"https://eriecorner.github.io/2020/05/16/suan-fa/leetcode/155.zui-xiao-zhan/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。 示例1234567891011121314151617181920输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack &#x3D; new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2.来源：力扣（LeetCode）链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;min-stack著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 解题思路 代码实现 JAVA实现123456789101112131415161718192021222324252627282930313233343536373839class MinStack &#123; Stack&lt;Integer&gt; stack; int min &#x3D; Integer.MAX_VALUE; &#x2F;** initialize your data structure here. *&#x2F; public MinStack() &#123; stack &#x3D; new Stack&lt;Integer&gt;(); &#125; public void push(int x) &#123; if(x&lt;&#x3D;min)&#123; &#x2F;&#x2F;将之前的最小值入栈 stack.push(min); &#x2F;&#x2F;更新最小值 min &#x3D; x; &#125; stack.push(x); &#125; public void pop() &#123; &#x2F;&#x2F;如果弹出的值是最小值，那么将下一个元素更新为最小值 if(stack.pop()&#x3D;&#x3D;min)&#123; min &#x3D; stack.pop(); &#125; &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return min; &#125;&#125; kotlin实现1234567891011121314151617181920212223242526internal class MinStack &#123; private var stack: Stack&lt;Int&gt; &#x3D; Stack() private var min &#x3D; Int.MAX_VALUE fun push(x: Int) &#123; if (x &lt;&#x3D; min) &#123; &#x2F;&#x2F;将之前的最小值入栈 stack.push(min) &#x2F;&#x2F;更新最小值 min &#x3D; x &#125; stack.push(x) &#125; fun pop() &#123; &#x2F;&#x2F;如果弹出的值是最小值，那么将下一个元素更新为最小值 if (stack.pop() &#x3D;&#x3D;&#x3D; min) &#123; min &#x3D; stack.pop() &#125; &#125; fun top(): Int &#123; return stack.peek() &#125; fun getMin(): Int &#123; return min &#125; &#125; 复杂度分析 时间复杂度$O(1)$：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。 空间复杂度$O(1)$：","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"栈","slug":"栈","permalink":"https://eriecorner.github.io/tags/%E6%A0%88/"}]},{"title":"【LeetCode】560. 和为K的子数组","slug":"算法/LeetCode/560. 和为K的子数组","date":"2020-05-15T16:00:00.000Z","updated":"2020-05-18T14:18:01.896Z","comments":true,"path":"2020/05/16/suan-fa/leetcode/560.he-wei-k-de-zi-shu-zu/","link":"","permalink":"https://eriecorner.github.io/2020/05/16/suan-fa/leetcode/560.he-wei-k-de-zi-shu-zu/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述： 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 说明 : 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 示例12输入:nums &#x3D; [1,1,1], k &#x3D; 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 解题思路 我们把前缀和放在 map 中， map.put(preSum,前缀和出现次数) (数组中可能会有负数，所以可能会重复出现) 代码实现JAVA实现1234567891011121314151617public int subarraySum(int[] nums, int k) &#123; int count &#x3D; 0; &#x2F;&#x2F;使用hashMap 实现线性查找，map以i以前各项的和作为k，i以前各项的和出现的次数作为value HashMap&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;&gt;(); &#x2F;&#x2F; 数组下标为 0，则前面数组为空，所以和为 0，且出现一次 map.put(0,1); int sum &#x3D; 0; for (int i &#x3D; 0; i &lt;nums.length ; i++) &#123; sum+&#x3D;nums[i]; if (map.containsKey(sum-k))&#123; count+&#x3D; map.getOrDefault(sum-k,0); &#125; map.put(sum,map.getOrDefault(sum,0)+1); &#125; return count; &#125; kotlin实现12345678910111213141516fun subarraySum(nums: IntArray, k: Int): Int &#123; var count &#x3D; 0 &#x2F;&#x2F;使用hashMap 实现线性查找，map以i以前各项的和作为k，i以前各项的和出现的次数作为value val map: HashMap&lt;Int, Int&gt; &#x3D; HashMap() map[0] &#x3D; 1 var sum &#x3D; 0 for (i in nums.indices) &#123; sum +&#x3D; nums[i] if (map.containsKey(sum - k)) &#123; count +&#x3D; map.getOrDefault(sum - k, 0) &#125; map[sum] &#x3D; map.getOrDefault(sum, 0) + 1 &#125; return count &#125; 复杂度分析 时间复杂度$O(N)$：其中 nn 为数组的长度。我们遍历数组的时间复杂度为 O(n)，中间利用哈希表查询删除的复杂度均为 O(1)，因此总时间复杂度为 O(n)。 空间复杂度$O(N)$：其中 nn 为数组的长度。哈希表在最坏情况下可能有 nn 个不同的键值，因此需要 O(n)O(n) 的空间复杂度。","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"【LeetCode】136. 只出现一次的数字","slug":"算法/LeetCode/136. 只出现一次的数字","date":"2020-05-14T16:00:00.000Z","updated":"2020-05-18T14:19:45.213Z","comments":true,"path":"2020/05/15/suan-fa/leetcode/136.zhi-chu-xian-yi-ci-de-shu-zi/","link":"","permalink":"https://eriecorner.github.io/2020/05/15/suan-fa/leetcode/136.zhi-chu-xian-yi-ci-de-shu-zi/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1. 12输入: [2,2,1]输出: 1 2. 12输入: [4,1,2,1,2]输出: 4 解题思路 异或运算 任何数和 0 做异或运算，结果仍然是原来的数； 任何数和其自身做异或运算，结果是 0； 异或运算满足交换律和结合律。 代码实现JAVA实现1234567 public int singleNumber(int[] nums) &#123; int singleNumber &#x3D; 0; for(int i &#x3D; 0;i&lt;nums.length;i++)&#123; singleNumber^&#x3D; nums[i]; &#125; return singleNumber;&#125; kotlin实现12345678 fun singleNumber(nums: IntArray): Int &#123; var singleNumber &#x3D; 0 for( i in nums.indices)&#123; singleNumber &#x3D; singleNumber xor nums[i] &#125;return singleNumber &#125; 复杂度分析 时间复杂度$O(N)$：其中 n 是数组长度。只需要对数组遍历一次。 空间复杂度$O(1)$：","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"【LeetCode】572. 另一个数的子树","slug":"算法/LeetCode/572. 另一个数的子树","date":"2020-05-14T16:00:00.000Z","updated":"2020-05-18T14:17:44.811Z","comments":true,"path":"2020/05/15/suan-fa/leetcode/572.ling-yi-ge-shu-de-zi-shu/","link":"","permalink":"https://eriecorner.github.io/2020/05/15/suan-fa/leetcode/572.ling-yi-ge-shu-de-zi-shu/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述： 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1.给定的树s： 12345 3 &#x2F; \\ 4 5 &#x2F; \\1 2 给定的树t： 123 4 &#x2F; \\1 2 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。 2.给定的树s： 1234567 3 &#x2F; \\ 4 5 &#x2F; \\1 2 &#x2F; 0 给定的树t： 123 4 &#x2F; \\1 2 返回 false 解题思路 递归思想，注意两棵树完全相同也可以看做一棵树是另一棵树的子树。 代码实现JAVA实现1234567891011121314151617181920public boolean isSubtree(TreeNode s, TreeNode t) &#123; if(t&#x3D;&#x3D;null)&#123; return true; &#125; if(s&#x3D;&#x3D;null) return false; return isSubtree(s.left,t)||isSubtree(s.right,t)||isSameTree(s,t); &#125; &#x2F;&#x2F;两个树完全相同 public boolean isSameTree(TreeNode s,TreeNode t)&#123; if(s &#x3D;&#x3D; null &amp;&amp; t&#x3D;&#x3D;null)&#123; return true; &#125; if(s &#x3D;&#x3D; null||t &#x3D;&#x3D; null)&#123; return false; &#125; if(s.val!&#x3D;t.val)&#123; return false; &#125; return isSameTree(s.left,t.left)&amp;&amp;isSameTree(s.right,t.right); kotlin实现12345678910111213141516171819fun isSubtree(s: TreeNode?, t: TreeNode?): Boolean &#123; if (t &#x3D;&#x3D; null) &#123; return true &#125; return if (s &#x3D;&#x3D; null) false else isSubtree(s.left, t) || isSubtree(s.right, t) || isSameTree(s, t) &#125; fun isSameTree(s: TreeNode?, t: TreeNode?): Boolean &#123; if (s &#x3D;&#x3D; null &amp;&amp; t &#x3D;&#x3D; null) &#123; return true &#125; if (s &#x3D;&#x3D; null || t &#x3D;&#x3D; null) &#123; return false &#125; return if (s.&#96;val&#96; !&#x3D;&#x3D; t.&#96;val&#96;) &#123; false &#125; else isSameTree(s.left, t.left) &amp;&amp; isSameTree(s.right, t.right) &#125; 复杂度分析 时间复杂度：$O()$ 空间复杂度：$O()$","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【LeetCode】102. 二叉树的层序遍历","slug":"算法/LeetCode/102. 二叉树的层序遍历","date":"2020-05-13T16:00:00.000Z","updated":"2020-05-18T14:19:52.276Z","comments":true,"path":"2020/05/14/suan-fa/leetcode/102.er-cha-shu-de-ceng-xu-bian-li/","link":"","permalink":"https://eriecorner.github.io/2020/05/14/suan-fa/leetcode/102.er-cha-shu-de-ceng-xu-bian-li/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述： 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例 二叉树：[3,9,20,null,null,15,7], 12345 3 &#x2F; \\9 20 &#x2F; \\ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 解题思路 其实就是二叉树的前序遍历，只是每一层装在一个单独的集合中，最后将每一层的子集合都装在一个大集合中。 通过递归遍历实现。 代码实现JAVA实现1234567891011121314151617class Solution &#123; List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;(); public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;inorderTraverse(root,0);return result; &#125; public void inorderTraverse(TreeNode node, int level) &#123; if(node!&#x3D;null)&#123; if(result.size()&#x3D;&#x3D;level)&#123; result.add(new ArrayList&lt;Integer&gt;()); &#125; result.get(level).add(node.val); inorderTraverse(node.left,level+1); inorderTraverse(node.right,level+1); &#125; &#125;&#125; kotlin实现123456789101112131415161718class Solution &#123; var result: MutableList&lt;MutableList&lt;Int?&gt;&gt; &#x3D; ArrayList() fun levelOrder(root: TreeNode?): List&lt;MutableList&lt;Int?&gt;&gt;? &#123; inorderTraverse(root, 0) return result &#125; fun inorderTraverse(node: TreeNode?, level: Int) &#123; if (node !&#x3D; null) &#123; if (result.size &#x3D;&#x3D; level) &#123; result.add(ArrayList()) &#125; result[level].add(node.&#96;val&#96;) inorderTraverse(node.left, level + 1) inorderTraverse(node.right, level + 1) &#125; &#125;&#125; 复杂度分析 时间复杂度$O(N)$：N 为二叉树节点的个数 空间复杂度$O(H)$：H 为二叉树的高度","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【LeetCode】98. 验证二叉搜索树","slug":"算法/LeetCode/98. 验证二叉搜索树","date":"2020-05-12T16:00:00.000Z","updated":"2020-05-18T14:20:00.291Z","comments":true,"path":"2020/05/13/suan-fa/leetcode/98.yan-zheng-er-cha-sou-suo-shu/","link":"","permalink":"https://eriecorner.github.io/2020/05/13/suan-fa/leetcode/98.yan-zheng-er-cha-sou-suo-shu/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述：给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 12345 输入: 2 &#x2F; \\ 1 3输出: true 123456789输入: 5 &#x2F; \\ 1 4 &#x2F; \\ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 解题思路 由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。 所以用递归来判断isChildBST(childNode,left,right),以childNode为根节点的子树的所有节点是否在（left,right）的区间内，如果 root 节点的值 val 不在 （left,right）的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。 代码实现JAVA实现 定义树节点123456public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val &#x3D; x; &#125; &#125; 核心方法123456789101112public boolean isValidBST(TreeNode root) &#123; return isChildBST(root,null,null); &#125; public boolean isChildBST(TreeNode childNode,Integer left,Integer right)&#123; if(childNode&#x3D;&#x3D;null)&#123; return true; &#125; if(left!&#x3D;null&amp;&amp;left&gt;&#x3D;childNode.val)return false; if(right!&#x3D;null&amp;&amp;right&lt;&#x3D;childNode.val) return false; return isChildBST(childNode.left,left,childNode.val)&amp;&amp;isChildBST(childNode.right,childNode.val,right); &#125; kotlin实现 定义树节点1234class TreeNode(var &#96;val&#96;: Int) &#123; var left: TreeNode? &#x3D; null var right: TreeNode? &#x3D; null &#125; 核心方法123456789101112fun isValidBST(root: TreeNode?): Boolean &#123; return isChildBST(root,null,null) &#125; fun isChildBST(childNode:TreeNode?,left:Int?,right:Int?):Boolean&#123; if (childNode &#x3D;&#x3D; null) &#123; return true &#125; if (left !&#x3D; null &amp;&amp; left &gt;&#x3D; childNode.&#96;val&#96;) return false return if (right !&#x3D; null &amp;&amp; right &lt;&#x3D; childNode.&#96;val&#96;) false else isChildBST(childNode.left, left, childNode.&#96;val&#96;) &amp;&amp; isChildBST(childNode.right, childNode.&#96;val&#96;, right) &#125; 复杂度分析 时间复杂度：$O(n)$ 其中 n 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。 空间复杂度：$O(n)$ 其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 O(n) 。","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【LeetCode】69. X的平方根","slug":"算法/LeetCode/69. X的平方根","date":"2020-05-11T16:00:00.000Z","updated":"2020-05-18T14:20:06.913Z","comments":true,"path":"2020/05/12/suan-fa/leetcode/69.x-de-ping-fang-gen/","link":"","permalink":"https://eriecorner.github.io/2020/05/12/suan-fa/leetcode/69.x-de-ping-fang-gen/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述：实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去 示例 1. 12输入: 4输出: 2 2. 1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 解题思路 由于x的平方跟的整数部分ans是满足$k^2$&lt;=x的，所以，我们可以对K进行二分查找来得到答案； 二分查找的下限定为0，上限定为x，在查找的过程中，比较mid*mid与x的大小关系，根据结果来调整上下限范围。 代码实现JAVA实现123456789101112131415public int mySqrt(int x) &#123; int l &#x3D; 0,r &#x3D; x,result &#x3D; -1; while(l&lt;&#x3D;r)&#123; int mid &#x3D; l+(r-l)&#x2F;2; if((long)mid*mid&lt;&#x3D;x)&#123; result &#x3D; mid; l &#x3D; mid+1; &#125;else&#123; r &#x3D; mid-1; &#125; &#125; return result; &#125; kotlin实现12345678910111213141516fun mySqrt(x: Int): Int &#123; var l &#x3D; 0 var r &#x3D; x var result &#x3D; -1 while (l &lt;&#x3D; r) &#123; val mid &#x3D; l + (r - l) &#x2F; 2 if (mid.toLong() * mid &lt;&#x3D; x) &#123; result &#x3D; mid l &#x3D; mid + 1 &#125; else &#123; r &#x3D; mid - 1 &#125; &#125; return result &#125; 复杂度分析 时间复杂度：$O(log x)$：即二分查找需要的次数。 空间复杂度：$O(1)$","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【LeetCode】50. Pow(x, n)","slug":"算法/LeetCode/50. Pow(x, n)","date":"2020-05-10T16:00:00.000Z","updated":"2020-05-18T14:20:21.479Z","comments":true,"path":"2020/05/11/suan-fa/leetcode/50.pow-x-n/","link":"","permalink":"https://eriecorner.github.io/2020/05/11/suan-fa/leetcode/50.pow-x-n/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述： 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 示例 1. 12输入: 2.00000, 10输出: 1024.00000 2. 12输入: 2.10000, 3输出: 9.26100 3 123输入: 2.00000, -2输出: 0.25000解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25 解题思路 当我们要计算$x^n$时,我们可以先递归地计算出 $y =x^(|n|/2) $; 根据递归计算的结果，如果 n为偶数$x^n = y^2$ ,当n为奇数时，$x^n = y^2*x$; 递归的边界为 n = 0，任意数的 0 次方均为 1; 代码实现JAVA实现1234567891011public double myPow(double x, int n) &#123; return n &gt;&#x3D; 0 ? quickMul(x, n) : 1.0 &#x2F; quickMul(x, -n); &#125; public double quickMul(double x,int n)&#123; if(n&#x3D;&#x3D;0)&#123; return 1.0; &#125; double y &#x3D; quickMul(x, n &#x2F; 2); return n % 2 &#x3D;&#x3D; 0 ? y * y : y * y * x; &#125; kotlin实现12345678910111213fun myPow(x: Double, n: Int): Double &#123; return if(n&gt;&#x3D;0) mulPow(x,n)else 1.0&#x2F;mulPow(x,-n) &#125; fun mulPow(x:Double,n:Int):Double&#123; if(n&#x3D;&#x3D;0)&#123; return 1.0 &#125; val y &#x3D; mulPow(x,n&#x2F;2); return if(n%2&#x3D;&#x3D;0) y*y else y*y*x &#125; 复杂度分析 时间复杂度$O(log n)$： 空间复杂度$O(1)$：","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【LeetCode】26. 删除排序数组中的重复项","slug":"算法/LeetCode/26. 删除排序数组中的重复项","date":"2020-05-09T16:00:00.000Z","updated":"2020-05-18T14:20:28.183Z","comments":true,"path":"2020/05/10/suan-fa/leetcode/26.shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/","link":"","permalink":"https://eriecorner.github.io/2020/05/10/suan-fa/leetcode/26.shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述： 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 示例 12345给定数组 nums &#x3D; [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 12345给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 解题思路 数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。当我们遇到 nums[j]!=nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。 代码实现JAVA实现1234567891011121314public int removeDuplicates(int[] nums) &#123; if(nums.length&#x3D;&#x3D;0)&#123; return 0; &#125; int i &#x3D; 0; for(int j&#x3D;1;j&lt;nums.length;j++)&#123; if(nums[j]!&#x3D;nums[i])&#123; i++; nums[i] &#x3D; nums[j]; &#125; &#125; return i+1; &#125; kotlin实现123456789101112131415fun removeDuplicates(nums: IntArray): Int &#123; &#x2F;&#x2F; var nums &#x3D; nums if (nums.isEmpty()) &#123; return 0 &#125; var j &#x3D; 0 for(i in 1 until nums.size)&#123; if(nums[i]!&#x3D;nums[j])&#123; j++ nums[j]&#x3D;nums[i] &#125; &#125; return j+1 &#125; 复杂度分析 时间复杂度：$O(n)$假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步 空间复杂度：$O(1)$","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"【LeetCode】25. K 个一组翻转链表","slug":"算法/LeetCode/25. K 个一组翻转链表","date":"2020-05-08T16:00:00.000Z","updated":"2020-05-18T14:20:35.111Z","comments":true,"path":"2020/05/09/suan-fa/leetcode/25.k-ge-yi-zu-fan-zhuan-lian-biao/","link":"","permalink":"https://eriecorner.github.io/2020/05/09/suan-fa/leetcode/25.k-ge-yi-zu-fan-zhuan-lian-biao/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述：给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 说明：你的算法只能使用常数的额外空间。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例12345给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5当 k &#x3D; 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5当 k &#x3D; 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 解题思路 创建一个tmp节点用来指向链表的头结点（因为在链表翻转的过程中头结点有可能改变） 对链表以K为单位进行分组，记录每一组的开始位置和结束位置； 对每一组进行翻转，更新开始位置和结束位置； 把不满足分组条件的直接链在翻转后的链表后面； 返回tmp.next; 代码实现JAVA实现12345678910111213141516171819202122232425262728293031323334353637383940public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode tmp &#x3D; new ListNode(0); tmp.next &#x3D; head; ListNode pre &#x3D; tmp; ListNode end &#x3D; head; int count &#x3D; 0; while(end!&#x3D;null)&#123; count++; if(count%k&#x3D;&#x3D;0)&#123;&#x2F;&#x2F;需要翻转 ListNode next &#x3D; end.next;&#x2F;&#x2F;保存每一组最后一个节点的下一个节点（下一组的头结点） end.next &#x3D; null;&#x2F;&#x2F;按组断开 ListNode childend &#x3D; pre.next;&#x2F;&#x2F;保存每一组的第一个节点（即翻转后的最后一个节点） ListNode childHead &#x3D; revert(pre.next);&#x2F;&#x2F;翻转后的每一组的头结点 childend.next &#x3D; next;&#x2F;&#x2F;翻转后链表的尾节点跟原链表的后半部分链接起来 pre.next &#x3D; childHead;&#x2F;&#x2F;翻转后链表的头结点跟原链表的前半部分链接起来 &#x2F;&#x2F;指针向后移动开始遍历下一组 pre &#x3D; childend; end &#x3D; next; &#125;else&#123; &#x2F;&#x2F;不需翻转，则指针向后移动 end &#x3D; end.next; &#125; &#125; return tmp.next; &#125; &#x2F;** * 进行链表翻转，返回翻转后的头指针 * 头插法 *&#x2F; public ListNode revert(ListNode start)&#123; ListNode pre &#x3D; new ListNode(0); while(start!&#x3D;null)&#123; ListNode next &#x3D; start.next; start.next &#x3D; pre.next ; pre.next &#x3D; start; start &#x3D; next; &#125; return pre.next; &#125; kotlin实现123456789101112131415161718192021222324252627282930313233343536373839 fun reverseKGroup(head: ListNode?, k: Int): ListNode? &#123; var tmp &#x3D; ListNode(-1) tmp.next &#x3D; head var pre &#x3D; tmp var end &#x3D; head var count &#x3D; 0 while(end!&#x3D;null)&#123; count++ if(count%k&#x3D;&#x3D;0)&#123; &#x2F;&#x2F;断开节点 var next &#x3D; end.next end.next &#x3D; null &#x2F;&#x2F;翻转子链表 var childEnd &#x3D; pre.next var childHead &#x3D; revert(pre.next) &#x2F;&#x2F;将子链表和原链表链接 childEnd.next &#x3D; next pre.next &#x3D; childHead &#x2F;&#x2F;指向下一个子链表 pre &#x3D; childEnd end &#x3D; next &#125;else&#123; end &#x3D; end.next &#125; &#125;return tmp.next &#125; fun revert(start:ListNode?):ListNode?&#123; var start &#x3D; start var tmp &#x3D; ListNode(-1) while(start!&#x3D;null)&#123; var next &#x3D; start.next start.next &#x3D; tmp.next tmp.next &#x3D; start start &#x3D; next &#125;return tmp.next &#125; 复杂度分析 时间复杂度$O(N)$： N 是链表的长度； 空间复杂度$O(1)$：","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【LeetCode】19. 删除链表的倒数第N个节点","slug":"算法/LeetCode/19. 删除链表的倒数第N个节点","date":"2020-05-07T16:00:00.000Z","updated":"2020-05-18T14:20:41.675Z","comments":true,"path":"2020/05/08/suan-fa/leetcode/19.shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/","link":"","permalink":"https://eriecorner.github.io/2020/05/08/suan-fa/leetcode/19.shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述：给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 说明：给定的 n 保证是有效的。 示例123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 解题思路 使用快慢指针slow和fast，当fast走到第K个节点时，slow也开始走，当fast走到链表尾时，slow就走到了倒数第K+1个节点，这时删除slow的下一个节点。 代码实现JAVA实现12345678910111213141516171819 public ListNode removeNthFromEnd(ListNode head, int n) &#123; if(head&#x3D;&#x3D;null)&#123; return null; &#125; ListNode slow &#x3D; new ListNode(-1); slow.next &#x3D; head; ListNode p &#x3D; slow; ListNode fast &#x3D; head; for(int i &#x3D; 1;fast!&#x3D;null;i++)&#123; fast &#x3D; fast.next; if(i&gt;n)&#123; slow &#x3D; slow.next; &#125; &#125; slow.next &#x3D; slow.next.next;return p.next; &#125; kotlin实现12345678910111213141516fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? &#123; var slow: ListNode? &#x3D; ListNode(-1) slow!!.next &#x3D; head val p &#x3D; slow var fast &#x3D; head var i &#x3D; 1 while (fast !&#x3D; null) &#123; fast &#x3D; fast.next if (i &gt; n) &#123; slow &#x3D; slow!!.next &#125; i++ &#125; slow!!.next &#x3D; slow.next!!.next return p.next &#125; 复杂度分析 时间复杂度$O(N)$:N 是链表的节点个数 空间复杂度$O(1)$:","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【LeetCode】15. 三数之和","slug":"算法/LeetCode/15. 三数之和","date":"2020-05-06T16:00:00.000Z","updated":"2020-05-18T14:20:48.267Z","comments":true,"path":"2020/05/07/suan-fa/leetcode/15.san-shu-zhi-he/","link":"","permalink":"https://eriecorner.github.io/2020/05/07/suan-fa/leetcode/15.san-shu-zhi-he/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例1234567给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解题思路 双指针+排序 固定 3 个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums)) 两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合： 当 nums[k] &gt; 0 时直接break跳出：因为 nums[j] &gt;= nums[i] &gt;= nums[k] &gt; 0，即 3 个数字都大于 0 ，在此固定指针 k 之后不可能再找到结果了。 当 k &gt; 0且nums[k] == nums[k - 1]时即跳过此元素nums[k]：因为已经将 nums[k - 1] 的所有组合加入到结果中，本次双指针搜索只会得到重复组合。 i，j 分设在数组索引 (k, len(nums))(k,len(nums)) 两端，当i &lt; j时循环计算s = nums[k] + nums[i] + nums[j]，并按照以下规则执行双指针移动： 当s &lt; 0时，i += 1并跳过所有重复的nums[i]； 当s &gt; 0时，j -= 1并跳过所有重复的nums[j]； 当s == 0时，记录组合[k, i, j]至res，执行i += 1和j -= 1并跳过所有重复的nums[i]和nums[j]，防止记录到重复组合。 代码实现JAVA实现12345678910111213141516171819202122232425262728public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList(); Arrays.sort(nums); for(int k &#x3D; 0;k&lt;nums.length-2;k++)&#123; if(nums[k]&gt;0)&#123; break; &#125; if(k&gt;0&amp;&amp;nums[k]&#x3D;&#x3D;nums[k-1]) &#123; continue; &#125; int i &#x3D; k+1,j &#x3D; nums.length-1; while(i&lt;j)&#123; int sum &#x3D; nums[k]+nums[i]+nums[j]; if(sum&lt;0)&#123; while(i&lt;j&amp;&amp;nums[i]&#x3D;&#x3D;nums[++i]); &#125;else if (sum&gt;0)&#123; while(i&lt;j&amp;&amp;nums[j]&#x3D;&#x3D;nums[--j]); &#125;else&#123; result.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[k],nums[i],nums[j]))); while(i&lt;j&amp;&amp;nums[i]&#x3D;&#x3D;nums[++i]); while(i&lt;j&amp;&amp;nums[j]&#x3D;&#x3D;nums[--j]); &#125; &#125; &#125; return result; &#125; kotlin实现1234567891011121314151617181920212223242526272829303132fun threeSum(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123; val result: MutableList&lt;List&lt;Int&gt;&gt; &#x3D; ArrayList() Arrays.sort(nums) for (k in 0 until nums.size - 2) &#123; if (nums[k] &gt; 0) &#123; break &#125; if (k &gt; 0 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) &#123; continue &#125; var i &#x3D; k + 1 var j &#x3D; nums.size - 1 while (i &lt; j) &#123; val sum &#x3D; nums[k] + nums[i] + nums[j] when &#123; sum &lt; 0 -&gt; &#123; while (i &lt; j &amp;&amp; nums[i] &#x3D;&#x3D; nums[++i]); &#125; sum &gt; 0 -&gt; &#123; while (i &lt; j &amp;&amp; nums[j] &#x3D;&#x3D; nums[--j]); &#125; else -&gt; &#123; result.add(ArrayList(mutableListOf(nums[k], nums[i], nums[j]))) while (i &lt; j &amp;&amp; nums[i] &#x3D;&#x3D; nums[++i]); while (i &lt; j &amp;&amp; nums[j] &#x3D;&#x3D; nums[--j]); &#125; &#125; &#125; &#125; return result &#125; 复杂度分析 时间复杂度：$O(NlogN)$ 空间复杂度：$O(1)$","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","permalink":"https://eriecorner.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"【LeetCode】13. 罗马数字转整数","slug":"算法/LeetCode/13. 罗马数字转整数","date":"2020-05-05T16:00:00.000Z","updated":"2020-05-18T14:20:54.391Z","comments":true,"path":"2020/05/06/suan-fa/leetcode/13.luo-ma-shu-zi-zhuan-zheng-shu/","link":"","permalink":"https://eriecorner.github.io/2020/05/06/suan-fa/leetcode/13.luo-ma-shu-zi-zhuan-zheng-shu/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述： 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例1.12输入: &quot;III&quot;输出: 3 2. 12输入: &quot;IV&quot;输出: 4 3. 123输入: &quot;LVIII&quot;输出: 58解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3. 4. 123输入: &quot;MCMXCIV&quot;输出: 1994解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4. 解题思路 分别列出每个字符对应的数字，然后循环遍历比较前后两个数字，若前面的数字比后面的大，则和减去前面的数；否则和加上前面的数。 代码实现JAVA实现123456789101112131415161718192021222324252627282930313233343536public int romanToInt(String s) &#123; int num &#x3D; getNum(s.charAt(0)); int sum &#x3D; 0; for(int i &#x3D; 1;i&lt;s.length();i++)&#123; int curr &#x3D; getNum(s.charAt(i)); if(num&lt;curr)&#123; sum-&#x3D;num; &#125;else&#123; sum+&#x3D; num; &#125; num &#x3D; curr; &#125; return sum+&#x3D; num; &#125; public int getNum(char str)&#123; switch(str)&#123; case &#39;I&#39;: return 1; case &#39;V&#39;: return 5; case &#39;X&#39;: return 10; case &#39;L&#39;: return 50; case &#39;C&#39;: return 100; case &#39;D&#39;: return 500; case &#39;M&#39;: return 1000; default:return 0; &#125; &#125; kotlin实现1234567891011121314151617181920212223242526fun romanToInt(s: String): Int &#123; var num &#x3D; getNum(s[0]) var sum &#x3D; 0 for (i in 1 until s.length) &#123; val curr &#x3D; getNum(s[i]) if (num &lt; curr) &#123; sum -&#x3D; num &#125; else &#123; sum +&#x3D; num &#125; num &#x3D; curr &#125; return num.let &#123; sum +&#x3D; it; sum &#125; &#125; fun getNum(str: Char): Int &#123; return when (str) &#123; &#39;I&#39; -&gt; 1 &#39;V&#39; -&gt; 5 &#39;X&#39; -&gt; 10 &#39;L&#39; -&gt; 50 &#39;C&#39; -&gt; 100 &#39;D&#39; -&gt; 500 &#39;M&#39; -&gt; 1000 else -&gt; 0 &#125; &#125; 复杂度分析 时间复杂度：$O(N)$：N 是字符串的长度 空间复杂度：$O(1)$","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【LeetCode】12. 整数转罗马数字","slug":"算法/LeetCode/12. 整数转罗马数字","date":"2020-05-05T16:00:00.000Z","updated":"2020-05-18T14:21:00.276Z","comments":true,"path":"2020/05/06/suan-fa/leetcode/12.zheng-shu-zhuan-luo-ma-shu-zi/","link":"","permalink":"https://eriecorner.github.io/2020/05/06/suan-fa/leetcode/12.zheng-shu-zhuan-luo-ma-shu-zi/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述：罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。12345678字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： - I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 - X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 示例 1. 12输入: 3输出: &quot;III&quot; 2. 12输入: 4输出: &quot;IV&quot; 3. 123输入: 58输出: &quot;LVIII&quot;解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3. 4. 123输入: 1994输出: &quot;MCMXCIV&quot;解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4. 解题思路 由题意可知：罗马数字由十三个元素组成，我们可以将其和对应的数字按照对应顺序分别存入两个数组中； 然后循环遍历这个数组，当给定的数字大于等于数组当前的值时，就将该值对应的罗马字符添加到目标字符串上，并将给定数字减去当前数字后继续跟当前数字进行比较。 代码实现JAVA实现1234567891011121314151617public String intToRoman(int num) &#123; &#x2F;&#x2F; 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中 &#x2F;&#x2F; 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想 int[] nums &#x3D;&#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;; String[] strs &#x3D; &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;; int size &#x3D; nums.length; StringBuilder result &#x3D; new StringBuilder(); for(int i &#x3D; 0;i&lt;size;i++)&#123; &#x2F;&#x2F; 注意：这里是等于号，表示尽量使用大的&quot;面值&quot; while(num&gt;&#x3D;nums[i])&#123; result.append(strs[i]); num-&#x3D;nums[i]; &#125; &#125; return result.toString(); &#125; kotlin实现123456789101112131415fun intToRoman(num: Int): String &#123; var num &#x3D; num val nums &#x3D; intArrayOf(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1) val strs &#x3D; arrayOf(&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;) var result:String &#x3D; &quot;&quot; for (i in 0 until nums.size) &#123; &#x2F;&#x2F; 注意：这里是等于号，表示尽量使用大的&quot;面值&quot; while (num &gt;&#x3D; nums[i]) &#123; result+&#x3D;(strs[i]) num -&#x3D; nums[i] &#125; &#125; return result &#125; 复杂度分析 时间复杂度：$O(1)$：虽然看起来是两层循环，但是外层循环的次数最多 12，内层循环的此时其实也是有限次的，综合一下，时间复杂度是 O(1)。 空间复杂度：$O(1)$:这里使用了两个辅助数字，空间都为 13，还有常数个变量，故空间复杂度是 O(1)。","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【LeetCode】11. 盛最多水的容器","slug":"算法/LeetCode/11. 盛最多水的容器","date":"2020-05-04T16:00:00.000Z","updated":"2020-05-18T14:21:06.990Z","comments":true,"path":"2020/05/05/suan-fa/leetcode/11.sheng-zui-duo-shui-de-rong-qi/","link":"","permalink":"https://eriecorner.github.io/2020/05/05/suan-fa/leetcode/11.sheng-zui-duo-shui-de-rong-qi/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述：给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 说明：你不能倾斜容器，且 n 的值至少为 2。 示例12输入：[1,8,6,2,5,4,8,3,7]输出：49 解题思路 要求与X轴共同构成的容器可以容纳的最多的水，也就是求构成的这个矩形尽可能大的面积，当然是长和宽都尽可能的大。构成的这个矩形中高取决于左右两条边中的最小值，宽就是左右两条边的横坐标之差。 那就定义两个指针i，j分别指向给定数组的第一个位置height[0]和最后一个位置height[length-1]，在这两个指针不重合的前提下判断这两个位置的值大小，当height[i]&lt;height[j],将i向右移动一个位置；当height[i]&lt;height[j],将j向左移动一位，得到高度后，宽等于j-i+1,循环遍历，计算出高*宽的最大值。 代码实现JAVA实现123456789 public int maxArea(int[] height) &#123; int max &#x3D; 0; for(int i &#x3D; 0,j&#x3D;height.length-1;i&lt;j;)&#123; int minHeight &#x3D; height[i]&lt;height[j]?height[i++]:height[j--]; max &#x3D; Math.max(max,(j-i+1)*minHeight); &#125;return max; &#125; kotlin实现12345678910fun maxArea(height: IntArray): Int &#123; var max &#x3D; 0 var i &#x3D; 0; var j &#x3D; height.size-1; while(i&lt;j)&#123; val minHeight &#x3D; if(height[i]&lt;height[j]) height[i++] else height[j--] max &#x3D; Math.max(max,(j-i+1)*minHeight) &#125;return max; &#125; 复杂度分析 时间复杂度$O(N)$：双指针遍历一次底边宽度 NN 。 空间复杂度$O(1)$：指针使用常数额外空间。","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"双指针","slug":"双指针","permalink":"https://eriecorner.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"【LeetCode】11. 盛最多水的容器","slug":"算法/LeetCode/9. 回文数","date":"2020-05-03T16:00:00.000Z","updated":"2020-05-18T14:21:11.868Z","comments":true,"path":"2020/05/04/suan-fa/leetcode/9.hui-wen-shu/","link":"","permalink":"https://eriecorner.github.io/2020/05/04/suan-fa/leetcode/9.hui-wen-shu/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述：判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1. 12输入: 121输出: true 2. 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 3. 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 解题思路 回文数是将改数字翻转后跟原来数字相同，也就是说其后半部分反转后应该与原始数字的前半部分相同； 再结合实际情况，负数肯定不是回文数字，另外若一个数的末尾是0，则要是回文数，该数就是0; 结合数学计算进行数字翻转，当原始数字小于翻转的数，则说明已经翻转了一半。 代码实现JAVA实现12345678910111213141516171819202122232425public boolean isPalindrome(int x) &#123; &#x2F;* &#x2F;&#x2F; 转换为字符串进行比较 String y &#x3D; String.valueOf(x); for (int i &#x3D; 0; i &lt; y.length(); i++) &#123; if (y.charAt(i)!&#x3D;y.charAt(y.length()-i-1))&#123; return false; &#125; &#125; return true; *&#x2F; if(x &lt; 0 || (x % 10 &#x3D;&#x3D; 0 &amp;&amp; x !&#x3D; 0)) &#123; return false; &#125; int revertedNumber &#x3D; 0; while(x &gt; revertedNumber) &#123; revertedNumber &#x3D; revertedNumber * 10 + x % 10; x &#x2F;&#x3D; 10; &#125;&#x2F;&#x2F; 当数字长度为奇数时，我们可以通过 revertedNumber&#x2F;10 去除处于中位的数字。&#x2F;&#x2F; 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x&#x3D;&#x3D;revertedNumber||x&#x3D;&#x3D;revertedNumber&#x2F;10; &#125; kotlin实现123456789101112fun isPalindrome(x: Int): Boolean &#123; var x &#x3D; x if(x&lt;0||(x%10&#x3D;&#x3D;0&amp;&amp;x!&#x3D;0))&#123; return false &#125; var revertNum:Int &#x3D; 0 while(x&gt;revertNum)&#123; revertNum &#x3D;revertNum*10+ x % 10 x&#x2F;&#x3D;10 &#125;return x&#x3D;&#x3D;revertNum||x&#x3D;&#x3D;revertNum&#x2F;10 &#125; 复杂度分析 时间复杂度：$O(log_{10}(n))$:对于每次迭代，我们会将输入除以10，因此时间复杂度为 $O(log_{10}(n))$。 空间复杂度：$O(1)$","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【LeetCode】7. 整数反转","slug":"算法/LeetCode/7. 整数反转","date":"2020-05-02T16:00:00.000Z","updated":"2020-05-18T14:21:17.696Z","comments":true,"path":"2020/05/03/suan-fa/leetcode/7.zheng-shu-fan-zhuan/","link":"","permalink":"https://eriecorner.github.io/2020/05/03/suan-fa/leetcode/7.zheng-shu-fan-zhuan/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述： 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 12输入: 123输出: 321 12输入: -123输出: -321 12输入: 120输出: 21 ==注意：== 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 解题思路 通过数学运算获得各位上的数字，高位变低位$x/10^n$,低位变高位$x*10^n$ 代码实现JAVA实现123456789101112131415161718public int reverse(int x) &#123; int INT_MAX &#x3D; (int)Math.pow(2,31)-1; int INT_MIN &#x3D; -(int)Math.pow(2,31); int result &#x3D; 0; int y &#x3D; 0; while(x!&#x3D;0)&#123; y &#x3D; x%10; x&#x2F;&#x3D;10; if(result&gt;INT_MAX&#x2F;10||(result&#x3D;&#x3D;INT_MAX&#x2F;10&amp;&amp;y&gt;7))&#123; return 0; &#125; if(result&lt;INT_MIN&#x2F;10||(result&#x3D;&#x3D;INT_MIN&#x2F;10&amp;&amp;y&lt;-8))&#123; return 0; &#125; result &#x3D; result*10+y; &#125;return result; &#125; kotlin实现123456789101112131415161718192021fun reverse(x: Int): Int &#123; var x &#x3D; x var y &#x3D; 0 var result &#x3D; 0 val max &#x3D; 2.0.pow(31.0).toInt() - 1 val min &#x3D; -2.0.pow(31.0).toInt() while(x!&#x3D;0)&#123; y &#x3D; x%10 x&#x3D;x&#x2F;10 if(result&gt;max&#x2F;10||(result&#x3D;&#x3D;max&#x2F;10&amp;&amp;y&gt;7))&#123; return 0; &#125; if(result&lt;min&#x2F;10||(result&#x3D;&#x3D;min&#x2F;10&amp;&amp;y&lt;-8))&#123; return 0; &#125; result &#x3D; result*10+y; &#125; return result &#125; 复杂度分析 时间复杂度：$O(log(x))$x 中大约有 $log10(x)$ 空间复杂度：$O(1)$","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【LeetCode】3. 无重复字符的最长子串","slug":"算法/LeetCode/3. 无重复字符的最长子串","date":"2020-05-01T16:00:00.000Z","updated":"2020-05-18T14:21:25.334Z","comments":true,"path":"2020/05/02/suan-fa/leetcode/3.wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/","link":"","permalink":"https://eriecorner.github.io/2020/05/02/suan-fa/leetcode/3.wu-chong-fu-zi-fu-de-zui-chang-zi-chuan/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述： 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 12345输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是&quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot;是一个子序列，不是子串。 解题思路 以字符串 abcabcbb 为例，找出 从每一个字符开始的，不包含重复字符的最长子串，那么其中最长的那个字符串即为答案。 以(a)bcabcbb 开始的最长字符串为 (abc)abcbb； 以(b)cabcbb 开始的最长字符串为 a(bca)bcbb； 以abc(a)bcbb 开始的最长字符串为 abc(abc)bb； ………… 以abcabcb(b) 开始的最长字符串为 abcabcb(b) 可以看出使用滑动窗口来解决此问题。我们依次递增地枚举子串的起始位置，假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk，那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk的字符显然是不重复的，并且由于少了原本的第 k个字符，我们可以尝试继续增大 rk ，直到右侧出现了重复字符为止。 在每一步的操作中，我们会将左指针向右移动一格，表示我们开始枚举下一个字符作为起始位置，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 以左指针开始的，不包含重复字符的最长子串。我们记录下这个子串的长度； 在枚举结束后，我们找到的最长的子串的长度即为答案。 代码实现JAVA实现123456789101112131415161718public int lengthOfLongestSubstring(String s) &#123; HashSet&lt;Character&gt; set &#x3D; new HashSet(); int right &#x3D; 0; int subLength &#x3D;0; for(int i &#x3D; 0;i&lt;s.length();i++)&#123; if(i&gt;0)&#123; &#x2F;&#x2F; 左指针向右移动一格，移除一个字符 set.remove(s.charAt(i-1)); &#125; while(right&lt;s.length()&amp;&amp;!set.contains(s.charAt(right)))&#123; &#x2F;&#x2F; 不断地移动右指针 set.add(s.charAt(right)); right++; &#125; subLength &#x3D;Math.max(subLength,right-i) ; &#125; return subLength; &#125; kotlin实现1234567891011121314151617fun lengthOfLongestSubstring(s: String): Int &#123; val set &#x3D; HashSet&lt;Char&gt;() var subLength &#x3D; 0 var right &#x3D; 0 for(i in s.indices )&#123; if(i&gt;0)&#123; set.remove(s[i-1]) &#125; while(right&lt;s.length&amp;&amp;!set.contains(s[right]))&#123; set.add(s[right]) right++ &#125; subLength &#x3D; Math.max(subLength, right - i) &#125;return subLength &#125; 复杂度分析 时间复杂度：O($N$) 其中 N 是字符串的长度。左指针和右指针分别会遍历整个字符串一次 空间复杂度：O($∣Σ∣$) 其中 $Σ$ 表示字符集（即字符串中可以出现的字符），$|Σ∣$表示字符集的大小。在本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 $[0, 128)$ 内的字符，即 $|Σ∣=128$。我们需要用到哈希集合来存储出现过的字符，而字符最多有 $|Σ∣$ 个，因此空间复杂度为 $O(∣Σ∣)$。","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://eriecorner.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【LeetCode】1. 两数之和","slug":"算法/LeetCode/1. 两数之和","date":"2020-04-30T16:00:00.000Z","updated":"2020-05-18T14:06:50.443Z","comments":true,"path":"2020/05/01/suan-fa/leetcode/1.liang-shu-zhi-he/","link":"","permalink":"https://eriecorner.github.io/2020/05/01/suan-fa/leetcode/1.liang-shu-zhi-he/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 示例:123给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9。因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 解题思路 通过遍历将数组中的元素和其下标以key和value的形式存储在一个map中； 然后判断这个map中存在（target-当前元素），若存在就说明已经找到了，从map中取出目标元素的下标和当前元素的下标，创建一个数组返回。 遍历完没有找到目标值，则说明不存在。代码实现 JAVA实现1234567891011public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map &#x3D; new HashMap(); for(int i &#x3D; 0;i&lt;nums.length;i++)&#123; int diff &#x3D; target- nums[i]; if(map.containsKey(diff))&#123; return new int[] &#123;map.get(diff),i&#125;; &#125; map.put(nums[i],i); &#125; throw new IllegalArgumentException(&quot;No two sum solution&quot;); &#125; kotlin实现123456789101112fun twoSum(nums: IntArray, target: Int): IntArray &#123; var map &#x3D; HashMap&lt;Int,Int&gt;() for(i in nums.indices)&#123; var diff &#x3D; target - nums[i] if(map.contains(diff))&#123; return intArrayOf(map[diff]!!,i) &#125; map[nums[i]] &#x3D; i; &#125; throw IllegalArgumentException(&quot;No two sum solution&quot;) &#125; 复杂度分析 时间复杂度$O(n)$ 只遍历了包含有 n 个元素的列表一次。在表中进行的每次查找只花费 $O(1)$的时间。 空间复杂度$O(n)$ 所需的额外空间取决于哈希表中存储的元素数量，该表最多需要存储 n个元素。","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【LeetCode】2. 两数想加","slug":"算法/LeetCode/2. 两数想加","date":"2020-04-30T16:00:00.000Z","updated":"2020-05-18T14:21:32.364Z","comments":true,"path":"2020/05/01/suan-fa/leetcode/2.liang-shu-xiang-jia/","link":"","permalink":"https://eriecorner.github.io/2020/05/01/suan-fa/leetcode/2.liang-shu-xiang-jia/","excerpt":"","text":"题目简介 题目来源： LeetCode 题目描述：给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 &#x3D; 807 解题思路 因为链表时逆序存储的，所以只需要计算各个节点值的和，大于10则进位1，将进位1带入下一个节点，两个节点的和%10的值作为当前节点的值。 循环计算各个节点的值，直到两个链表的节点都遍历完。 若最后一个节点的和大于10，记得将进位1继续创建一个节点。 代码实现JAVA实现 定义单链表节点12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val &#x3D; x; &#125; &#125; 核心算法123456789101112131415161718192021222324public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode pNode &#x3D; new ListNode(-1); ListNode sumNode&#x3D; pNode; int sumVal &#x3D; 0; int tmp &#x3D; 0; while(l1!&#x3D;null||l2!&#x3D;null)&#123; int l1Val &#x3D; l1&#x3D;&#x3D;null?0:l1.val; int l2Val &#x3D; l2&#x3D;&#x3D;null?0:l2.val; sumVal &#x3D; l1Val+l2Val+tmp; tmp &#x3D; sumVal&#x2F;10; l1 &#x3D; l1&#x3D;&#x3D;null?null:l1.next; l2 &#x3D; l2&#x3D;&#x3D;null?null:l2.next; sumNode.next &#x3D; new ListNode(sumVal%10); sumNode &#x3D; sumNode.next; &#125; if(tmp!&#x3D;0)&#123; sumNode.next &#x3D; new ListNode(tmp); &#125; return pNode.next; &#125; kotlin实现 定义单链表的节点123class ListNode(var &#96;val&#96;: Int) &#123; var next: ListNode? &#x3D; null &#125; 核心算法1234567891011121314151617181920212223 fun addTwoNumbers(l1: ListNode?, l2: ListNode?): ListNode? &#123; var l1 &#x3D; l1 var l2 &#x3D; l2 var sumNode &#x3D; ListNode(-1) var pNode &#x3D; sumNode; var sumVal &#x3D; 0 var tmp &#x3D; 0 while(l1!&#x3D;null||l2!&#x3D;null)&#123; val l1Val &#x3D; l1?.&#96;val&#96;?:0 val l2Val &#x3D; l2?.&#96;val&#96;?:0 sumVal &#x3D; l1Val+l2Val+tmp tmp &#x3D; sumVal&#x2F;10 l1 &#x3D; l1?.next l2 &#x3D; l2?.next sumNode.next &#x3D; ListNode(sumVal%10) sumNode &#x3D; sumNode.next &#125; if (tmp !&#x3D; 0) &#123; sumNode.next &#x3D; ListNode(tmp) &#125;return pNode.next &#125; 复杂度分析 时间复杂度：O(max(m,n))。假设m,n分别表示链表一和链表二的长度。 空间复杂度：O(max(m,n))。 新列表的长度最多为max(m,n)+1。","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【剑指Offer】21. 顺时针打印矩阵","slug":"算法/剑指Offer/21. 顺时针打印矩阵","date":"2020-04-28T16:00:00.000Z","updated":"2020-05-18T14:04:48.864Z","comments":true,"path":"2020/04/29/suan-fa/jian-zhi-offer/21.shun-shi-zhen-da-yin-ju-zhen/","link":"","permalink":"https://eriecorner.github.io/2020/04/29/suan-fa/jian-zhi-offer/21.shun-shi-zhen-da-yin-ju-zhen/","excerpt":"","text":"题目描述 题目来源： Nowcoder 题设： 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 123456\\begin&#123;bmatrix&#125;1&amp;2&amp;3&amp;4\\\\5&amp;6&amp;7&amp;8\\\\9&amp;10&amp;11&amp;12\\\\13&amp;14&amp;15&amp;16\\end&#123;bmatrix&#125; 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解题思路 顺时针遍历即从左到右，再从右上到右下，从右到左，再从左下到左上这个环形遍历。 则标记left = 0，top = 0，right = row-1;bottom = col-1； 从左到右（leftright）遍历完一行后，top向下移动一位（top+1）；从右上到右下遍历（topbottom）一列后，right向左移动一位（right-1）；当bottom&gt;=tops时，有必要从右到左（rightleft）遍历，这一行遍历完后bottom向上移动一位（bottom-1）;当right&gt;=left时，有必要从下向上遍历（bottomtop）,这一边遍历完后，left向右移动一位（left+1）; 当左边标记（left）大于右边（right）标记或者上边标记（top）大于下边标记（bottom）时，证明已经遍历完。 代码实现JAVA实现123456789101112131415161718192021222324252627282930313233&#x2F;** * @param matrix * @return 顺时针打印矩阵 *&#x2F; public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) &#123; ArrayList result &#x3D; new ArrayList(); int left &#x3D; 0, right &#x3D; matrix[0].length - 1, top &#x3D; 0, bottom &#x3D; matrix.length - 1; while (left &lt;&#x3D; right &amp;&amp; top &lt;&#x3D; bottom) &#123; for (int i &#x3D; left; i &lt;&#x3D; right; i++) &#123;&#x2F;&#x2F;左到右 result.add(matrix[top][i]); &#125; top++; for (int i &#x3D; top; i &lt;&#x3D; bottom; i++) &#123;&#x2F;&#x2F;右上到右下 result.add(matrix[i][right]); &#125; right--; if (bottom &gt;&#x3D; top) &#123; for (int i &#x3D; right; i &gt;&#x3D; left; i--) &#123;&#x2F;&#x2F;右到左 result.add(matrix[bottom][i]); &#125; bottom--; &#125; if (right &gt;&#x3D; left) &#123; for (int i &#x3D; bottom; i &gt;&#x3D; top; i--) &#123;&#x2F;&#x2F;左下到左上 result.add(matrix[i][left]); &#125; left++; &#125; &#125; return result; &#125; kotlin实现 核心实现123456789101112131415161718192021222324252627282930313233&#x2F;** * 顺时针打印矩阵 *&#x2F; fun printMatrix(matrix: Array&lt;IntArray&gt;): java.util.ArrayList&lt;Int&gt; &#123; val result &#x3D; java.util.ArrayList&lt;Int&gt;() var left &#x3D; 0 var right: Int &#x3D; matrix[0].size - 1 var top &#x3D; 0 var bottom &#x3D; matrix.size - 1 while (left &lt;&#x3D; right &amp;&amp; top &lt;&#x3D; bottom) &#123; &#x2F;&#x2F;当左标记不大于有标记并且上标记不大于下标记的时候进行循环打印 for (i in left..right) &#123; &#x2F;&#x2F;左到右 result.add(matrix[top][i]) &#125; top++ &#x2F;&#x2F;行加一 for (i in top..bottom) &#123; &#x2F;&#x2F;右上到右下 result.add(matrix[i][right]) &#125; right-- &#x2F;&#x2F;列减一 if (bottom &gt;&#x3D; top) &#123; for (i in right downTo left) &#123; &#x2F;&#x2F;右到左 result.add(matrix[bottom][i]) &#125; bottom-- &#x2F;&#x2F;行减一 &#125; if (right &gt;&#x3D; left) &#123; for (i in bottom downTo top) &#123; &#x2F;&#x2F;左下到左上 result.add(matrix[i][left]) &#125; left++ &#x2F;&#x2F;列加一 &#125; &#125; return result &#125; 测试12345@Test fun getResult4() &#123; val arr &#x3D; arrayOf(intArrayOf(1, 2, 3, 4, 5), intArrayOf(6, 7, 8, 9, 10), intArrayOf(11, 12, 13, 14, 15), intArrayOf(16, 17, 18, 19, 20)) println(printMatrix(arr)) &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"【剑指Offer】19. 树的子结构","slug":"算法/剑指Offer/19. 树的子结构","date":"2020-04-27T16:00:00.000Z","updated":"2020-05-18T14:04:18.730Z","comments":true,"path":"2020/04/28/suan-fa/jian-zhi-offer/19.shu-de-zi-jie-gou/","link":"","permalink":"https://eriecorner.github.io/2020/04/28/suan-fa/jian-zhi-offer/19.shu-de-zi-jie-gou/","excerpt":"","text":"题目描述 题目来源： Nowcoder 题设： 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 解题思路 先从跟节点开始判断，若两个根节点的值对应，则继续比较两个节点的左节点和右节点是否都对应； 若在上一步没有找到，则从左子树开始找； 若左子树中没有找到，则从右子树开始找； 代码实现JAVA实现 定义树节点1234567891011121314private class TreeNode &#123; int val; TreeNode left; TreeNode right; public TreeNode(int node) &#123; this.val &#x3D; node; &#125; public String toString() &#123; return &quot;TreeNode [data&#x3D;&quot; + val + &quot;, left&#x3D;&quot; + left + &quot;, right&#x3D;&quot; + right + &quot;]&quot;; &#125; 核心方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#x2F;** * @param root1 * @param root2 * @return 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） *&#x2F;public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; boolean result &#x3D; false; &#x2F;&#x2F;有一个树是空的，就直接返回false if (root1 &#x3D;&#x3D; null || root2 &#x3D;&#x3D; null) &#123; return false; &#125; &#x2F;&#x2F;若找到了Tree2的根节点，则以此根节点为起点判断是不是包含Tree2 if (root1.val &#x3D;&#x3D; root2.val) &#123; result &#x3D; isSubtree(root1, root2); &#125; &#x2F;&#x2F;如果不包含，则以root Tree的左子树作为起点判断是否包含Tree2 if (!result) &#123; result &#x3D; HasSubtree(root1.left, root2); &#125; &#x2F;&#x2F;否则 以root的右子树为起点，判断是否包含Tree2 if (!result) &#123; result &#x3D; HasSubtree(root1.right, root2); &#125; return result;&#125;&#x2F;** * @param node1 * @param node2 * @return *&#x2F;public boolean isSubtree(TreeNode node1, TreeNode node2) &#123; &#x2F;&#x2F; 如果Tree2已经遍历完了都能对应的上，返回true if (node2 &#x3D;&#x3D; null) &#123; return true; &#125; &#x2F;&#x2F;如果Tree2还没有遍历完，Tree1却遍历完了。返回false if (node1 &#x3D;&#x3D; null) &#123; return false; &#125; &#x2F;&#x2F;如果其中有一个点没有对应上，返回false if (node1.val !&#x3D; node2.val) &#123; return false; &#125; &#x2F;&#x2F;如果根节点对应的上，那么就分别去左右子节点里面匹配 return isSubtree(node1.left, node2.left) &amp;&amp; isSubtree(node1.right, node2.right);&#125; kotlin实现 定义树节点1data class TreeNode(val data: Int, var left: TreeNode? &#x3D; null, var right: TreeNode? &#x3D; null) 核心方法1234567891011121314151617181920212223242526272829303132333435363738&#x2F;** * @param node1 * @param node2 * @return 求 node2 是node1的子树 *&#x2F; fun hasSubtree(node1: TreeNode, node2: TreeNode): Boolean &#123; var result &#x3D; false &#x2F;&#x2F;有一个树是空的就返回false if (node1 &#x3D;&#x3D; null || node2 &#x3D;&#x3D; null) &#123; return false &#125; if (node1.data &#x3D;&#x3D; node2.data) &#123; result &#x3D; isSubtree(node1, node2) &#125; if (!result) &#123; result &#x3D; hasSubtree(node1.left!!, node2) &#125; if (!result) &#123; result &#x3D; hasSubtree(node1.right!!, node2) &#125; return result &#125; fun isSubtree(node1: TreeNode, node2: TreeNode): Boolean &#123; if (node2 &#x3D;&#x3D; null) &#123; return true &#125; if (node1 &#x3D;&#x3D; null) &#123; return false &#125; if (node1.data !&#x3D; node2.data) &#123; return false &#125; return isSubtree(node1.left!!, node2.left!!) &amp;&amp; isSubtree(node1.right!!, node2.right!!) &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【剑指Offer】20. 二叉树的镜像","slug":"算法/剑指Offer/20. 二叉树的镜像","date":"2020-04-27T16:00:00.000Z","updated":"2020-05-18T14:04:25.219Z","comments":true,"path":"2020/04/28/suan-fa/jian-zhi-offer/20.er-cha-shu-de-jing-xiang/","link":"","permalink":"https://eriecorner.github.io/2020/04/28/suan-fa/jian-zhi-offer/20.er-cha-shu-de-jing-xiang/","excerpt":"","text":"题目描述 题目来源： Nowcoder 题设：操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述: 二叉树的镜像定义：源二叉树 1234567891011 8 &#x2F; \\ 6 10 &#x2F; \\ &#x2F; \\5 7 9 11镜像二叉树 8 &#x2F; \\ 10 6 &#x2F; \\ &#x2F; \\11 9 7 5 解题思路 当左右节点不为空时将左右节点交换位置代码实现 JAVA实现 定义树节点1234567891011121314private class TreeNode &#123; int val; TreeNode left; TreeNode right; public TreeNode(int node) &#123; this.val &#x3D; node; &#125; public String toString() &#123; return &quot;TreeNode [data&#x3D;&quot; + val + &quot;, left&#x3D;&quot; + left + &quot;, right&#x3D;&quot; + right + &quot;]&quot;; &#125; 核心方法123456789101112131415161718192021&#x2F;** * @param root 求一个二叉树的镜像 *&#x2F;public void Mirror(TreeNode root) &#123; if (root &#x3D;&#x3D; null) &#123; return; &#125; if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123; return; &#125; TreeNode tmp &#x3D; root.left; root.left &#x3D; root.right; root.right &#x3D; tmp; if (root.left!&#x3D;null)&#123; Mirror(root.left); &#125; if (root.right!&#x3D;null)&#123; Mirror(root.right); &#125;&#125; kotlin实现 定义树节点1data class TreeNode(val data: Int, var left: TreeNode? &#x3D; null, var right: TreeNode? &#x3D; null) 核心方法 123456789101112131415161718192021&#x2F;** * @param root 求一个二叉树的镜像 *&#x2F; fun mirror(root: TreeNode) &#123; if (root &#x3D;&#x3D; null) &#123; return &#125; if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123; return &#125; var tmp: TreeNode? &#x3D; root.left root.left &#x3D; root.right root.right &#x3D; tmp while (root.left !&#x3D; null) &#123; mirror(root.left!!) &#125; while (root.right !&#x3D; null) &#123; mirror(root.right!!) &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【剑指Offer】16. 链表中倒数第k个节点","slug":"算法/剑指Offer/16. 链表中倒数第k个节点","date":"2020-04-26T16:00:00.000Z","updated":"2020-05-18T14:03:57.864Z","comments":true,"path":"2020/04/27/suan-fa/jian-zhi-offer/16.lian-biao-zhong-dao-shu-di-k-ge-jie-dian/","link":"","permalink":"https://eriecorner.github.io/2020/04/27/suan-fa/jian-zhi-offer/16.lian-biao-zhong-dao-shu-di-k-ge-jie-dian/","excerpt":"","text":"题目描述 题目来源： Nowcoder 题设： 输入一个链表，输出该链表中倒数第k个结点。 解题思路 定义两个指针（fast，slow）分别都指向头节点； 当fast指针走到k的位置时，slow指针开始走； 当fast指针走到最后时，当前slow所指指针就是的倒数第k个节点； 当链表的节点数小于k时，则返回null。 代码实现JAVA实现 先定义节点对象123456789public static class ListNode &#123; private int value; private ListNode next; public ListNode(int node) &#123; this.value &#x3D; node; &#125;&#125; 核心方法12345678910111213141516171819&#x2F;** * @param head * @param k * @return 链表中倒数第k个结点 *&#x2F;public ListNode FindKthToTail(ListNode head, int k) &#123; &#x2F;&#x2F;定义两个指针都指向头结点 ListNode fast,slow; fast &#x3D; slow &#x3D; head; int i &#x3D; 0; for (; fast!&#x3D;null; i++) &#123; fast &#x3D; fast.next; if (i&gt;&#x3D;k)&#123;&#x2F;&#x2F;当fast走到k位置时 slow &#x3D; slow.next;&#x2F;&#x2F;slow也开始走 &#125; &#125; return i&lt;k?null:slow;&#125; 构建链表1234567891011&#x2F;&#x2F;构建链表 private ListNode BuildLinkList() &#123; ListNode head &#x3D; new ListNode(0); ListNode cur &#x3D; head; for (int i &#x3D; 1; i &lt; 10; i++) &#123; ListNode tmp &#x3D; new ListNode(i); cur.next&#x3D; tmp; cur &#x3D; tmp; &#125; return head; &#125; 测试12345@Testpublic void printResult() &#123; ListNode head &#x3D; BuildLinkList(); System.out.println(FindKthToTail(head,2));&#125; kotlin实现 定义节点对象1234data class ListNode( val value: Int) &#123; var next: ListNode? &#x3D; null &#125; 核心方法12345678910111213fun findKthToTail(head: ListNode?, k: Int): ListNode? &#123; var fast &#x3D; head var slow &#x3D; head var count: Int &#x3D; 0; while (fast !&#x3D; null) &#123; fast &#x3D; fast.next if (count &gt;&#x3D; k) &#123; &#x2F;&#x2F;当fast走到k位置时 slow &#x3D; slow?.next &#x2F;&#x2F;slow也开始走 &#125; count++ &#125; return if (count &lt; k) null else slow &#125; 构建测试链表12345678910private fun buildLinkList(): ListNode? &#123; val head &#x3D; ListNode(0) var cur &#x3D; head for (i in 1..9) &#123; val tmp &#x3D; ListNode(i) cur.next &#x3D; tmp cur &#x3D; tmp &#125; return head &#125; 测试12345@Test fun printResult() &#123; print(findKthToTail(buildLinkList(), 6)) &#125; &#x2F;&#x2F;打印结果：ListNode(value&#x3D;4)","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"-链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【剑指Offer】18. 合并两个排序的链表","slug":"算法/剑指Offer/18. 合并两个排序的链表","date":"2020-04-26T16:00:00.000Z","updated":"2020-05-18T14:04:10.284Z","comments":true,"path":"2020/04/27/suan-fa/jian-zhi-offer/18.he-bing-liang-ge-pai-xu-de-lian-biao/","link":"","permalink":"https://eriecorner.github.io/2020/04/27/suan-fa/jian-zhi-offer/18.he-bing-liang-ge-pai-xu-de-lian-biao/","excerpt":"","text":"题目描述 题目来源： Nowcoder 题设： 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 解题思路 定义一个head节点存储合并后的链表的头结点和一个p节点存储合并后的工作指针； 将两个链表中较小值的节点指向定义的头结点；并将头结点也指向P节点； 接下来比较两个链表中将较小值的节点加入到工作节点，并将该结点和工作节点都向后移动一个节点，直到至少有一个链表到尾部； 最后将没有遍历完的链表添加到工作链表。 代码实现JAVA实现 首先定义节点123456789public static class ListNode &#123; private int val; private ListNode next; public ListNode(int node) &#123; this.val &#x3D; node; &#125;&#125; 核心方法123456789101112131415161718192021222324252627282930313233343536373839404142434445&#x2F;** * @param list1 * @param list2 * @return 合并两个排序的链表 *&#x2F; public ListNode Merge(ListNode list1, ListNode list2) &#123; if (list1 &#x3D;&#x3D; null) &#123; return list2; &#125; if (list2 &#x3D;&#x3D; null) &#123; return list1; &#125; ListNode head;&#x2F;&#x2F;存储头结点 ListNode p; &#x2F;&#x2F; 取较小值作头结点，并将该链表向后移动一位 if (list1.val &lt; list2.val) &#123; head &#x3D; list1; list1 &#x3D; list1.next; &#125; else &#123; head &#x3D; list2; list2 &#x3D; list2.next; &#125; p &#x3D; head;&#x2F;&#x2F;合并后链表的工作节点 while (list1 !&#x3D; null &amp;&amp; list2 !&#x3D; null) &#123; &#x2F;&#x2F;取较小值的节点加入合并节点，并将该节点向后移动一位，工作节点也向后移动一位 if (list1.val &lt;&#x3D; list2.val) &#123; p.next &#x3D; list1; list1 &#x3D; list1.next; p &#x3D; p.next; &#125; else &#123; p.next &#x3D; list2; list2 &#x3D; list2.next; p &#x3D; p.next; &#125; &#125; &#x2F;&#x2F;未结束的链表连接到合并后的链表尾部 if (list1 &#x3D;&#x3D; null) &#123; p.next &#x3D; list2; &#125; if (list2 &#x3D;&#x3D; null) &#123; p.next &#x3D; list1; &#125; return head; &#125; kotlin实现 定义节点对象1data class ListNode(val value: Int,var next: ListNode? &#x3D; null) 核心方法1234567891011121314151617181920212223242526272829303132333435363738fun merge(list1: ListNode?, list2: ListNode?): ListNode? &#123; var list1 &#x3D; list1 var list2 &#x3D; list2 if (list1 &#x3D;&#x3D; null) &#123; return list2 &#125; if (list2 &#x3D;&#x3D; null) &#123; return list1 &#125; var head: ListNode var p: ListNode if (list1.value &lt; list2.value) &#123; head &#x3D; list1 list1 &#x3D; list1.next!! &#125; else &#123; head &#x3D; list2 list2 &#x3D; list2.next!! &#125; p &#x3D; head while (list1 !&#x3D; null &amp;&amp; list2 !&#x3D; null) &#123; if (list1.value &lt;&#x3D; list2.value) &#123; p.next &#x3D; list1 list1 &#x3D; list1.next p &#x3D; p.next!! &#125; else &#123; p.next &#x3D; list2 list2 &#x3D; list2.next p &#x3D; p.next!! &#125; &#125; if (list1 &#x3D;&#x3D; null) &#123; p.next &#x3D; list2!! &#125; if (list2 &#x3D;&#x3D; null) &#123; p.next &#x3D; list1!! &#125; return head &#125; 构建链表123456789101112fun buildLinkList1(num: Int): ListNode? &#123; var num &#x3D; num val head &#x3D; ListNode(0) var cur &#x3D; head for (i in 1..9) &#123; if (i % 2 &#x3D;&#x3D; num) &#123; cur.next &#x3D; ListNode(i) cur &#x3D; cur.next!! &#125; &#125; return head &#125; 测试123456789@Test fun printLinkList() &#123; var list1 &#x3D; buildLinkList1(0) println(list1) var list2 &#x3D; buildLinkList1(1) println(list2) println(merge(list1,list2)) &#125; 输出结果12345678List1:ListNode(value&#x3D;0, next&#x3D;ListNode(value&#x3D;2, next&#x3D;ListNode(value&#x3D;4, next&#x3D;ListNode(value&#x3D;6, next&#x3D;ListNode(value&#x3D;8, next&#x3D;null)))))List2:ListNode(value&#x3D;0, next&#x3D;ListNode(value&#x3D;1, next&#x3D;ListNode(value&#x3D;3, next&#x3D;ListNode(value&#x3D;5, next&#x3D;ListNode(value&#x3D;7, next&#x3D;ListNode(value&#x3D;9, next&#x3D;null))))))合并后的链表;ListNode(value&#x3D;0, next&#x3D;ListNode(value&#x3D;0, next&#x3D;ListNode(value&#x3D;1, next&#x3D;ListNode(value&#x3D;2, next&#x3D;ListNode(value&#x3D;3, next&#x3D;ListNode(value&#x3D;4, next&#x3D;ListNode(value&#x3D;5, next&#x3D;ListNode(value&#x3D;6, next&#x3D;ListNode(value&#x3D;7, next&#x3D;ListNode(value&#x3D;8, next&#x3D;ListNode(value&#x3D;9, next&#x3D;null)))))))))))","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【剑指Offer】17. 反转链表，输出新链表的表头","slug":"算法/剑指Offer/17. 反转链表，输出新链表的表头","date":"2020-04-26T16:00:00.000Z","updated":"2020-05-18T14:04:04.192Z","comments":true,"path":"2020/04/27/suan-fa/jian-zhi-offer/17.fan-zhuan-lian-biao-shu-chu-xin-lian-biao-de-biao-tou/","link":"","permalink":"https://eriecorner.github.io/2020/04/27/suan-fa/jian-zhi-offer/17.fan-zhuan-lian-biao-shu-chu-xin-lian-biao-de-biao-tou/","excerpt":"","text":"题目描述 题目来源： Nowcoder 题设：输入一个链表，反转链表后，输出新链表的表头。 解题思路 用两个节点（pre，next）分别存储当前节点的前一个节点后后一个节点 当前节点不为null的时候，循环执行如下操作： 用next保存当前节点的下一个节点，目的是不让当前节点反指向其前一个节点后，原来的节点断裂； 保存了next节点后，就让当前节点从指向next变成指向pre 当前节点指向pre后，就继续一次反转下一个节点； 12graph LRnode1(a) --&gt; node2(b) 代码实现JAVA实现 先定义节点对象123456789public static class ListNode &#123; private int value; private ListNode next; public ListNode(int node) &#123; this.value &#x3D; node; &#125;&#125; 核心方法12345678910111213141516171819202122&#x2F;** * @param head * @return 反转链表后输出表头 *&#x2F; public ListNode ReverseList(ListNode head) &#123; &#x2F;&#x2F;head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null； if (head &#x3D;&#x3D; null) &#123; return null; &#125; ListNode pre &#x3D; null;&#x2F;&#x2F;当前节点的前一节点 ListNode next &#x3D; null;&#x2F;&#x2F;当前节点的下一个节点，为了使当前节点（head）反转指向其前面的节点（pre）后，原来的next节点（head.next）不断裂 &#x2F;&#x2F;pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2 while (head !&#x3D; null) &#123;&#x2F;&#x2F;循环让当前节点从指向next到指向pre next &#x3D; head.next;&#x2F;&#x2F;先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂 head.next &#x3D; pre;&#x2F;&#x2F;保存完next，就可以让head从指向next变成指向pre了，代码如下 &#x2F;&#x2F;head指向pre后，就继续依次反转下一个节点 &#x2F;&#x2F;让pre，head，next依次向后移动一个节点，继续下一次的指针反转 pre &#x3D; head; head &#x3D; next; &#125; return pre; &#125; 构建链表1234567891011&#x2F;&#x2F;构建链表 private ListNode BuildLinkList() &#123; ListNode head &#x3D; new ListNode(0); ListNode cur &#x3D; head; for (int i &#x3D; 1; i &lt; 10; i++) &#123; ListNode tmp &#x3D; new ListNode(i); cur.next&#x3D; tmp; cur &#x3D; tmp; &#125; return head; &#125; 测试12345@Testpublic void printResult() &#123; ListNode head &#x3D; BuildLinkList(); System.out.println(ReverseList(head));&#125; kotlin实现 定义节点对象1234data class ListNode( val value: Int) &#123; var next: ListNode? &#x3D; null &#125; 核心方法12345678910111213141516fun reverseList(head: ListNode?): ListNode? &#123; var head: ListNode? &#x3D; head ?: return null var pre: ListNode? &#x3D; null var next: ListNode? &#x3D; null while (head !&#x3D; null) &#123; next &#x3D; head.next head.next &#x3D; pre pre &#x3D; head head &#x3D; next!! &#125; return pre &#125; 构建测试链表12345678910private fun buildLinkList(): ListNode? &#123; val head &#x3D; ListNode(0) var cur &#x3D; head for (i in 1..9) &#123; val tmp &#x3D; ListNode(i) cur.next &#x3D; tmp cur &#x3D; tmp &#125; return head &#125; 测试12345 @Test fun printResult() &#123; print(reverseList(buildLinkList())) &#125;&#x2F;&#x2F;结果：ListNode(value&#x3D;9)","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【剑指Offer】15. 调整数组顺序使奇数位于偶数前面","slug":"算法/剑指Offer/15. 调整数组顺序使奇数位于偶数前面","date":"2020-04-25T16:00:00.000Z","updated":"2020-05-18T14:03:49.837Z","comments":true,"path":"2020/04/26/suan-fa/jian-zhi-offer/15.diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian/","link":"","permalink":"https://eriecorner.github.io/2020/04/26/suan-fa/jian-zhi-offer/15.diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian/","excerpt":"","text":"题目描述 题目来源： Nowcoder 题设： 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 解题思路 要使奇数偶数的相对位置不变，则需将相邻的两个偶数和奇数交换位置； 若当前位置的数是偶数，其后面的数是奇数，则这两个数交换位置，循环遍历，则一次遍历结束，最右边沉淀一位偶数。 代码实现JAVA实现1234567891011121314151617&#x2F;** * @param array 调整数组顺序使奇数位于偶数前面 *&#x2F; public void reOrderArray(int[] array) &#123; if (array !&#x3D; null &amp;&amp; array.length &gt; 0) &#123; for (int i &#x3D; 0; i &lt; array.length; i++) &#123; for (int j &#x3D; 0; j &lt; array.length-1-i; j++) &#123; if(array[j]%2&#x3D;&#x3D;0&amp;&amp;array[j+1]%2&#x3D;&#x3D;1)&#123;&#x2F;&#x2F;前偶后奇交换 int t &#x3D; array[j]; array[j]&#x3D;array[j+1]; array[j+1]&#x3D;t; &#125; &#125; &#125; &#125; &#125; kotlin实现12345678910111213141516 &#x2F;** * @param array 调整数组顺序使奇数位于偶数前面 *&#x2F;fun reOrderArray(array:ArrayList&lt;Int&gt;)&#123; if (array!&#x3D;null&amp;&amp;array.size&gt;0)&#123; for (i in 0 until array.size)&#123; for (j in 0 until (array.size-1-i))&#123; if (array[j]%2&#x3D;&#x3D;0&amp;&amp;array[j+1]%2&#x3D;&#x3D;1)&#123; var temp &#x3D; array[j] array[j] &#x3D; array[j+1] array[j+1] &#x3D; temp &#125; &#125; &#125; &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"【剑指Offer】14.数值的整数次方","slug":"算法/剑指Offer/14.数值的整数次方","date":"2020-04-24T16:00:00.000Z","updated":"2020-05-18T14:03:40.540Z","comments":true,"path":"2020/04/25/suan-fa/jian-zhi-offer/14.shu-zhi-de-zheng-shu-ci-fang/","link":"","permalink":"https://eriecorner.github.io/2020/04/25/suan-fa/jian-zhi-offer/14.shu-zhi-de-zheng-shu-ci-fang/","excerpt":"","text":"题目描述 题目来源： Nowcoder 题设：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。（保证base和exponent不同时为0 ） 解题思路 负数的幂次方等于其绝对值的幂次方的倒数 代码实现JAVA实现1234567891011121314151617181920public double power(double base, int exponent) &#123; double result &#x3D; 1; if (base &#x3D;&#x3D; 0) &#123; return 0.0; &#125; if (exponent &#x3D;&#x3D; 0) &#123; return 1.0; &#125; int t &#x3D; Math.abs(exponent); while (t&gt;&#x3D;1)&#123; result *&#x3D; base; t--; &#125; if (exponent&gt;0)&#123; return result; &#125;else &#123; return 1.0&#x2F;result; &#125; &#125; kotlin实现12345678910111213141516171819fun power(base: Double, exponent: Int): Double &#123; var result &#x3D; 1.0 if (base &#x3D;&#x3D; 0.0) &#123; return 0.0 &#125; if (exponent &#x3D;&#x3D; 0) &#123; return 1.0 &#125; var t &#x3D; abs(exponent) while (t &gt;&#x3D; 1) &#123; result *&#x3D; base t-- &#125; return if (exponent &gt; 0) &#123; result &#125; else &#123; 1.0 &#x2F; result &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【剑指Offer】12. 剪绳子","slug":"算法/剑指Offer/12. 剪绳子","date":"2020-04-23T16:00:00.000Z","updated":"2020-05-18T14:03:12.596Z","comments":true,"path":"2020/04/24/suan-fa/jian-zhi-offer/12.jian-sheng-zi/","link":"","permalink":"https://eriecorner.github.io/2020/04/24/suan-fa/jian-zhi-offer/12.jian-sheng-zi/","excerpt":"","text":"题目描述： 来源：NewCoder 题设：给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 解题思路 先举几个例子找找规律： 2 : 1*1 3 : 1*2 4 ： 2*2 5 ： 2*3 6 ： 3*3 7 ： 2*2*3 或者4*3 8 ： 2*3*3 9 ： 3*3*3 10：2*2*3*3 或者4*3*3 11：2*3*3*3 12：3*3*3*3 13：2*2*3*3*3 或者4*3*3*3 由此可见：2，3包含于各个问题中，如果再往下剪得话，乘积就会变小。所以选择2，3作为做小的子问题。 当n≥5时，3(n−3)≥2(n−2)，所以我们尽可能多的剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。 代码实现JAVA实现123456789101112131415161718192021222324252627&#x2F;** * 剪绳子问题 * * @param n 绳子长度 是整数且&gt;1 * 把绳子剪成整数长的m段，m是整数，且&gt;1 * @return *&#x2F; public int cutRope(int n) &#123; if (n &lt; 2) &#123; return 0; &#125; if (n &#x3D;&#x3D; 2) &#123;&#x2F;&#x2F;因为m&gt;1,所以只能是1*1 return 1; &#125; if (n &#x3D;&#x3D; 3) &#123; return 2; &#125; int times3 &#x3D; n &#x2F; 3; if (n % 3 &#x3D;&#x3D; 1) &#123; times3--; &#125; int times2 &#x3D; (n -3*times3) &#x2F; 2; return (int) (Math.pow(2, times2) * Math.pow(3, times3)); &#125; Kotlin 实现123456789101112131415161718192021222324&#x2F;** * 剪绳子问题 * * @param n 绳子长度 是整数且&gt;1 * 把绳子剪成整数长的m段，m是整数，且&gt;1 * @return *&#x2F; fun cutRope(n:Int):Int&#123; if(n&lt;2)&#123; return 0 &#125; if (n&#x3D;&#x3D;2)&#123;&#x2F;&#x2F;因为m&gt;1,所以只能1*1 return 1 &#125; if (n&#x3D;&#x3D;3)&#123; return 2 &#125; var times3 &#x3D; n&#x2F;3 if (times3%3&#x3D;&#x3D;1)&#123; times3-- &#125; val times2 &#x3D; (n- 3*times3)&#x2F;2 return (2.0.pow(times2.toDouble())* 3.0.pow(times3.toDouble())).toInt() &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"【剑指Offer】11.机器人的运动范围","slug":"算法/剑指Offer/11. 机器人的运动范围","date":"2020-04-22T16:00:00.000Z","updated":"2020-05-18T13:34:14.800Z","comments":true,"path":"2020/04/23/suan-fa/jian-zhi-offer/11.ji-qi-ren-de-yun-dong-fan-wei/","link":"","permalink":"https://eriecorner.github.io/2020/04/23/suan-fa/jian-zhi-offer/11.ji-qi-ren-de-yun-dong-fan-wei/","excerpt":"","text":"题目描述NowCoder 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 解题思路 从(0,0)开始走，每成功走一步标记当前位置为true,然后从当前位置往四个方向探索，返回1 + 44个方向的探索值之和。 探索时，判断当前节点是否可达的标准为： 当前节点在矩阵内； 当前节点未被访问过； 当前节点满足limit限制。 代码实现java 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x2F;** * 机器人的运动范围 * * @param threshold * @param rows * @param cols * @return *&#x2F; public int movingCount(int threshold, int rows, int cols) &#123; if (rows &lt; 0 || cols &lt; 0 || threshold &lt; 0) &#123; return 0; &#125; &#x2F;&#x2F;标记矩阵中的格子是否走过 boolean[][] visit &#x3D; new boolean[rows][cols]; return findPathCount(threshold, rows, cols, 0, 0, visit); &#125; &#x2F;** * @param k * @param rows * @param cols * @param i * @param j * @param visit * @return 可走格子数 *&#x2F; public int findPathCount(int k, int rows, int cols, int i, int j, boolean[][] visit) &#123; &#x2F;&#x2F;若越界或者已经走过或者当前位置的坐标不满足条件，则返回0 if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; rows || j &gt;&#x3D; cols || visit[i][j] || !(sumIsOk(k, i, j))) &#123; return 0; &#125; &#x2F;&#x2F; 标记当前位置已走过 visit[i][j] &#x3D; true; &#x2F;&#x2F;当前位置的上下左右可走格子的和+1（当前格子） return 1 + findPathCount(k, rows, cols, i + 1, j, visit) + findPathCount(k, rows, cols, i - 1, j, visit) + findPathCount(k, rows, cols, i, j - 1, visit) + findPathCount(k, rows, cols, i, j + 1, visit); &#125; &#x2F;** * @param k * @param row * @param col * @return 行坐标和列坐标的数位之和是否大于k *&#x2F; public boolean sumIsOk(int k, int row, int col) &#123; int sum &#x3D; 0; while (row !&#x3D; 0) &#123; sum +&#x3D; row % 10; row &#x3D; row &#x2F; 10; &#125; while (col !&#x3D; 0) &#123; sum +&#x3D; col % 10; col &#x3D; col &#x2F; 10; &#125; return sum &lt;&#x3D; k; &#125; Kotlin实现123456789101112131415161718192021222324252627282930313233343536373839404142434445&#x2F;** *机器人的运动范围 *&#x2F; fun movingCount(k: Int, rows: Int, cols: Int): Int &#123; if (k &lt; 0 || rows &lt; 0 || cols &lt; 0) &#123; return 0; &#125; val visit &#x3D; Array(rows) &#123; BooleanArray(cols) &#125; return findPathCount(k, rows, cols, 0, 0, visit) &#125; &#x2F;** *回溯法寻找可行走的格子 *&#x2F; fun findPathCount(k: Int, rows: Int, cols: Int, i: Int, j: Int, visit: Array&lt;BooleanArray&gt;): Int &#123; &#x2F;&#x2F;若越界或者已经走过或者当前位置的坐标不满足条件，则返回0 if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; rows || j &gt;&#x3D; cols || visit[i][j] || !sumIsOk(k, i, j)) &#123; return 0 &#125; &#x2F;&#x2F; 标记当前位置已走过 visit[i][j] &#x3D; true &#x2F;&#x2F;当前位置的上下左右可走格子的和+1（当前格子） return (1 + findPathCount(k, rows, cols, i + 1, j, visit) + findPathCount(k, rows, cols, i - 1, j, visit) + findPathCount(k, rows, cols, i, j - 1, visit) + findPathCount(k, rows, cols, i, j + 1, visit)) &#125; &#x2F;** * 判断 限制条件是否ok *&#x2F; fun sumIsOk(k: Int, row: Int, col: Int): Boolean &#123; var row &#x3D; row var col &#x3D; col var sum &#x3D; 0 while (row !&#x3D; 0) &#123; sum +&#x3D; row % 10 row &#x3D; row &#x2F; 10 &#125; while (col !&#x3D; 0) &#123; sum +&#x3D; col % 10 col &#x3D; col &#x2F; 10 &#125; return sum &lt;&#x3D; k &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"【剑指Offer】7. 重建二叉树","slug":"算法/剑指Offer/7. 重建二叉树","date":"2020-04-16T16:00:00.000Z","updated":"2020-05-18T13:33:55.035Z","comments":true,"path":"2020/04/17/suan-fa/jian-zhi-offer/7.chong-jian-er-cha-shu/","link":"","permalink":"https://eriecorner.github.io/2020/04/17/suan-fa/jian-zhi-offer/7.chong-jian-er-cha-shu/","excerpt":"","text":"题目描述根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 题解 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。 代码实现JAVA实现 首先定义树结构 123456789101112131415private class TreeNode &#123; int node;&#x2F;&#x2F;节点 TreeNode left;&#x2F;&#x2F;左子树 TreeNode right;&#x2F;&#x2F;右子树 public TreeNode(int node) &#123; this.node &#x3D; node; &#125; public String toString() &#123; return &quot;TreeNode [data&#x3D;&quot; + node + &quot;, left&#x3D;&quot; + left + &quot;, right&#x3D;&quot; + right + &quot;]&quot;; &#125; &#125; 核心算法 12345678910111213141516171819202122232425262728293031public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; if (pre.length &#x3D;&#x3D; 0 || in.length &#x3D;&#x3D; 0) &#123; return null; &#125; TreeNode root &#x3D; rebuildBinaryTreeCoreAfter(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; public TreeNode rebuildBinaryTreeCore(int preorder[], int startPreorder, int endPreorder, int inorder[], int startInorder, int endInorder) &#123; if (startPreorder &gt; endPreorder || startInorder &gt; endInorder) &#123; &#x2F;&#x2F;停止递归的条件 return null; &#125; TreeNode root &#x3D; new TreeNode(preorder[startPreorder]); for (int i &#x3D; startInorder; i &lt;&#x3D; endInorder; i++) &#123; if (preorder[startPreorder] &#x3D;&#x3D; inorder[i]) &#123; &#x2F;&#x2F; 其中（i - startInorder）为中序排序中左子树结点的个数 &#x2F;&#x2F;左子树 root.left &#x3D; rebuildBinaryTreeCore(preorder, startPreorder + 1, startPreorder + (i - startInorder), inorder, startInorder, i-1 ); &#x2F;&#x2F;右子树 root.right &#x3D; rebuildBinaryTreeCore(preorder, (i - startInorder) + startPreorder + 1, endPreorder, inorder, i + 1, endInorder); &#125; &#125; return root; &#125; 验证 123456789101112131415public void getResult() &#123; int[] pre &#x3D; &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;; int[] mid &#x3D; &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;; System.out.println(reConstructBinaryTree(pre,mid)); &#125; &#x2F;&#x2F;树结构： 1 2 3 4 5 6 7 8 Kotlin实现 首先定义树结构 12data class TreeNode(val data: Int, var left: TreeNode? &#x3D; null, var right: TreeNode? &#x3D; null) &#123; &#125; 核心算法 12345678910111213141516171819202122232425262728private fun reConstructBinaryTree(pre: IntArray, mid: IntArray): TreeNode? &#123; if (pre.isEmpty() || mid.isEmpty()) &#123; return null &#125; return reConstructBinaryTreeCore(pre, 0, pre.size - 1, mid, 0, mid.size - 1) &#125; private fun reConstructBinaryTreeCore(pre: IntArray, preStart: Int, preEnd: Int, mid: IntArray, midStart: Int, midEnd: Int): TreeNode? &#123; if (preStart &gt; preEnd || midStart &gt; midEnd) &#123; return null &#125; val root &#x3D; TreeNode(pre[preStart]); for (i in mid.indices) &#123; if (mid[i] &#x3D;&#x3D; pre[preStart]) &#123; &#x2F;&#x2F;（）i - midStart） 是为中序排序中左子树结点的个数 &#x2F;&#x2F;左子树 root.left &#x3D; reConstructBinaryTreeCore(pre, preStart + 1, preStart + (i - midStart), mid, midStart, i - 1) &#x2F;&#x2F;右子树 root.right &#x3D; reConstructBinaryTreeCore(pre, preStart + (i - midStart) + 1, preEnd, mid, i + 1, midEnd) &#125; &#125; return root; &#125; 验证 123456789101112131415fun getResult() &#123; val pre &#x3D; intArrayOf(1, 2, 4, 7, 3, 5, 6, 8) val mid &#x3D; intArrayOf(4, 7, 2, 1, 5, 3, 8, 6) print(reConstructBinaryTree(pre, mid )); &#125; &#x2F;&#x2F;树结构 1 2 3 4 5 6 7 8 举一反三根据二叉树的后序遍历和中序遍历的结果，重建出该二叉树。假设输入的后序遍历和中序遍历的结果中都不含重复的数字。 题解思路同上，后序序遍历的最后一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。 代码实现JAVA实现 核心算法123456789101112131415private TreeNode rebuildBinaryTreeCoreAfter(int[] after,int afterStart,int afterEnd,int[]mid ,int midStart,int midEnd )&#123; if (afterStart&gt;afterEnd||midStart&gt;midEnd)&#123; return null; &#125; TreeNode root &#x3D; new TreeNode(after[afterEnd]); for (int i &#x3D; 0; i &lt;&#x3D; midEnd; i++) &#123; if (after[afterEnd]&#x3D;&#x3D;mid[i])&#123; root.left &#x3D; rebuildBinaryTreeCoreAfter(after,afterStart,afterStart-1+(i-midStart), mid,midStart,i-1); root.right &#x3D; rebuildBinaryTreeCoreAfter(after,afterStart+(i-midStart),afterEnd-1, mid,i+1,midEnd); &#125; &#125; return root; &#125; 验证1234567891011121314151617public void getResult() &#123; &#x2F;&#x2F;int[] pre &#x3D; &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;; &#x2F;&#x2F;int[] mid &#x3D; &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;; &#x2F;&#x2F;System.out.println(reConstructBinaryTree(pre,mid)); int[] after &#x3D; &#123;2,4,3,1,6,7,5&#125;; int[] mid &#x3D; &#123;1,2,3,4,5,6,7&#125;; System.out.println(reConstructBinaryTree(after,mid)); &#125; &#x2F;&#x2F;树结构 5 1 7 3 6 2 4 Kotlin实现 核心算法12345678910111213141516171819202122232425private fun reConstructBinaryTreeAfter(pre: Array&lt;Int&gt;, mid: Array&lt;Int&gt;): TreeNode? &#123; if (pre.isEmpty() || mid.isEmpty()) &#123; return null &#125; val root &#x3D; reConstructBinaryTreeCoreAfter(pre, 0, pre.size - 1, mid, 0, mid.size - 1) return root&#125; private fun reConstructBinaryTreeCoreAfter(after: Array&lt;Int&gt;, afterStart: Int, afterEnd: Int, mid: Array&lt;Int&gt;, midStart: Int, midEnd: Int): TreeNode? &#123; if (afterStart &gt; afterEnd || midStart &gt; midEnd) return null val root &#x3D; TreeNode(after[afterEnd]) for (i in mid.indices) &#123; if (mid[i] &#x3D;&#x3D; after[afterEnd]) &#123; root.left &#x3D; reConstructBinaryTreeCoreAfter(after, afterStart, afterStart - 1 + (i - midStart), mid, midStart, i - 1) root.right &#x3D; reConstructBinaryTreeCoreAfter(after, afterStart + (i - midStart), afterEnd - 1, mid, i + 1, midEnd) &#125; &#125; return root;&#125; 验证1234567891011121314151617fun getResult() &#123;&#x2F;&#x2F; val pre &#x3D; intArrayOf(1, 2, 4, 7, 3, 5, 6, 8)&#x2F;&#x2F; val mid &#x3D; intArrayOf(4, 7, 2, 1, 5, 3, 8, 6)&#x2F;&#x2F; print(reConstructBinaryTree(pre, mid )); val after &#x3D; arrayOf(2,4,3,1,6,7,5) val ins &#x3D; arrayOf(1,2,3,4,5,6,7) print(reConstructBinaryTreeAfter(after, ins)); &#125; &#x2F;&#x2F;树结构 5 1 7 3 6 2 4","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"【剑指Offer】5. 替换空格","slug":"算法/剑指Offer/5. 替换空格","date":"2020-04-15T16:00:00.000Z","updated":"2020-05-18T13:33:10.469Z","comments":true,"path":"2020/04/16/suan-fa/jian-zhi-offer/5.ti-huan-kong-ge/","link":"","permalink":"https://eriecorner.github.io/2020/04/16/suan-fa/jian-zhi-offer/5.ti-huan-kong-ge/","excerpt":"","text":"题目描述：将一个字符串中的空格替换成 “%20”。 题解：从后往前复制，数组长度会增加，或使用StringBuffer，StringBuild类。 代码实现：时间复杂度O（N），空间复杂度O（N） 123456789101112131415public String replaceSpace(String value)&#123; if (value&#x3D;&#x3D;null)&#123; return null; &#125; StringBuilder builder &#x3D; new StringBuilder(); for (int i &#x3D; 0; i &lt;value.length() ; i++) &#123; if (String.valueOf(value.charAt(i)).equals(&quot; &quot;))&#123; builder.append(&quot;%20&quot;); &#125;else &#123; builder.append(value.charAt(i)); &#125; &#125; return builder.toString(); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://eriecorner.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"【剑指Offer】6. 从尾到头打印链表","slug":"算法/剑指Offer/6. 从尾到头打印链表","date":"2020-04-15T16:00:00.000Z","updated":"2020-05-18T13:33:25.224Z","comments":true,"path":"2020/04/16/suan-fa/jian-zhi-offer/6.cong-wei-dao-tou-da-yin-lian-biao/","link":"","permalink":"https://eriecorner.github.io/2020/04/16/suan-fa/jian-zhi-offer/6.cong-wei-dao-tou-da-yin-lian-biao/","excerpt":"","text":"题目描述：从尾到头反过来打印出每个结点的值。 题解：1. 使用栈栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。 代码实现：12345678910111213141516171819202122232425262728293031323334353637&#x2F;&#x2F;先定义一个节点 public static class ListNode &#123; private int value; private ListNode next; public ListNode(int node) &#123; this.value &#x3D; node; &#125; &#125; &#x2F;&#x2F;构建链表 private ListNode BuildLinkList() &#123; ListNode head &#x3D; new ListNode(0); ListNode cur &#x3D; head; for (int i &#x3D; 1; i &lt; 10; i++) &#123; ListNode tmp &#x3D; new ListNode(i); cur.next&#x3D; tmp; cur &#x3D; tmp; &#125; return head; &#125; public ArrayList&lt;Integer&gt; printListFromTrilToHead(ListNode listNode)&#123; Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;(); while (listNode!&#x3D;null)&#123; stack.add(listNode.value); listNode &#x3D; listNode.next; &#125; ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;(); while (!stack.isEmpty())&#123; ret.add(stack.pop()); &#125; return ret; &#125; 2.递归时间复杂度：O(n)空间复杂度：O(n) 123456789public ArrayList&lt;Integer&gt; printListFromTrilToHead1(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;(); if (listNode !&#x3D; null) &#123; ret.addAll(printListFromTrilToHead1(listNode.next)); ret.add(listNode.value); &#125; return ret; &#125; 3.遍历node的每一个节点插入到集合的第一个位置时间复杂度：O(n)空间复杂度：O(n) 12345678910public ArrayList&lt;Integer&gt; printListFromTrilToHead2(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;(); ListNode tmp &#x3D; listNode; while (tmp !&#x3D; null) &#123; ret.add(0,tmp.value); tmp &#x3D; tmp.next; &#125; return ret; &#125; 4. 头插法123456789101112131415161718public ArrayList&lt;Integer&gt; printListFromTrilToHead3(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;(); ListNode head &#x3D; new ListNode(-1); while (listNode !&#x3D; null) &#123; ListNode tmp &#x3D; listNode.next; listNode.next &#x3D; head.next; head.next &#x3D; listNode; listNode &#x3D; tmp; &#125; head &#x3D; head.next; while (head !&#x3D; null) &#123; ret.add(head.value); head &#x3D; head.next; &#125; return ret; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"【剑指Offer】 2. 旋转数组中的最小元素","slug":"算法/剑指Offer/2. 旋转数组中的最小元素","date":"2020-04-14T16:00:00.000Z","updated":"2020-05-18T13:32:45.129Z","comments":true,"path":"2020/04/15/suan-fa/jian-zhi-offer/2.xuan-zhuan-shu-zu-zhong-de-zui-xiao-yuan-su/","link":"","permalink":"https://eriecorner.github.io/2020/04/15/suan-fa/jian-zhi-offer/2.xuan-zhuan-shu-zu-zhong-de-zui-xiao-yuan-su/","excerpt":"","text":"题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 题解：利用折半查找的思想，时间复杂度度为O（logN），为了方便，这里将 log2N 写为 logN 将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。 （l 代表 low，m 代表 mid，h 代表 high）当 nums[m] &lt;= nums[h] 时，表示 [m, h] 区间内的数组是非递减数组，[l, m] 区间内的数组是旋转数组，此时令 h = m； 否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。 代码实现：123456789101112131415private int findMixNumInRotateArray(int[] nums) &#123; if (nums.length &#x3D;&#x3D; 0) &#123; return 0; &#125; int l &#x3D; 0, h &#x3D; nums.length - 1; while (l &lt; h) &#123; int m &#x3D; l + (h - 1) &#x2F; 2; if (nums[m] &lt; nums[h]) &#123; h &#x3D; m; &#125; else &#123; l &#x3D; m + 1; &#125; &#125; return nums[l]; &#125; 如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。 例如对于数组{1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。 1234567891011121314151617181920212223242526private int findMixNumInRotateArray2(int[] nums) &#123; if (nums.length &#x3D;&#x3D; 0) &#123; return 0; &#125; int l &#x3D; 0, h &#x3D; nums.length - 1; while (l &lt; h) &#123; int m &#x3D; l + (h - 1) &#x2F; 2; if (nums[l] &#x3D;&#x3D; nums[m] || nums[m] &#x3D;&#x3D; nums[h]) &#123; return minNums(nums, l, h); &#125; else if (nums[m] &lt; nums[h]) &#123; h &#x3D; m; &#125; else &#123; l &#x3D; m + 1; &#125; &#125; return nums[l]; &#125; private int minNums(int[] nums, int l, int h) &#123; for (int i &#x3D; l; i &lt; h; i++) &#123; if (nums[i] &gt; nums[i + 1]) &#123; return nums[i + 1]; &#125; &#125; return nums[l]; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"【剑指Offer】1.1 斐波那契数列","slug":"算法/剑指Offer/ 1.1 斐波那契数列","date":"2020-04-13T16:00:00.000Z","updated":"2020-05-18T13:30:55.135Z","comments":true,"path":"2020/04/14/suan-fa/jian-zhi-offer/1.1-fei-bo-na-qi-shu-lie/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/suan-fa/jian-zhi-offer/1.1-fei-bo-na-qi-shu-lie/","excerpt":"","text":"题目描述：现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。n&lt;=39 题解：斐波那契数列如：1,1,2,3,5,8,13…；所以得知F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）。 代码实现 递归实现 —— 时间复杂度O(2^n）123456789public long fibonacci(int n) &#123; if (n &lt; 0) &#123; return 0; &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123; return 1; &#125; else &#123; return fibonacci(n - 1) + fibonacci(n - 2); &#125; &#125; 顺序求法——时间复杂度O(n）1234567891011121314151617public long fibonacci2(int n) &#123; long result &#x3D; 0; long preOne &#x3D; 1; long preTwo &#x3D; 1; if (n &lt; 0) &#123; return 0; &#125; if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123; return 1; &#125; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; result &#x3D; preOne + preTwo; preTwo &#x3D; preOne; preOne &#x3D; result; &#125; return result; &#125; 状态矩阵相乘法——时间复杂度O(log n）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 public long fibonacci3(int n) &#123; if (n &lt; 0) &#123; return 0; &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123; return 1; &#125; &#x2F;&#x2F;状态矩阵 int[][] base &#x3D; &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;; &#x2F;&#x2F;最后的结果需要求矩阵的n-2次 int[][] res &#x3D; matrixPower(base, n - 2); return res[0][0] + res[1][0]; &#125; &#x2F;&#x2F;求矩阵m的p次幂的值 private int[][] matrixPower(int[][] m, int p) &#123; int[][] res &#x3D; new int[m.length][m[0].length]; &#x2F;&#x2F;先把res设为单位矩阵，相当于整数中的1 for (int i &#x3D; 0; i &lt; res.length; i++) &#123; res[i][i] &#x3D; 1; &#125; &#x2F;&#x2F;临时矩阵 int[][] tmp &#x3D; m; for (; p !&#x3D; 0; p &gt;&gt;&#x3D; 1) &#123; if ((p &amp; 1) !&#x3D; 0) &#123;&#x2F;&#x2F;按位与操作，其实也就是位置为1的乘把这个矩阵乘一下 res &#x3D; muliMatrix(res, tmp); &#125; &#x2F;&#x2F; &#x2F;&#x2F;等于0 的时候我临时矩阵自己乘一下 tmp &#x3D; muliMatrix(tmp, tmp); &#125; return res; &#125; private int[][] muliMatrix(int[][] m1, int[][] m2) &#123; &#x2F;&#x2F;构造出一个m1行和m2列的矩阵（矩阵相乘规则） int[][] res &#x3D; new int[m1.length][m2[0].length]; &#x2F;&#x2F;给我们要得到的矩阵的每一个元素的值进行赋值操作 for (int i &#x3D; 0; i &lt; m1.length; i++) &#123; for (int j &#x3D; 0; j &lt; m2[0].length; j++) &#123; for (int k &#x3D; 0; k &lt; m2.length; k++) &#123;&#x2F;&#x2F;i，j位置元素的值就是i行元素和j行元素乘积的加和 res[i][j] +&#x3D; m1[i][k] * m2[k][j]; &#125; &#125; &#125; return res; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]},{"title":"【剑指Offer】1.3 跳台阶问题","slug":"算法/剑指Offer/1.3 跳台阶问题","date":"2020-04-13T16:00:00.000Z","updated":"2020-05-18T13:32:32.999Z","comments":true,"path":"2020/04/14/suan-fa/jian-zhi-offer/1.3-tiao-tai-jie-wen-ti/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/suan-fa/jian-zhi-offer/1.3-tiao-tai-jie-wen-ti/","excerpt":"","text":"题目描述:一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 题解：f(1) = 1; f(2) = 2; n&gt;2则f(n) = f(n-1)+f(n-2) 代码实现：123456789101112private int jumpFloor(int n) &#123; if (n &lt;&#x3D; 2) &#123; return n; &#125; int preOne &#x3D; 2, preTwo &#x3D; 1, result &#x3D; 0; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; result &#x3D; preOne + preTwo; preTwo &#x3D; preOne; preOne &#x3D; result; &#125; return result; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]},{"title":"【剑指Offer】1.4 变态跳台阶问题","slug":"算法/剑指Offer/1.4 变态跳台阶问题","date":"2020-04-13T16:00:00.000Z","updated":"2020-05-18T13:32:40.493Z","comments":true,"path":"2020/04/14/suan-fa/jian-zhi-offer/1.4-bian-tai-tiao-tai-jie-wen-ti/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/suan-fa/jian-zhi-offer/1.4-bian-tai-tiao-tai-jie-wen-ti/","excerpt":"","text":"题目描述一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级… 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 题解： 跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么 f(n-1) = f(n-2) + f(n-3) + ... + f(0)； 同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么 f(n) = f(n-1) + f(n-2) + ... + f(0) 综上可得 f(n) - f(n-1) = f(n-1) 即 f(n) = 2*f(n-1)代码实现：123private int jumpFloorIn(int n) &#123; return (int) Math.pow(2, n - 1); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]},{"title":"【剑指Offer】1.2 矩形覆盖问题","slug":"算法/剑指Offer/1.2 矩形覆盖问题","date":"2020-04-13T16:00:00.000Z","updated":"2020-05-18T13:32:28.179Z","comments":true,"path":"2020/04/14/suan-fa/jian-zhi-offer/1.2-ju-xing-fu-gai-wen-ti/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/suan-fa/jian-zhi-offer/1.2-ju-xing-fu-gai-wen-ti/","excerpt":"","text":"题目描述：我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ 题解：f(1) = 1; f(2) = 2; n&gt;2则f(n) = f(n-1)+f(n-2) 代码实现：123456789101112public int coverRect(int n) &#123; if (n &lt;&#x3D; 2) &#123; return n; &#125; int preOne &#x3D; 2, preTwo &#x3D; 1, result &#x3D; 0; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; result &#x3D; preOne + preTwo; preTwo &#x3D; preOne; preOne &#x3D; result; &#125; return result; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"},{"name":"Android进阶","slug":"Android进阶","permalink":"https://eriecorner.github.io/categories/Android%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"三方框架源码解析","slug":"三方框架源码解析","permalink":"https://eriecorner.github.io/tags/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"栈","slug":"栈","permalink":"https://eriecorner.github.io/tags/%E6%A0%88/"},{"name":"数学","slug":"数学","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","permalink":"https://eriecorner.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"字符串","slug":"字符串","permalink":"https://eriecorner.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"-链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]}