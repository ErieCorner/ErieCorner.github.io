{"meta":{"title":"紫依卓兰","subtitle":"","description":"","author":"紫依卓兰","url":"https://eriecorner.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-04-20T08:37:17.000Z","updated":"2020-04-20T12:56:03.600Z","comments":false,"path":"categories/index.html","permalink":"https://eriecorner.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-20T08:37:17.000Z","updated":"2020-04-20T12:56:27.177Z","comments":false,"path":"tags/index.html","permalink":"https://eriecorner.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"9. 两个栈实现一个队列","slug":"9. 两个栈实现一个队列","date":"2020-04-17T16:00:00.000Z","updated":"2020-04-21T12:33:05.298Z","comments":true,"path":"2020/04/18/9.liang-ge-zhan-shi-xian-yi-ge-dui-lie/","link":"","permalink":"https://eriecorner.github.io/2020/04/18/9.liang-ge-zhan-shi-xian-yi-ge-dui-lie/","excerpt":"","text":"题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 题解栈是先进后出，队列是先进先出。即一序列元素入栈后，出站顺序被翻转，则一个栈（暂且称为inStack）中的元素出站时先放入另一个栈(暂且称为outStack)），然后outStack栈的出站顺序和inStack的入栈顺序一致，就是队列的入队出队顺序。 代码实现java实现 定义队列及其入队出队的方法 123456789101112131415161718192021222324252627282930313233343536373839class Queue &#123; private Stack&lt;Integer&gt; inStack &#x3D; new Stack&lt;&gt;(); private Stack&lt;Integer&gt; outStack &#x3D; new Stack&lt;&gt;(); &#x2F;** * @param node * 进栈操作 *&#x2F; public void push(int node) &#123; inStack.push(node); &#125; &#x2F;** * @return 队列中是否有元素 *&#x2F; public boolean hasElement() &#123; if (outStack.isEmpty() &amp;&amp; inStack.isEmpty()) &#123; return false; &#125; return true; &#125; &#x2F;** * @return 出栈操作 * @throws Exception *&#x2F; public int pop() throws Exception &#123; if (outStack.isEmpty()) &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()); &#125; &#125; if (outStack.isEmpty()) &#123; throw new Exception(&quot;queue is empty&quot;); &#125; return outStack.pop(); &#125; &#125; 测试 123456789101112 @Test public void getResult() throws Exception &#123; Queue queue &#x3D; new Queue(); for (int i &#x3D; 0; i &lt; 5; i++) &#123; queue.push(i); &#125; while (queue.hasElement()) &#123; System.out.println(queue.pop()); &#125; &#125;&#x2F;&#x2F;输出01234 Kotlin 实现 构造队列并实现入队出队操作 12345678910111213141516171819202122232425262728class Queue &#123; val inStack &#x3D; Stack&lt;Int&gt;(); val outStack &#x3D; Stack&lt;Int&gt;(); &#x2F;&#x2F;入栈操作 fun push(node: Int) &#123; inStack.push(node) &#125; &#x2F;&#x2F;出站操作 fun pop(): Int &#123; if (outStack.isEmpty()) &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()) &#125; &#125; if (outStack.isEmpty()) &#123; throw Exception(&quot;queue is empty!&quot;) &#125; return outStack.pop() &#125; fun hasElement(): Boolean &#123; if (inStack.isEmpty() &amp;&amp; outStack.isEmpty()) &#123; return false &#125; return true &#125; &#125; 测试 123456789101112@Test fun getResult() &#123; val queue &#x3D; Queue() for (i:Int in 0..4)&#123; queue.push(i) &#125; while (queue.hasElement())&#123; print(queue.pop()) &#125; &#125; &#x2F;&#x2F;输出 01234","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"队列","slug":"队列","permalink":"https://eriecorner.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"https://eriecorner.github.io/tags/%E6%A0%88/"}]},{"title":"7. 重建二叉树","slug":"7. 重建二叉树","date":"2020-04-16T16:00:00.000Z","updated":"2020-04-21T12:46:25.927Z","comments":true,"path":"2020/04/17/7.chong-jian-er-cha-shu/","link":"","permalink":"https://eriecorner.github.io/2020/04/17/7.chong-jian-er-cha-shu/","excerpt":"","text":"题目描述根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 题解 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。 代码实现JAVA实现 首先定义树结构 123456789101112131415private class TreeNode &#123; int node;&#x2F;&#x2F;节点 TreeNode left;&#x2F;&#x2F;左子树 TreeNode right;&#x2F;&#x2F;右子树 public TreeNode(int node) &#123; this.node &#x3D; node; &#125; public String toString() &#123; return &quot;TreeNode [data&#x3D;&quot; + node + &quot;, left&#x3D;&quot; + left + &quot;, right&#x3D;&quot; + right + &quot;]&quot;; &#125; &#125; 核心算法 12345678910111213141516171819202122232425262728293031public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; if (pre.length &#x3D;&#x3D; 0 || in.length &#x3D;&#x3D; 0) &#123; return null; &#125; TreeNode root &#x3D; rebuildBinaryTreeCoreAfter(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; public TreeNode rebuildBinaryTreeCore(int preorder[], int startPreorder, int endPreorder, int inorder[], int startInorder, int endInorder) &#123; if (startPreorder &gt; endPreorder || startInorder &gt; endInorder) &#123; &#x2F;&#x2F;停止递归的条件 return null; &#125; TreeNode root &#x3D; new TreeNode(preorder[startPreorder]); for (int i &#x3D; startInorder; i &lt;&#x3D; endInorder; i++) &#123; if (preorder[startPreorder] &#x3D;&#x3D; inorder[i]) &#123; &#x2F;&#x2F; 其中（i - startInorder）为中序排序中左子树结点的个数 &#x2F;&#x2F;左子树 root.left &#x3D; rebuildBinaryTreeCore(preorder, startPreorder + 1, startPreorder + (i - startInorder), inorder, startInorder, i-1 ); &#x2F;&#x2F;右子树 root.right &#x3D; rebuildBinaryTreeCore(preorder, (i - startInorder) + startPreorder + 1, endPreorder, inorder, i + 1, endInorder); &#125; &#125; return root; &#125; 验证 123456789101112131415public void getResult() &#123; int[] pre &#x3D; &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;; int[] mid &#x3D; &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;; System.out.println(reConstructBinaryTree(pre,mid)); &#125; &#x2F;&#x2F;树结构： 1 2 3 4 5 6 7 8 Kotlin实现 首先定义树结构 12data class TreeNode(val data: Int, var left: TreeNode? &#x3D; null, var right: TreeNode? &#x3D; null) &#123; &#125; 核心算法 12345678910111213141516171819202122232425262728private fun reConstructBinaryTree(pre: IntArray, mid: IntArray): TreeNode? &#123; if (pre.isEmpty() || mid.isEmpty()) &#123; return null &#125; return reConstructBinaryTreeCore(pre, 0, pre.size - 1, mid, 0, mid.size - 1) &#125; private fun reConstructBinaryTreeCore(pre: IntArray, preStart: Int, preEnd: Int, mid: IntArray, midStart: Int, midEnd: Int): TreeNode? &#123; if (preStart &gt; preEnd || midStart &gt; midEnd) &#123; return null &#125; val root &#x3D; TreeNode(pre[preStart]); for (i in mid.indices) &#123; if (mid[i] &#x3D;&#x3D; pre[preStart]) &#123; &#x2F;&#x2F;（）i - midStart） 是为中序排序中左子树结点的个数 &#x2F;&#x2F;左子树 root.left &#x3D; reConstructBinaryTreeCore(pre, preStart + 1, preStart + (i - midStart), mid, midStart, i - 1) &#x2F;&#x2F;右子树 root.right &#x3D; reConstructBinaryTreeCore(pre, preStart + (i - midStart) + 1, preEnd, mid, i + 1, midEnd) &#125; &#125; return root; &#125; 验证 123456789101112131415fun getResult() &#123; val pre &#x3D; intArrayOf(1, 2, 4, 7, 3, 5, 6, 8) val mid &#x3D; intArrayOf(4, 7, 2, 1, 5, 3, 8, 6) print(reConstructBinaryTree(pre, mid )); &#125; &#x2F;&#x2F;树结构 1 2 3 4 5 6 7 8 举一反三根据二叉树的后序遍历和中序遍历的结果，重建出该二叉树。假设输入的后序遍历和中序遍历的结果中都不含重复的数字。 题解思路同上，后序序遍历的最后一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。 代码实现JAVA实现 核心算法123456789101112131415private TreeNode rebuildBinaryTreeCoreAfter(int[] after,int afterStart,int afterEnd,int[]mid ,int midStart,int midEnd )&#123; if (afterStart&gt;afterEnd||midStart&gt;midEnd)&#123; return null; &#125; TreeNode root &#x3D; new TreeNode(after[afterEnd]); for (int i &#x3D; 0; i &lt;&#x3D; midEnd; i++) &#123; if (after[afterEnd]&#x3D;&#x3D;mid[i])&#123; root.left &#x3D; rebuildBinaryTreeCoreAfter(after,afterStart,afterStart-1+(i-midStart), mid,midStart,i-1); root.right &#x3D; rebuildBinaryTreeCoreAfter(after,afterStart+(i-midStart),afterEnd-1, mid,i+1,midEnd); &#125; &#125; return root; &#125; 验证1234567891011121314151617public void getResult() &#123; &#x2F;&#x2F;int[] pre &#x3D; &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;; &#x2F;&#x2F;int[] mid &#x3D; &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;; &#x2F;&#x2F;System.out.println(reConstructBinaryTree(pre,mid)); int[] after &#x3D; &#123;2,4,3,1,6,7,5&#125;; int[] mid &#x3D; &#123;1,2,3,4,5,6,7&#125;; System.out.println(reConstructBinaryTree(after,mid)); &#125; &#x2F;&#x2F;树结构 5 1 7 3 6 2 4 Kotlin实现 核心算法12345678910111213141516171819202122232425private fun reConstructBinaryTreeAfter(pre: Array&lt;Int&gt;, mid: Array&lt;Int&gt;): TreeNode? &#123; if (pre.isEmpty() || mid.isEmpty()) &#123; return null &#125; val root &#x3D; reConstructBinaryTreeCoreAfter(pre, 0, pre.size - 1, mid, 0, mid.size - 1) return root&#125; private fun reConstructBinaryTreeCoreAfter(after: Array&lt;Int&gt;, afterStart: Int, afterEnd: Int, mid: Array&lt;Int&gt;, midStart: Int, midEnd: Int): TreeNode? &#123; if (afterStart &gt; afterEnd || midStart &gt; midEnd) return null val root &#x3D; TreeNode(after[afterEnd]) for (i in mid.indices) &#123; if (mid[i] &#x3D;&#x3D; after[afterEnd]) &#123; root.left &#x3D; reConstructBinaryTreeCoreAfter(after, afterStart, afterStart - 1 + (i - midStart), mid, midStart, i - 1) root.right &#x3D; reConstructBinaryTreeCoreAfter(after, afterStart + (i - midStart), afterEnd - 1, mid, i + 1, midEnd) &#125; &#125; return root;&#125; 验证1234567891011121314151617fun getResult() &#123;&#x2F;&#x2F; val pre &#x3D; intArrayOf(1, 2, 4, 7, 3, 5, 6, 8)&#x2F;&#x2F; val mid &#x3D; intArrayOf(4, 7, 2, 1, 5, 3, 8, 6)&#x2F;&#x2F; print(reConstructBinaryTree(pre, mid )); val after &#x3D; arrayOf(2,4,3,1,6,7,5) val ins &#x3D; arrayOf(1,2,3,4,5,6,7) print(reConstructBinaryTreeAfter(after, ins)); &#125; &#x2F;&#x2F;树结构 5 1 7 3 6 2 4","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"8. 查找二叉树的下一个节点","slug":"8. 查找二叉树的下一个节点","date":"2020-04-16T16:00:00.000Z","updated":"2020-04-21T12:44:05.123Z","comments":true,"path":"2020/04/17/8.cha-zhao-er-cha-shu-de-xia-yi-ge-jie-dian/","link":"","permalink":"https://eriecorner.github.io/2020/04/17/8.cha-zhao-er-cha-shu-de-xia-yi-ge-jie-dian/","excerpt":"","text":"题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回 。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 题解二叉树的中序遍历为：先遍历树的左子树，再遍历根节点，最后再遍历右子树。所以最左节点是中序遍历的第一个节点。 如果一个节点的右子树不为空，则该节点的下一个节点是右子树的最左节点； 如果该节点的右子树为空，则不断向上找该节点的父节点的左子树，直到找到第一个左子树包含该节点，则该节点的下一个节点为此父节点。 若这两种都没有找到，则该节点没有下一个节点。代码实现java实现 构造二叉树12345678910public class TreeLinkNode &#123; int val; TreeLinkNode left &#x3D; null; TreeLinkNode right &#x3D; null; TreeLinkNode next &#x3D; null; TreeLinkNode(int val) &#123; this.val &#x3D; val; &#125;&#125; 核心算法12345678910111213141516171819public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode.right!&#x3D;null)&#123; TreeLinkNode node &#x3D; pNode.right; while (node.left!&#x3D;null)&#123; node &#x3D; node.left; &#125; return node; &#125;else &#123; while (pNode.next!&#x3D;null)&#123; TreeLinkNode parent &#x3D; pNode.next; if (parent.left&#x3D;&#x3D;pNode)&#123; return parent; &#125; pNode &#x3D; pNode.next; &#125; &#125; return null; &#125; Kotlin实现 构造二叉树1data class TreeLinkNode(val data: Int, var left: TreeLinkNode?, var right: TreeLinkNode?, var next: TreeLinkNode?) &#123;&#125; 核心算法12345678910111213141516171819private fun getNext( pNode: TreeLinkNode): TreeLinkNode? &#123; if (pNode.right !&#x3D; null) &#123; var node: TreeLinkNode &#x3D; pNode.right!! while (node.left !&#x3D; null) &#123; node &#x3D; node.left!! &#125; return node &#125; else &#123; var nextNode &#x3D; pNode while (nextNode.next !&#x3D; null) &#123; var parent &#x3D; pNode.next!! if (parent.left &#x3D;&#x3D; pNode) &#123; return parent &#125; nextNode &#x3D; pNode.next!! &#125; &#125; return null &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"5. 替换空格","slug":"5. 替换空格","date":"2020-04-15T16:00:00.000Z","updated":"2020-04-21T12:32:15.089Z","comments":true,"path":"2020/04/16/5.ti-huan-kong-ge/","link":"","permalink":"https://eriecorner.github.io/2020/04/16/5.ti-huan-kong-ge/","excerpt":"","text":"题目描述：将一个字符串中的空格替换成 “%20”。 题解：从后往前复制，数组长度会增加，或使用StringBuffer，StringBuild类。 代码实现：时间复杂度O（N），空间复杂度O（N） 123456789101112131415public String replaceSpace(String value)&#123; if (value&#x3D;&#x3D;null)&#123; return null; &#125; StringBuilder builder &#x3D; new StringBuilder(); for (int i &#x3D; 0; i &lt;value.length() ; i++) &#123; if (String.valueOf(value.charAt(i)).equals(&quot; &quot;))&#123; builder.append(&quot;%20&quot;); &#125;else &#123; builder.append(value.charAt(i)); &#125; &#125; return builder.toString(); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://eriecorner.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"6. 从尾到头打印链表","slug":"6. 从尾到头打印链表","date":"2020-04-15T16:00:00.000Z","updated":"2020-04-21T12:44:26.941Z","comments":true,"path":"2020/04/16/6.cong-wei-dao-tou-da-yin-lian-biao/","link":"","permalink":"https://eriecorner.github.io/2020/04/16/6.cong-wei-dao-tou-da-yin-lian-biao/","excerpt":"","text":"题目描述：从尾到头反过来打印出每个结点的值。 题解：1. 使用栈栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。 代码实现：12345678910111213141516171819202122232425262728293031323334353637&#x2F;&#x2F;先定义一个节点 public static class ListNode &#123; private int value; private ListNode next; public ListNode(int node) &#123; this.value &#x3D; node; &#125; &#125; &#x2F;&#x2F;构建链表 private ListNode BuildLinkList() &#123; ListNode head &#x3D; new ListNode(0); ListNode cur &#x3D; head; for (int i &#x3D; 1; i &lt; 10; i++) &#123; ListNode tmp &#x3D; new ListNode(i); cur.next&#x3D; tmp; cur &#x3D; tmp; &#125; return head; &#125; public ArrayList&lt;Integer&gt; printListFromTrilToHead(ListNode listNode)&#123; Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;(); while (listNode!&#x3D;null)&#123; stack.add(listNode.value); listNode &#x3D; listNode.next; &#125; ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;(); while (!stack.isEmpty())&#123; ret.add(stack.pop()); &#125; return ret; &#125; 2.递归时间复杂度：O(n)空间复杂度：O(n) 123456789public ArrayList&lt;Integer&gt; printListFromTrilToHead1(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;(); if (listNode !&#x3D; null) &#123; ret.addAll(printListFromTrilToHead1(listNode.next)); ret.add(listNode.value); &#125; return ret; &#125; 3.遍历node的每一个节点插入到集合的第一个位置时间复杂度：O(n)空间复杂度：O(n) 12345678910public ArrayList&lt;Integer&gt; printListFromTrilToHead2(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;(); ListNode tmp &#x3D; listNode; while (tmp !&#x3D; null) &#123; ret.add(0,tmp.value); tmp &#x3D; tmp.next; &#125; return ret; &#125; 4. 头插法123456789101112131415161718public ArrayList&lt;Integer&gt; printListFromTrilToHead3(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;(); ListNode head &#x3D; new ListNode(-1); while (listNode !&#x3D; null) &#123; ListNode tmp &#x3D; listNode.next; listNode.next &#x3D; head.next; head.next &#x3D; listNode; listNode &#x3D; tmp; &#125; head &#x3D; head.next; while (head !&#x3D; null) &#123; ret.add(head.value); head &#x3D; head.next; &#125; return ret; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"2. 旋转数组中的最小元素","slug":"2. 旋转数组中的最小元素","date":"2020-04-14T16:00:00.000Z","updated":"2020-04-21T12:43:53.289Z","comments":true,"path":"2020/04/15/2.xuan-zhuan-shu-zu-zhong-de-zui-xiao-yuan-su/","link":"","permalink":"https://eriecorner.github.io/2020/04/15/2.xuan-zhuan-shu-zu-zhong-de-zui-xiao-yuan-su/","excerpt":"","text":"题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 题解：利用折半查找的思想，时间复杂度度为O（logN），为了方便，这里将 log2N 写为 logN 将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。 （l 代表 low，m 代表 mid，h 代表 high）当 nums[m] &lt;= nums[h] 时，表示 [m, h] 区间内的数组是非递减数组，[l, m] 区间内的数组是旋转数组，此时令 h = m； 否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。 代码实现：123456789101112131415private int findMixNumInRotateArray(int[] nums) &#123; if (nums.length &#x3D;&#x3D; 0) &#123; return 0; &#125; int l &#x3D; 0, h &#x3D; nums.length - 1; while (l &lt; h) &#123; int m &#x3D; l + (h - 1) &#x2F; 2; if (nums[m] &lt; nums[h]) &#123; h &#x3D; m; &#125; else &#123; l &#x3D; m + 1; &#125; &#125; return nums[l]; &#125; 如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。 例如对于数组{1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。 1234567891011121314151617181920212223242526private int findMixNumInRotateArray2(int[] nums) &#123; if (nums.length &#x3D;&#x3D; 0) &#123; return 0; &#125; int l &#x3D; 0, h &#x3D; nums.length - 1; while (l &lt; h) &#123; int m &#x3D; l + (h - 1) &#x2F; 2; if (nums[l] &#x3D;&#x3D; nums[m] || nums[m] &#x3D;&#x3D; nums[h]) &#123; return minNums(nums, l, h); &#125; else if (nums[m] &lt; nums[h]) &#123; h &#x3D; m; &#125; else &#123; l &#x3D; m + 1; &#125; &#125; return nums[l]; &#125; private int minNums(int[] nums, int l, int h) &#123; for (int i &#x3D; l; i &lt; h; i++) &#123; if (nums[i] &gt; nums[i + 1]) &#123; return nums[i + 1]; &#125; &#125; return nums[l]; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"4 二维数组中查找目标值","slug":"4.  二维数组中查找目标值","date":"2020-04-14T16:00:00.000Z","updated":"2020-04-21T12:32:03.184Z","comments":true,"path":"2020/04/15/4.er-wei-shu-zu-zhong-cha-zhao-mu-biao-zhi/","link":"","permalink":"https://eriecorner.github.io/2020/04/15/4.er-wei-shu-zu-zhong-cha-zhao-mu-biao-zhi/","excerpt":"","text":"题目描述给定一个二维数组int num[M][N]，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。 题解：该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。 代码实现：时间复杂度O(MN) ，空间复杂度O(1) 12345678910111213141516public boolean find(int target, int[][] nums) &#123; if (nums &#x3D;&#x3D; null || nums.length &#x3D;&#x3D; 0 || nums[0].length &#x3D;&#x3D; 0) &#123; return false; &#125; int r &#x3D; 0, c &#x3D; nums[0].length - 1; while (r &lt; nums.length - 1 &amp;&amp; c &gt;&#x3D; 0) &#123; if (target &#x3D;&#x3D; nums[r][c]) &#123; return true; &#125;else if (target&gt;nums[r][c])&#123; r++; &#125;else &#123; c--; &#125; &#125; return false; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"3. 数组中重复的数字","slug":"3. 数组中重复的数字","date":"2020-04-14T16:00:00.000Z","updated":"2020-04-21T12:31:42.739Z","comments":true,"path":"2020/04/15/3.shu-zu-zhong-chong-fu-de-shu-zi/","link":"","permalink":"https://eriecorner.github.io/2020/04/15/3.shu-zu-zhong-chong-fu-de-shu-zi/","excerpt":"","text":"题目描述在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的， 也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 题解：对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。本题要求找出重复的数字，因此在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。 代码实现：时间复杂度O（N），空间复杂度 O(1)。 123456789101112131415161718public boolean duplicate(int numbers[], int length, int[] duplication) &#123; if (numbers &#x3D;&#x3D; null || length &#x3D;&#x3D; 0) &#123; return false; &#125; for (int i &#x3D; 0; i &lt; length; i++) &#123; while (numbers[i] !&#x3D; i) &#123; if (numbers[i] &#x3D;&#x3D; numbers[numbers[i]]) &#123; duplication[0] &#x3D; numbers[i]; return true; &#125; else &#123; int temp &#x3D; numbers[i]; numbers[i] &#x3D; numbers[temp]; numbers[temp] &#x3D; temp; &#125; &#125; &#125; return false; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"1.1 斐波那契数列","slug":" 1.1 斐波那契数列","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-21T12:36:01.069Z","comments":true,"path":"2020/04/14/1.1-fei-bo-na-qi-shu-lie/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/1.1-fei-bo-na-qi-shu-lie/","excerpt":"","text":"题目描述：现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。n&lt;=39 题解：斐波那契数列如：1,1,2,3,5,8,13…；所以得知F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）。 代码实现 递归实现 —— 时间复杂度O(2^n）123456789public long fibonacci(int n) &#123; if (n &lt; 0) &#123; return 0; &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123; return 1; &#125; else &#123; return fibonacci(n - 1) + fibonacci(n - 2); &#125; &#125; 顺序求法——时间复杂度O(n）1234567891011121314151617public long fibonacci2(int n) &#123; long result &#x3D; 0; long preOne &#x3D; 1; long preTwo &#x3D; 1; if (n &lt; 0) &#123; return 0; &#125; if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123; return 1; &#125; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; result &#x3D; preOne + preTwo; preTwo &#x3D; preOne; preOne &#x3D; result; &#125; return result; &#125; 状态矩阵相乘法——时间复杂度O(log n）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 public long fibonacci3(int n) &#123; if (n &lt; 0) &#123; return 0; &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123; return 1; &#125; &#x2F;&#x2F;状态矩阵 int[][] base &#x3D; &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;; &#x2F;&#x2F;最后的结果需要求矩阵的n-2次 int[][] res &#x3D; matrixPower(base, n - 2); return res[0][0] + res[1][0]; &#125; &#x2F;&#x2F;求矩阵m的p次幂的值 private int[][] matrixPower(int[][] m, int p) &#123; int[][] res &#x3D; new int[m.length][m[0].length]; &#x2F;&#x2F;先把res设为单位矩阵，相当于整数中的1 for (int i &#x3D; 0; i &lt; res.length; i++) &#123; res[i][i] &#x3D; 1; &#125; &#x2F;&#x2F;临时矩阵 int[][] tmp &#x3D; m; for (; p !&#x3D; 0; p &gt;&gt;&#x3D; 1) &#123; if ((p &amp; 1) !&#x3D; 0) &#123;&#x2F;&#x2F;按位与操作，其实也就是位置为1的乘把这个矩阵乘一下 res &#x3D; muliMatrix(res, tmp); &#125; &#x2F;&#x2F; &#x2F;&#x2F;等于0 的时候我临时矩阵自己乘一下 tmp &#x3D; muliMatrix(tmp, tmp); &#125; return res; &#125; private int[][] muliMatrix(int[][] m1, int[][] m2) &#123; &#x2F;&#x2F;构造出一个m1行和m2列的矩阵（矩阵相乘规则） int[][] res &#x3D; new int[m1.length][m2[0].length]; &#x2F;&#x2F;给我们要得到的矩阵的每一个元素的值进行赋值操作 for (int i &#x3D; 0; i &lt; m1.length; i++) &#123; for (int j &#x3D; 0; j &lt; m2[0].length; j++) &#123; for (int k &#x3D; 0; k &lt; m2.length; k++) &#123;&#x2F;&#x2F;i，j位置元素的值就是i行元素和j行元素乘积的加和 res[i][j] +&#x3D; m1[i][k] * m2[k][j]; &#125; &#125; &#125; return res; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]},{"title":"1.2 矩形覆盖问题","slug":"1.2 矩形覆盖问题","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-21T12:36:14.433Z","comments":true,"path":"2020/04/14/1.2-ju-xing-fu-gai-wen-ti/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/1.2-ju-xing-fu-gai-wen-ti/","excerpt":"","text":"题目描述：我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ 题解：f(1) = 1; f(2) = 2; n&gt;2则f(n) = f(n-1)+f(n-2) 代码实现：123456789101112public int coverRect(int n) &#123; if (n &lt;&#x3D; 2) &#123; return n; &#125; int preOne &#x3D; 2, preTwo &#x3D; 1, result &#x3D; 0; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; result &#x3D; preOne + preTwo; preTwo &#x3D; preOne; preOne &#x3D; result; &#125; return result; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]},{"title":"1.3 跳台阶问题","slug":"1.3 跳台阶问题","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-21T12:36:25.298Z","comments":true,"path":"2020/04/14/1.3-tiao-tai-jie-wen-ti/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/1.3-tiao-tai-jie-wen-ti/","excerpt":"","text":"题目描述:一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 题解：f(1) = 1; f(2) = 2; n&gt;2则f(n) = f(n-1)+f(n-2) 代码实现：123456789101112private int jumpFloor(int n) &#123; if (n &lt;&#x3D; 2) &#123; return n; &#125; int preOne &#x3D; 2, preTwo &#x3D; 1, result &#x3D; 0; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; result &#x3D; preOne + preTwo; preTwo &#x3D; preOne; preOne &#x3D; result; &#125; return result; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]},{"title":"1.4 变态跳台阶问题","slug":"1.4 变态跳台阶问题","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-21T12:36:43.501Z","comments":true,"path":"2020/04/14/1.4-bian-tai-tiao-tai-jie-wen-ti/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/1.4-bian-tai-tiao-tai-jie-wen-ti/","excerpt":"","text":"题目描述一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级… 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 题解： 跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么 f(n-1) = f(n-2) + f(n-3) + ... + f(0)； 同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么 f(n) = f(n-1) + f(n-2) + ... + f(0) 综上可得 f(n) - f(n-1) = f(n-1) 即 f(n) = 2*f(n-1)代码实现：123private int jumpFloorIn(int n) &#123; return (int) Math.pow(2, n - 1); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"队列","slug":"队列","permalink":"https://eriecorner.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"https://eriecorner.github.io/tags/%E6%A0%88/"},{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"字符串","slug":"字符串","permalink":"https://eriecorner.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]}