{"meta":{"title":"紫依卓兰","subtitle":"","description":"","author":"紫依卓兰","url":"https://eriecorner.github.io","root":"/"},"pages":[{"title":"分类","date":"2020-04-20T08:37:17.000Z","updated":"2020-04-20T12:56:03.600Z","comments":false,"path":"categories/index.html","permalink":"https://eriecorner.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-20T08:37:17.000Z","updated":"2020-04-20T12:56:27.177Z","comments":false,"path":"tags/index.html","permalink":"https://eriecorner.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"OkHttp源码解析（Oktlin版）","slug":"三方框架源码解析/OkHttp  Kotlin版 源码解析","date":"2020-05-17T13:34:27.475Z","updated":"2020-05-17T13:38:41.963Z","comments":true,"path":"2020/05/17/san-fang-kuang-jia-yuan-ma-jie-xi/okhttp-kotlin-ban-yuan-ma-jie-xi/","link":"","permalink":"https://eriecorner.github.io/2020/05/17/san-fang-kuang-jia-yuan-ma-jie-xi/okhttp-kotlin-ban-yuan-ma-jie-xi/","excerpt":"","text":"前言OkHttp 是一款非常优秀的网络请求框架，随着Kotlin语言的不断完善，OkHttp 自 4.0 版本开始使用Kotlin编写，对于巩固Kotlin语法知识及实践，研读OkHttp 4.0及以上版本的源码是一个不错的选择。 首先列出一些前置知识点： Kotlin基础知识 Kotlin学习平台 网络请求响应码含义123451xx：信息，请求收到，继续处理2xx：成功，行为被成功地接受、理解和采纳3xx：重定向，为了完成请求，必须进一步执行的动作4xx：客户端错误，请求包含语法错误或者请求无法实现5xx：服务器错误，服务器不能实现一种明显无效的请求 Http缓存机制 OkHttp的基本使用 首先添加依赖库（去官网找最新的或想要的版本） Http 请求有多种类型，常用的分为 Get 和 Post，而 POST 又分为 Form 和 Multiple 等，下面我们以Get请求为例：1234567891011121314151617181920212223&#x2F;&#x2F; 1.创建OkHttpClient 对象，&#x2F;&#x2F; var client &#x3D; OkHttpClient();&#x2F;&#x2F;方式一 &#x2F;&#x2F;方式二： val client &#x3D; OkHttpClient.Builder().readTimeout(5, TimeUnit.SECONDS).build() &#x2F;&#x2F;2.创建请求对象并添加请求参数信息 val request &#x3D; Request.Builder().url(&quot;&quot;).build() &#x2F;&#x2F;3.构建进行请求操作的call对象 val call &#x3D; client.newCall(request) &#x2F;&#x2F;同步请求 Call （RealCall）—&gt;execute() 返回response &#x2F;&#x2F; val response &#x3D; client.newCall(request).execute() &#x2F;&#x2F;异步请求 Call （RealCall）—&gt;enqueue() call.enqueue( object : Callback &#123; override fun onFailure(call: Call, e: IOException) &#123; println(e.stackTrace.toString()) &#125; @Throws(IOException::class) override fun onResponse(call: Call, response: Response) &#123; println(response.body.toString()) &#125; &#125;) 首先使用OkHttpClint的构造OkHttpClient()或者Build模式构建一个OkHttpClint的对象实例； 使用构建者模式构建一个Request对象，通过OkHttpClient和Request对象，构建出Call对象； 执行call的enqueue()或者execute()。 注意：在实际开发中建议将OkHttpClint对象的创建封装成单列， 因为每个 OkHttpClient 对象都管理自己独有的线程池和连接池，复用连接池和线程池能够减少延迟、节省内存。 OkHttp 源码分析一. OkHttpClient12345678910111213141516171819202122232425262728293031323334constructor() : this(Builder())&#x2F;&#x2F;这里是默认的参数设置class Builder constructor() &#123; internal var dispatcher: Dispatcher &#x3D; Dispatcher()&#x2F;&#x2F;调度器，通过双端队列保存Calls（同步&amp;异步Call） internal var connectionPool: ConnectionPool &#x3D; ConnectionPool()&#x2F;&#x2F;链接池 internal val interceptors: MutableList&lt;Interceptor&gt; &#x3D; mutableListOf()&#x2F;&#x2F;拦截器 internal val networkInterceptors: MutableList&lt;Interceptor&gt; &#x3D; mutableListOf()&#x2F;&#x2F;网络拦截器 internal var eventListenerFactory: EventListener.Factory &#x3D; EventListener.NONE.asFactory()&#x2F;&#x2F;一个Call的状态监听器 internal var retryOnConnectionFailure &#x3D; true internal var authenticator: Authenticator &#x3D; Authenticator.NONE internal var followRedirects &#x3D; true internal var followSslRedirects &#x3D; true internal var cookieJar: CookieJar &#x3D; CookieJar.NO_COOKIES&#x2F;&#x2F;默认没有Cookie internal var cache: Cache? &#x3D; null internal var dns: Dns &#x3D; Dns.SYSTEM&#x2F;&#x2F;域名解析系统 domain name -&gt; ip address internal var proxy: Proxy? &#x3D; null internal var proxySelector: ProxySelector? &#x3D; null&#x2F;&#x2F;使用默认的代理选择器 internal var proxyAuthenticator: Authenticator &#x3D; Authenticator.NONE internal var socketFactory: SocketFactory &#x3D; SocketFactory.getDefault()&#x2F;&#x2F;默认的Socket 工厂生产Socket internal var sslSocketFactoryOrNull: SSLSocketFactory? &#x3D; null internal var x509TrustManagerOrNull: X509TrustManager? &#x3D; null internal var connectionSpecs: List&lt;ConnectionSpec&gt; &#x3D; DEFAULT_CONNECTION_SPECS&#x2F;&#x2F;OKHttp连接（Connection）配置 internal var protocols: List&lt;Protocol&gt; &#x3D; DEFAULT_PROTOCOLS internal var hostnameVerifier: HostnameVerifier &#x3D; OkHostnameVerifier internal var certificatePinner: CertificatePinner &#x3D; CertificatePinner.DEFAULT internal var certificateChainCleaner: CertificateChainCleaner? &#x3D; null internal var callTimeout &#x3D; 0 internal var connectTimeout &#x3D; 10_000 internal var readTimeout &#x3D; 10_000 internal var writeTimeout &#x3D; 10_000 internal var pingInterval &#x3D; 0&#x2F;&#x2F;和WebSocket有关,为了保持长连接，我们必须间隔一段时间发送一个ping指令进行保活 internal var minWebSocketMessageToCompress &#x3D; RealWebSocket.DEFAULT_MINIMUM_DEFLATE_SIZE internal var routeDatabase: RouteDatabase? &#x3D; null connectionSpecs： OKHttp连接（Connection）配置 1234567891011121314151617181920212223companion object &#123; internal val DEFAULT_PROTOCOLS &#x3D; immutableListOf(HTTP_2, HTTP_1_1) internal val DEFAULT_CONNECTION_SPECS &#x3D; immutableListOf( ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT) &#125; &#x2F;** * A modern TLS configuration that works on most client platforms and can connect to most servers. * This is OkHttp&#39;s default configuration. *&#x2F; &#x2F;&#x2F;针对TLS的， 是OkHttp 的默认配置 @JvmField val MODERN_TLS &#x3D; Builder(true) .cipherSuites(*APPROVED_CIPHER_SUITES) .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2) .supportsTlsExtensions(true) .build() &#x2F;** URL的未经加密，未经身份验证的连接 *&#x2F; @JvmField val CLEARTEXT &#x3D; Builder(false).build() 二. 同步请求流程分析以下代码为同步请求流程中的核心代码，按照调用次序呈现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129 &#x2F;&#x2F; 1. val response &#x3D; client.newCall(request).execute() &#x2F;&#x2F; 2. &#x2F;** Prepares the [request] to be executed at some point in the future. *&#x2F; override fun newCall(request: Request): Call &#x3D; RealCall(this, request, forWebSocket &#x3D; false) &#x2F;&#x2F;RealCall的execute() &#x2F;&#x2F; 3. 真正执行请求的是在call的实现类 RealCall的execute()中 override fun execute(): Response &#123; &#x2F;&#x2F;标记请求执行状态：一个请求只能执行一次 synchronized(this) &#123; check(!executed) &#123; &quot;Already Executed&quot; &#125; executed &#x3D; true &#125; timeout.enter() callStart() try &#123; &#x2F;&#x2F; 4. 通知dispatcher已经进入执行状态 client.dispatcher.executed(this) &#x2F;&#x2F; 5. 通过连接器的链式调用进行请求处理并返回最终响应结果 return getResponseWithInterceptorChain() &#125; finally &#123; &#x2F;&#x2F; 6. 通知dispatcher自己已执行完毕 client.dispatcher.finished(this) &#125; &#125; &#x2F;&#x2F;4 . dispatcher.executed() &#x2F;** Used by &#96;Call#execute&#96; to signal it is in-flight. *&#x2F; @Synchronized internal fun executed(call: RealCall) &#123; runningSyncCalls.add(call) &#125; &#x2F;&#x2F;Dispatcher中维护的ArrayDeque &#x2F;** 准备执行的异步请求队列. *&#x2F; private val readyAsyncCalls &#x3D; ArrayDeque&lt;AsyncCall&gt;() &#x2F;** 正在执行的异步请求队列 *&#x2F; private val runningAsyncCalls &#x3D; ArrayDeque&lt;AsyncCall&gt;() &#x2F;** 正在执行的同步请求队列 *&#x2F; private val runningSyncCalls &#x3D; ArrayDeque&lt;RealCall&gt;() &#x2F;&#x2F;5 .RealCall的getResponseWithInterceptorChain() @Throws(IOException::class) internal fun getResponseWithInterceptorChain(): Response &#123; &#x2F;&#x2F; Build a full stack of interceptors. val interceptors &#x3D; mutableListOf&lt;Interceptor&gt;() interceptors +&#x3D; client.interceptors&#x2F;&#x2F;用户在构建OkHttpClient是配置的连接器 interceptors +&#x3D; RetryAndFollowUpInterceptor(client)&#x2F;&#x2F;负责请求失败后的重试和重定向 interceptors +&#x3D; BridgeInterceptor(client.cookieJar)&#x2F;&#x2F;对请求和响应的参数进行必要的处理 interceptors +&#x3D; CacheInterceptor(client.cache)&#x2F;&#x2F;读取缓存数据返回、更新缓存 interceptors +&#x3D; ConnectInterceptor&#x2F;&#x2F;负责跟服务器的链接操作 if (!forWebSocket) &#123; &#x2F;&#x2F;创建OkHttpClient时设置的networkInterceptor interceptors +&#x3D; client.networkInterceptors &#125; &#x2F;&#x2F;向服务器发送请求数据，读取响应数据 interceptors +&#x3D; CallServerInterceptor(forWebSocket) &#x2F;&#x2F;将请求对象及OkHttpClient的一些配置封装在RealInterceptorChain中 val chain &#x3D; RealInterceptorChain( call &#x3D; this, interceptors &#x3D; interceptors, index &#x3D; 0, exchange &#x3D; null, request &#x3D; originalRequest, connectTimeoutMillis &#x3D; client.connectTimeoutMillis, readTimeoutMillis &#x3D; client.readTimeoutMillis, writeTimeoutMillis &#x3D; client.writeTimeoutMillis ) var calledNoMoreExchanges &#x3D; false try &#123; &#x2F;&#x2F;开启链式调用 val response &#x3D; chain.proceed(originalRequest) if (isCanceled()) &#123; response.closeQuietly() throw IOException(&quot;Canceled&quot;) &#125; return response &#125; catch (e: IOException) &#123; calledNoMoreExchanges &#x3D; true throw noMoreExchanges(e) as Throwable &#125; finally &#123; if (!calledNoMoreExchanges) &#123; noMoreExchanges(null) &#125; &#125; &#125;&#x2F;&#x2F;7. RealInterceptorChain的proceed()@Throws(IOException::class) override fun proceed(request: Request): Response &#123; check(index &lt; interceptors.size) calls++ if (exchange !&#x3D; null) &#123; check(exchange.finder.sameHostAndPort(request.url)) &#123; &quot;network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port&quot; &#125; check(calls &#x3D;&#x3D; 1) &#123; &quot;network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once&quot; &#125; &#125; &#x2F;&#x2F; Call the next interceptor in the chain. 实例化下一个拦截器 val next &#x3D; copy(index &#x3D; index + 1, request &#x3D; request) &#x2F;&#x2F;获取当前拦截器 val interceptor &#x3D; interceptors[index] &#x2F;&#x2F;调用当前拦截器的intercept(),并将下一个拦截器的RealIterceptorChain对象传递下去,最后返回响应结果 @Suppress(&quot;USELESS_ELVIS&quot;) val response &#x3D; interceptor.intercept(next) ?: throw NullPointerException( &quot;interceptor $interceptor returned null&quot;) if (exchange !&#x3D; null) &#123; check(index + 1 &gt;&#x3D; interceptors.size || next.calls &#x3D;&#x3D; 1) &#123; &quot;network interceptor $interceptor must call proceed() exactly once&quot; &#125; &#125; check(response.body !&#x3D; null) &#123; &quot;interceptor $interceptor returned a response with no body&quot; &#125; return response &#125; 三. 异步请求流程分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 &#x2F;&#x2F;1. 异步请求 Call （RealCall）—&gt;enqueue() client.newCall(request).enqueue( object : Callback &#123; override fun onFailure(call: Call, e: IOException) &#123; println(e.stackTrace.toString()) &#125; @Throws(IOException::class) override fun onResponse(call: Call, response: Response) &#123; println(response.body.toString()) &#125; &#125;) &#x2F;&#x2F;2. RealCall 的enqueue() override fun enqueue(responseCallback: Callback) &#123; synchronized(this) &#123; check(!executed) &#123; &quot;Already Executed&quot; &#125; executed &#x3D; true &#125; callStart() client.dispatcher.enqueue(AsyncCall(responseCallback)) &#125; &#x2F;&#x2F;3. dispatcher 的enqueue() internal fun enqueue(call: AsyncCall) &#123; synchronized(this) &#123; &#x2F;&#x2F;将请求添加到等待执行的异步请求队列中 readyAsyncCalls.add(call) &#x2F;&#x2F; Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to &#x2F;&#x2F; the same host. if (!call.call.forWebSocket) &#123; val existingCall &#x3D; findExistingCallWithHost(call.host) if (existingCall !&#x3D; null) call.reuseCallsPerHostFrom(existingCall) &#125; &#125; promoteAndExecute() &#125; &#x2F;** * Promotes eligible calls from [readyAsyncCalls] to [runningAsyncCalls] and runs them on the * executor service. Must not be called with synchronization because executing calls can call * into user code. * * @return true if the dispatcher is currently running calls. *&#x2F; &#x2F;&#x2F;4. 不断从readyAsyncCalls中取出要执行的请求放到runningAsyncCalls中，并将readyAsyncCalls中的移除 private fun promoteAndExecute(): Boolean &#123; this.assertThreadDoesntHoldLock() val executableCalls &#x3D; mutableListOf&lt;AsyncCall&gt;() val isRunning: Boolean synchronized(this) &#123; val i &#x3D; readyAsyncCalls.iterator() while (i.hasNext()) &#123; val asyncCall &#x3D; i.next() &#x2F;&#x2F; 如果其中的runningAsynCalls不满，且call占用的host小于最大数量，则将call加入到runningAsyncCalls中执行， if (runningAsyncCalls.size &gt;&#x3D; this.maxRequests) break &#x2F;&#x2F; Max capacity. if (asyncCall.callsPerHost.get() &gt;&#x3D; this.maxRequestsPerHost) continue &#x2F;&#x2F; Host max capacity. i.remove() asyncCall.callsPerHost.incrementAndGet() executableCalls.add(asyncCall) runningAsyncCalls.add(asyncCall) &#125; isRunning &#x3D; runningCallsCount() &gt; 0 &#125; for (i in 0 until executableCalls.size) &#123; val asyncCall &#x3D; executableCalls[i] &#x2F;&#x2F; 利用线程池执行call asyncCall.executeOn(executorService) &#125; return isRunning &#125; 异步请求的dispatcher.enqueue(AsyncCall)中传入是call 是一个AsyncCall，接下来看AsyncCall的实现.它是RealCall的内部类，实际是一个Runnable。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273internal inner class AsyncCall( private val responseCallback: Callback) : Runnable &#123; @Volatile var callsPerHost &#x3D; AtomicInteger(0) private set fun reuseCallsPerHostFrom(other: AsyncCall) &#123; this.callsPerHost &#x3D; other.callsPerHost &#125; val host: String get() &#x3D; originalRequest.url.host val request: Request get() &#x3D; originalRequest val call: RealCall get() &#x3D; this@RealCall &#x2F;** * Attempt to enqueue this async call on [executorService]. This will attempt to clean up * if the executor has been shut down by reporting the call as failed. *&#x2F; fun executeOn(executorService: ExecutorService) &#123; client.dispatcher.assertThreadDoesntHoldLock() var success &#x3D; false try &#123; &#x2F;&#x2F;在线程迟中执行 executorService.execute(this) success &#x3D; true &#125; catch (e: RejectedExecutionException) &#123; val ioException &#x3D; InterruptedIOException(&quot;executor rejected&quot;) ioException.initCause(e) noMoreExchanges(ioException) responseCallback.onFailure(this@RealCall, ioException) &#125; finally &#123; if (!success) &#123; client.dispatcher.finished(this) &#x2F;&#x2F; This call is no longer running! &#125; &#125; &#125; override fun run() &#123; threadName(&quot;OkHttp $&#123;redactedUrl()&#125;&quot;) &#123; var signalledCallback &#x3D; false timeout.enter() try &#123; &#x2F;&#x2F;最终进行拦截器的链式调用来处理请求并返回最终的响应结果 val response &#x3D; getResponseWithInterceptorChain() signalledCallback &#x3D; true responseCallback.onResponse(this@RealCall, response) &#125; catch (e: IOException) &#123; if (signalledCallback) &#123; &#x2F;&#x2F; Do not signal the callback twice! Platform.get().log(&quot;Callback failure for $&#123;toLoggableString()&#125;&quot;, Platform.INFO, e) &#125; else &#123; responseCallback.onFailure(this@RealCall, e) &#125; &#125; catch (t: Throwable) &#123; cancel() if (!signalledCallback) &#123; val canceledException &#x3D; IOException(&quot;canceled due to $t&quot;) canceledException.addSuppressed(t) responseCallback.onFailure(this@RealCall, canceledException) &#125; throw t &#125; finally &#123; client.dispatcher.finished(this) &#125; &#125; &#125;&#125; 通过源码看到Dispatcher维护了三个ArrayDeque，一个保存了正在执行的同步任务；一个保存异步正在执行的请求，另一个是异步等待执行的请求，异步右两个ArrayDeque是因为Dispatcher默认支持最大的并发请求是64个，单个Host最多执行5个并发请求，如果超过，则Call会先被放入到readyAsyncCall中，当出现空闲的线程时，再将readyAsyncCall中的线程移入到runningAsynCalls中，执行请求。 通过拦截器链处理，得到响应结果后执行finally中的代码dispatcher.finished(this)，现在来看下这个方法，走到这，一个请求流程就结束了。 12345678910111213141516171819202122232425262728&#x2F;** Used by [AsyncCall.run] to signal completion. *&#x2F;&#x2F;&#x2F;异步请求时调用 internal fun finished(call: AsyncCall) &#123; call.callsPerHost.decrementAndGet() finished(runningAsyncCalls, call) &#125; &#x2F;** Used by [Call.execute] to signal completion. *&#x2F; &#x2F;&#x2F;同步请求时调用 internal fun finished(call: RealCall) &#123; finished(runningSyncCalls, call) &#125; &#x2F;&#x2F;最终都调用这个方法 private fun &lt;T&gt; finished(calls: Deque&lt;T&gt;, call: T) &#123; val idleCallback: Runnable? synchronized(this) &#123; &#x2F;&#x2F;将当前call从其队列中移除 if (!calls.remove(call)) throw AssertionError(&quot;Call wasn&#39;t in-flight!&quot;) idleCallback &#x3D; this.idleCallback &#125; val isRunning &#x3D; promoteAndExecute() if (!isRunning &amp;&amp; idleCallback !&#x3D; null) &#123; idleCallback.run() &#125; &#125; 总结：网络请求是从OkHttpClient().newCall(request)开始的，通过创建的OkHttpClient对象和Request对象，构建出一个RealCall对象来执行网络请求，同步请求是在RealCall的execute()方法中，异步请求是在enqueue()中，在这两个方法中都用OkHttpClient对象的dispatcher执行对应的请求方法。对于同步请求，dispatcher的execute()就是将请求加入到runningSyncCalls这个双端队列中；对于异步请求，dispatcher进行请求的分发执行。在dispatcher将请求分发后调用getResponseWithInterceptorChain()方法，在这里，==依次==将client.interceptorsRetryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor、ConnectInterceptor、client.networkInterceptors和CallServerInterceptor添加到一个集合中，并创建出一个拦截器链RealInterceptorChain，通过RealInterceptorChain.proceed()使每一个拦截器执行完毕之后会调用下一个拦截器或者不调用并返回结果。显然，我们最终拿到的响应就是这个链条执行之后返回的结果。 整体的请求流程图如下： 四.OkHttp内置拦截器源码分析1. RetryAndFollowUpInterceptor这个拦截器负责重试和重定向，当一个请求由于各种原因失败了，如果是路由或者连接异常，则尝试恢复，否则，根据响应码（ResponseCode）,followup方法会对Request进行再处理以得到新的Request，然后沿着拦截器链继续新的Request；当尝试次数超过最大次数就抛出异常。代码逻辑相对比较简单，这里就不贴出来了。 2. BridgeInterceptor负责将用户请求转换为网络请求，也就是根据 Request 信息组建请求 Header 以及设置响应数据，包括设置 Cookie 以及gzip。源码就不贴出来了。 3. CacheInterceptor负责根据请求的信息和缓存的响应的信息来判断是否存在可用的缓存，读取缓存直接返回、否则就继续使用责任链模式来从服务器中获取响应。当获取到响应的时候，更新缓存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200@Throws(IOException::class)override fun intercept(chain: Interceptor.Chain): Response &#123; &#x2F;&#x2F;从缓存中获取 val cacheCandidate &#x3D; cache?.get(chain.request()) val now &#x3D; System.currentTimeMillis() &#x2F;&#x2F;缓存策略，决定使用缓存还是从网络获取 val strategy &#x3D; CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute() val networkRequest &#x3D; strategy.networkRequest val cacheResponse &#x3D; strategy.cacheResponse &#x2F;&#x2F;根据缓存策略，更新统计指标：请求次数、使用网络请求次数、使用缓存次数 cache?.trackResponse(strategy) &#x2F;&#x2F;若缓存不可用，关闭 if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it. cacheCandidate.body?.closeQuietly() &#125; &#x2F;&#x2F; If we&#39;re forbidden from using the network and the cache is insufficient, fail. &#x2F;&#x2F;如果既无网络请求可用，又没有缓存，则返回504错误 if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123; return Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(HTTP_GATEWAY_TIMEOUT) .message(&quot;Unsatisfiable Request (only-if-cached)&quot;) .body(EMPTY_RESPONSE) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build() &#125; &#x2F;&#x2F; If we don&#39;t need the network, we&#39;re done. &#x2F;&#x2F;缓存可用，则返回缓存中数据 if (networkRequest &#x3D;&#x3D; null) &#123; return cacheResponse!!.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build() &#125; var networkResponse: Response? &#x3D; null try &#123; &#x2F;&#x2F;进行网络请求，返回请求结果 networkResponse &#x3D; chain.proceed(networkRequest) &#125; finally &#123; &#x2F;&#x2F; If we&#39;re crashing on I&#x2F;O or otherwise, don&#39;t leak the cache body. if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123; cacheCandidate.body?.closeQuietly() &#125; &#125; &#x2F;&#x2F; If we have a cache response too, then we&#39;re doing a conditional get. &#x2F;&#x2F;HTTP_NOT_MODIFIED缓存有效，合并网络请求和缓存 if (cacheResponse !&#x3D; null) &#123; if (networkResponse?.code &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123; val response &#x3D; cacheResponse.newBuilder() .headers(combine(cacheResponse.headers, networkResponse.headers)) .sentRequestAtMillis(networkResponse.sentRequestAtMillis) .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build() networkResponse.body!!.close() &#x2F;&#x2F; Update the cache after combining headers but before stripping the &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()). cache!!.trackConditionalCacheHit() cache.update(cacheResponse, response)&#x2F;&#x2F;更新缓存 return response &#125; else &#123; cacheResponse.body?.closeQuietly() &#125; &#125; val response &#x3D; networkResponse!!.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build() &#x2F;&#x2F;允许缓存且请求结果不为空，则写入缓存 if (cache !&#x3D; null) &#123; if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123; &#x2F;&#x2F; Offer this request to the cache. val cacheRequest &#x3D; cache.put(response) return cacheWritingResponse(cacheRequest, response) &#125; if (HttpMethod.invalidatesCache(networkRequest.method)) &#123; try &#123; cache.remove(networkRequest) &#125; catch (_: IOException) &#123; &#x2F;&#x2F; The cache cannot be written. &#125; &#125; &#125; return response&#125; &#x2F;&#x2F; CacheStrategy中的核心方法 computeCandidate() &#x2F;** Returns a strategy to use assuming the request can use the network. *&#x2F; private fun computeCandidate(): CacheStrategy &#123; &#x2F;&#x2F; No cached response. 没有缓存，直接进行网络请求 if (cacheResponse &#x3D;&#x3D; null) &#123; return CacheStrategy(request, null) &#125; &#x2F;&#x2F; Drop the cached response if it&#39;s missing a required handshake. 是https请求，但是没有握手，进行网络请求 if (request.isHttps &amp;&amp; cacheResponse.handshake &#x3D;&#x3D; null) &#123; return CacheStrategy(request, null) &#125; &#x2F;&#x2F; If this response shouldn&#39;t have been stored, it should never be used as a response source. &#x2F;&#x2F; This check should be redundant as long as the persistence store is well-behaved and the &#x2F;&#x2F; rules are constant. &#x2F;&#x2F;不能进行缓存 if (!isCacheable(cacheResponse, request)) &#123; return CacheStrategy(request, null) &#125; val requestCaching &#x3D; request.cacheControl &#x2F;&#x2F;请求头nocache或者请求头包含If-Modified-Since或者If-None-Match(意味着本地缓存过期，需要服务器验证本地缓存是不是还能继续使用) if (requestCaching.noCache || hasConditions(request)) &#123; return CacheStrategy(request, null) &#125; val responseCaching &#x3D; cacheResponse.cacheControl val ageMillis &#x3D; cacheResponseAge() var freshMillis &#x3D; computeFreshnessLifetime() if (requestCaching.maxAgeSeconds !&#x3D; -1) &#123; freshMillis &#x3D; minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong())) &#125; var minFreshMillis: Long &#x3D; 0 if (requestCaching.minFreshSeconds !&#x3D; -1) &#123; minFreshMillis &#x3D; SECONDS.toMillis(requestCaching.minFreshSeconds.toLong()) &#125; var maxStaleMillis: Long &#x3D; 0 if (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds !&#x3D; -1) &#123; maxStaleMillis &#x3D; SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong()) &#125; &#x2F;&#x2F;缓存过期了，但仍然可用，给相应头中添加了Warning，使用缓存 if (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123; val builder &#x3D; cacheResponse.newBuilder() if (ageMillis + minFreshMillis &gt;&#x3D; freshMillis) &#123; builder.addHeader(&quot;Warning&quot;, &quot;110 HttpURLConnection \\&quot;Response is stale\\&quot;&quot;) &#125; val oneDayMillis &#x3D; 24 * 60 * 60 * 1000L if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123; builder.addHeader(&quot;Warning&quot;, &quot;113 HttpURLConnection \\&quot;Heuristic expiration\\&quot;&quot;) &#125; return CacheStrategy(null, builder.build())&#x2F;&#x2F;使用缓存 &#125; &#x2F;&#x2F; Find a condition to add to the request. If the condition is satisfied, the response body &#x2F;&#x2F; will not be transmitted. val conditionName: String val conditionValue: String? &#x2F;&#x2F;流程走到这，说明缓存已经过期了 &#x2F;&#x2F;添加请求头：If-Modified-Since或者If-None-Match &#x2F;&#x2F;etag与If-None-Match配合使用 &#x2F;&#x2F;lastModified与If-Modified-Since配合使用 &#x2F;&#x2F;前者和后者的值是相同的 &#x2F;&#x2F;区别在于前者是响应头，后者是请求头。 &#x2F;&#x2F;后者用于服务器进行资源比对，看看是资源是否改变了。 &#x2F;&#x2F; 如果没有，则本地的资源虽过期还是可以用的 when &#123; etag !&#x3D; null -&gt; &#123; conditionName &#x3D; &quot;If-None-Match&quot; conditionValue &#x3D; etag &#125; lastModified !&#x3D; null -&gt; &#123; conditionName &#x3D; &quot;If-Modified-Since&quot; conditionValue &#x3D; lastModifiedString &#125; servedDate !&#x3D; null -&gt; &#123; conditionName &#x3D; &quot;If-Modified-Since&quot; conditionValue &#x3D; servedDateString &#125; else -&gt; return CacheStrategy(request, null) &#x2F;&#x2F; No condition! Make a regular request. &#125; val conditionalRequestHeaders &#x3D; request.headers.newBuilder() conditionalRequestHeaders.addLenient(conditionName, conditionValue!!) val conditionalRequest &#x3D; request.newBuilder() .headers(conditionalRequestHeaders.build()) .build() return CacheStrategy(conditionalRequest, cacheResponse) &#125; 从上述CatchStragety.computeCandidate()方法可知，缓存策略如下： 1. 没有缓存，直接网络请求； 2. 如果是Https，没有进行握手，则进行网络请求； 3. 设置了不可缓存，则进行网络请求； 4. 请求头nocache或者请求头包含If-Modified-Since或者If-None-Match，则需要服务器验证本地缓存是不是还能继续使用，进行网络请求； 5. 可以缓存，并且缓存过期过期了但是还可以使用，这时给响应头添加Warning后，使用缓存； 6. 缓存已经过期，添加请求头：If-Modified-Since或者If-None-Match，进行网络请求；整个CatcheIncepter的执行依靠CatchStragety的缓存策略，代码中添加了注释，这里整理下流程如下： 1. 如果网络不可用并且无可用的有效缓存，则返回504错误； 2. 如果禁止了网络请求，则直接使用缓存； 3. 如果没有缓存且网络请求可用，则进行网络请求； 4. 如果此时有缓存，并且网络请求返回HTTP_NOT_MODIFIED（304），说明缓存还是有效的，则合并网络响应和缓存结果。同时更新缓存； 5. 如果没有缓存，则将请求回来的结果写入新的缓存中； 6. 返回响应数据。可以看到，缓存的获取、添加、更新等操作都是在Catche中初始化了一个DiskLruCache来完成的，具体方法如下: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&#x2F;&#x2F;获取缓存 internal fun get(request: Request): Response? &#123; val key &#x3D; key(request.url) val snapshot: DiskLruCache.Snapshot &#x3D; try &#123; cache[key] ?: return null &#125; catch (_: IOException) &#123; return null &#x2F;&#x2F; Give up because the cache cannot be read. &#125; val entry: Entry &#x3D; try &#123; Entry(snapshot.getSource(ENTRY_METADATA)) &#125; catch (_: IOException) &#123; snapshot.closeQuietly() return null &#125; val response &#x3D; entry.response(snapshot) if (!entry.matches(request, response)) &#123; response.body?.closeQuietly() return null &#125; return response &#125;&#x2F;&#x2F;添加缓存 internal fun put(response: Response): CacheRequest? &#123; val requestMethod &#x3D; response.request.method if (HttpMethod.invalidatesCache(response.request.method)) &#123; try &#123; remove(response.request) &#125; catch (_: IOException) &#123; &#x2F;&#x2F; The cache cannot be written. &#125; return null &#125; if (requestMethod !&#x3D; &quot;GET&quot;) &#123; &#x2F;&#x2F; Don&#39;t cache non-GET responses. We&#39;re technically allowed to cache HEAD requests and some &#x2F;&#x2F; POST requests, but the complexity of doing so is high and the benefit is low. return null &#125; if (response.hasVaryAll()) &#123; return null &#125; val entry &#x3D; Entry(response) var editor: DiskLruCache.Editor? &#x3D; null try &#123; editor &#x3D; cache.edit(key(response.request.url)) ?: return null entry.writeTo(editor) return RealCacheRequest(editor) &#125; catch (_: IOException) &#123; abortQuietly(editor) return null &#125; &#125;&#x2F;&#x2F;更新缓存 internal fun update(cached: Response, network: Response) &#123; val entry &#x3D; Entry(network) val snapshot &#x3D; (cached.body as CacheResponseBody).snapshot var editor: DiskLruCache.Editor? &#x3D; null try &#123; editor &#x3D; snapshot.edit() ?: return &#x2F;&#x2F; edit() returns null if snapshot is not current. entry.writeTo(editor) editor.commit() &#125; catch (_: IOException) &#123; abortQuietly(editor) &#125; &#125; 4. ConnectInterceptor这个拦截器打开与目标服务器的链接并进入下一个拦截器。通过RealCall的initExchange(chain)创建一个Exchange对象，并调用 Chain.proceed()方法。initExchange（）方法中会先通过 ExchangeFinder 尝试去 RealConnectionPool 中寻找已存在的连接，未找到则会重新创建一个RealConnection 并开始连接，然后将其存入RealConnectionPool，现在已经准备好了RealConnection 对象，然后通过请求协议创建不同的ExchangeCodec 并返回，返回的ExchangeCodec正是创建Exchange对象的一个参数。 下面说一下在建立连接过程中涉及到的几个重要类： Route:是连接到服务器的具体路由。其中包含了 IP 地址、端口、代理等参数。由于存在代理或者 DNS 可能返回多个 IP 地址的情况，所以同一个接口地址可能会对应多个 route。在创建 Connection 时将会使用 Route 而不是直接用 IP 地址。 RouteSelector：路由选择器，其中存储了所有可用的 route，在准备连接时时会通过 RouteSelector.next() 方法获取下一个 Route。值得注意的是，RouteSelector中包含了一个 routeDatabase 对象，其中存放着连接失败的Route，RouteSelector 会将其中存储的上次连接失败的route 放在最后，以此提高连接速度。 RealConnection:RealConnection 实现了 Connection接口，其中使用 Socket建立HTTP/HTTPS连接,并且获取 I/O 流，同一个 Connection 可能会承载多个 HTTP 的请求与响应。 RealConnectionPool:这是用来存储 RealConnection 的池子，内部使用一个双端队列来进行存储。在 OkHttp 中，一个连接（RealConnection）用完后不会立马被关闭并释放掉，而且是会存储到连接池（RealConnectionPool）中。除了缓存连接外，缓存池还负责定期清理过期的连接，在 RealConnection 中会维护一个用来描述该连接空闲时间的字段，每添加一个新的连接到连接池中时都会进行一次检测，遍历所有的连接，找出当前未被使用且空闲时间最长的那个连接，如果该连接空闲时长超出阈值，或者连接池已满，将会关闭该连接。 ExchangeCodec：ExchangeCodec 负责对Request 编码及解码 Response，也就是写入请求及读取响应，我们的请求及响应数据都通过它来读写。其实现类有两个：Http1ExchangeCodec 及 Http2ExchangeCodec，分别对应两种协议版本。 Exchange：功能类似 ExchangeCodec，但它是对应的是单个请求，其在 ExchangeCodec 基础上担负了一些连接管理及事件分发的作用。具体而言，Exchange 与 Request 一一对应，新建一个请求时就会创建一个 Exchange，该 Exchange 负责将这个请求发送出去并读取到响应数据，而发送与接收数据使用的是 ExchangeCodec。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132override fun intercept(chain: Interceptor.Chain): Response &#123; val realChain &#x3D; chain as RealInterceptorChain val exchange &#x3D; realChain.call.initExchange(chain) val connectedChain &#x3D; realChain.copy(exchange &#x3D; exchange) return connectedChain.proceed(realChain.request) &#125; &#x2F;&#x2F;RealCall 中的initExchange（）初始化Exchange对象 &#x2F;** Finds a new or pooled connection to carry a forthcoming request and response. *&#x2F; internal fun initExchange(chain: RealInterceptorChain): Exchange &#123; synchronized(connectionPool) &#123; check(!noMoreExchanges) &#123; &quot;released&quot; &#125; check(exchange &#x3D;&#x3D; null) &#125; val codec &#x3D; exchangeFinder!!.find(client, chain) val result &#x3D; Exchange(this, eventListener, exchangeFinder!!, codec) this.interceptorScopedExchange &#x3D; result synchronized(connectionPool) &#123; this.exchange &#x3D; result this.exchangeRequestDone &#x3D; false this.exchangeResponseDone &#x3D; false return result &#125; &#125; &#x2F;&#x2F;找到可用的resultConnection后根据协议创建ExchangeCodec并返回 fun find( client: OkHttpClient, chain: RealInterceptorChain ): ExchangeCodec &#123; try &#123; val resultConnection &#x3D; findHealthyConnection( connectTimeout &#x3D; chain.connectTimeoutMillis, readTimeout &#x3D; chain.readTimeoutMillis, writeTimeout &#x3D; chain.writeTimeoutMillis, pingIntervalMillis &#x3D; client.pingIntervalMillis, connectionRetryEnabled &#x3D; client.retryOnConnectionFailure, doExtensiveHealthChecks &#x3D; chain.request.method !&#x3D; &quot;GET&quot; ) return resultConnection.newCodec(client, chain) &#125; catch (e: RouteException) &#123; trackFailure(e.lastConnectException) throw e &#125; catch (e: IOException) &#123; trackFailure(e) throw RouteException(e) &#125; &#125; &#x2F;&#x2F;ExchangeFinder的findConnection方法中找已经存在的可用的链接 &#x2F;** * Returns a connection to host a new stream. This prefers the existing connection if it exists, * then the pool, finally building a new connection. *&#x2F; @Throws(IOException::class) private fun findConnection( connectTimeout: Int, readTimeout: Int, writeTimeout: Int, pingIntervalMillis: Int, connectionRetryEnabled: Boolean ): RealConnection &#123; var foundPooledConnection &#x3D; false var result: RealConnection? &#x3D; null var selectedRoute: Route? &#x3D; null var releasedConnection: RealConnection? val toClose: Socket? synchronized(connectionPool) &#123; ………… &#x2F;&#x2F; Attempt to get a connection from the pool. &#x2F;&#x2F;从connectPool中找可用的链接并返回 if (connectionPool.callAcquirePooledConnection(address, call, null, false)) &#123; foundPooledConnection &#x3D; true result &#x3D; call.connection &#125; else if (nextRouteToTry !&#x3D; null) &#123; selectedRoute &#x3D; nextRouteToTry nextRouteToTry &#x3D; null &#125; &#125; &#125; toClose?.closeQuietly() if (releasedConnection !&#x3D; null) &#123; eventListener.connectionReleased(call, releasedConnection!!) &#125; if (foundPooledConnection) &#123; eventListener.connectionAcquired(call, result!!) &#125; if (result !&#x3D; null) &#123; &#x2F;&#x2F; If we found an already-allocated or pooled connection, we&#39;re done. return result!! &#125; ………… &#x2F;&#x2F; Create a connection and assign it to this allocation immediately. This makes it possible &#x2F;&#x2F; for an asynchronous cancel() to interrupt the handshake we&#39;re about to do. &#x2F;&#x2F;创建一个新的RealConnection result &#x3D; RealConnection(connectionPool, selectedRoute!!) connectingConnection &#x3D; result var socket: Socket? &#x3D; null synchronized(connectionPool) &#123; connectingConnection &#x3D; null &#x2F;&#x2F; Last attempt at connection coalescing, which only occurs if we attempted multiple &#x2F;&#x2F; concurrent connections to the same host. if (connectionPool.callAcquirePooledConnection(address, call, routes, true)) &#123; &#x2F;&#x2F; We lost the race! Close the connection we created and return the pooled connection. result!!.noNewExchanges &#x3D; true socket &#x3D; result!!.socket() result &#x3D; call.connection &#x2F;&#x2F; It&#39;s possible for us to obtain a coalesced connection that is immediately unhealthy. In &#x2F;&#x2F; that case we will retry the route we just successfully connected with. nextRouteToTry &#x3D; selectedRoute &#125; else &#123; connectionPool.put(result!!)&#x2F;&#x2F;将新创建的RealConnection添加到connectPool中 call.acquireConnectionNoEvents(result!!) &#125; &#125; socket?.closeQuietly() eventListener.connectionAcquired(call, result!!) return result!! &#125; 5. CallServerInterceptor这是OkHttp 的连接器链中的最后一个拦截器，负责利用exchange把Request中的数据发送给服务端，并获取到数据写入到Response中。 到这里，OkHttp框架的核心逻辑已经梳理完了，回顾一下整体的架构实现，用到的设计模式有：Builder模式（OKHttpClient的构建）、工厂方法模式（Call接口提供了内部接口Factory、责任链模式（拦截器链）、享元模式（在Dispatcher的线程池）、策略模式（CacheInterceptor中数据选择等。 参考资源 OkHttp 4.6源码 okhttp源码解析 OkHttp 源码分析 感谢您阅读这篇文章，若有不正确的地方，欢迎指正!","categories":[{"name":"Android","slug":"Android","permalink":"https://eriecorner.github.io/categories/Android/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"https://eriecorner.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"}]},{"title":"14.数值的整数次方","slug":"算法/14.数值的整数次方","date":"2020-04-26T14:27:25.747Z","updated":"2020-04-26T14:29:06.455Z","comments":true,"path":"2020/04/26/suan-fa/14.shu-zhi-de-zheng-shu-ci-fang/","link":"","permalink":"https://eriecorner.github.io/2020/04/26/suan-fa/14.shu-zhi-de-zheng-shu-ci-fang/","excerpt":"","text":"题目描述 题目来源： Nowcoder 题设：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。（保证base和exponent不同时为0 ） 解题思路 负数的幂次方等于其绝对值的幂次方的倒数 代码实现JAVA实现1234567891011121314151617181920public double power(double base, int exponent) &#123; double result &#x3D; 1; if (base &#x3D;&#x3D; 0) &#123; return 0.0; &#125; if (exponent &#x3D;&#x3D; 0) &#123; return 1.0; &#125; int t &#x3D; Math.abs(exponent); while (t&gt;&#x3D;1)&#123; result *&#x3D; base; t--; &#125; if (exponent&gt;0)&#123; return result; &#125;else &#123; return 1.0&#x2F;result; &#125; &#125; kotlin实现12345678910111213141516171819fun power(base: Double, exponent: Int): Double &#123; var result &#x3D; 1.0 if (base &#x3D;&#x3D; 0.0) &#123; return 0.0 &#125; if (exponent &#x3D;&#x3D; 0) &#123; return 1.0 &#125; var t &#x3D; abs(exponent) while (t &gt;&#x3D; 1) &#123; result *&#x3D; base t-- &#125; return if (exponent &gt; 0) &#123; result &#125; else &#123; 1.0 &#x2F; result &#125; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"13.二进制中1的个数","slug":"算法/13. 二进制中1的个数","date":"2020-04-24T16:00:00.000Z","updated":"2020-04-25T13:04:19.803Z","comments":true,"path":"2020/04/25/suan-fa/13.er-jin-zhi-zhong-1-de-ge-shu/","link":"","permalink":"https://eriecorner.github.io/2020/04/25/suan-fa/13.er-jin-zhi-zhong-1-de-ge-shu/","excerpt":"","text":"题目描述 题目来源：NowCoder 题设：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 解题思路 先看看二进制的表示： 正数的二进制原码、反码、补码都是相同的 负数的二进制原码：负数的绝对值的二进制的最高位变为1（1是标志位，只用来表示正负，1表示负数，0表示是正数。所以八位二进制的取值范围是[-127,127]），其余位与正数原码相同。 负数的反码：等于原码的最高位不变，其余取反。 负数的补码：等于原码的最高位不变，其余取反，然后加一。 正零和负零的补码相同，[+0]补=[-0]补=0000 0000B 所以如果一个整数不为0，那么这个整数至少有一位是1。通过二进制的运算可以得到一个规律：把一个整数减1的结果是把其二进制最右边的一个1开始的所有位都取反了。那么n&amp;（n-1）的二进制结果就是n的二进制的最右边一个1那一位开始所有位都会变成0。那么我们就可以使用这个规律进行求解。 代码实现java实现12345678public int numOf1(int num) &#123; int count &#x3D; 0; while (num !&#x3D; 0) &#123; count++; num &#x3D; num &amp; (num - 1); &#125; return count; &#125; Kotlin实现123456789fun numOf1(num: Int): Int &#123; var num &#x3D; num var count &#x3D; 0 while (num !&#x3D; 0) &#123; count++ num &#x3D; num and num - 1 &#125; return count &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二进制","slug":"二进制","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"12. 剪绳子","slug":"算法/12. 剪绳子","date":"2020-04-23T16:00:00.000Z","updated":"2020-04-24T09:39:40.195Z","comments":true,"path":"2020/04/24/suan-fa/12.jian-sheng-zi/","link":"","permalink":"https://eriecorner.github.io/2020/04/24/suan-fa/12.jian-sheng-zi/","excerpt":"","text":"题目描述： 来源：NewCoder 题设：给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 解题思路 先举几个例子找找规律： 2 : 1*1 3 : 1*2 4 ： 2*2 5 ： 2*3 6 ： 3*3 7 ： 2*2*3 或者4*3 8 ： 2*3*3 9 ： 3*3*3 10：2*2*3*3 或者4*3*3 11：2*3*3*3 12：3*3*3*3 13：2*2*3*3*3 或者4*3*3*3 由此可见：2，3包含于各个问题中，如果再往下剪得话，乘积就会变小。所以选择2，3作为做小的子问题。 当n≥5时，3(n−3)≥2(n−2)，所以我们尽可能多的剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。 代码实现JAVA实现123456789101112131415161718192021222324252627&#x2F;** * 剪绳子问题 * * @param n 绳子长度 是整数且&gt;1 * 把绳子剪成整数长的m段，m是整数，且&gt;1 * @return *&#x2F; public int cutRope(int n) &#123; if (n &lt; 2) &#123; return 0; &#125; if (n &#x3D;&#x3D; 2) &#123;&#x2F;&#x2F;因为m&gt;1,所以只能是1*1 return 1; &#125; if (n &#x3D;&#x3D; 3) &#123; return 2; &#125; int times3 &#x3D; n &#x2F; 3; if (n % 3 &#x3D;&#x3D; 1) &#123; times3--; &#125; int times2 &#x3D; (n -3*times3) &#x2F; 2; return (int) (Math.pow(2, times2) * Math.pow(3, times3)); &#125; Kotlin 实现123456789101112131415161718192021222324&#x2F;** * 剪绳子问题 * * @param n 绳子长度 是整数且&gt;1 * 把绳子剪成整数长的m段，m是整数，且&gt;1 * @return *&#x2F; fun cutRope(n:Int):Int&#123; if(n&lt;2)&#123; return 0 &#125; if (n&#x3D;&#x3D;2)&#123;&#x2F;&#x2F;因为m&gt;1,所以只能1*1 return 1 &#125; if (n&#x3D;&#x3D;3)&#123; return 2 &#125; var times3 &#x3D; n&#x2F;3 if (times3%3&#x3D;&#x3D;1)&#123; times3-- &#125; val times2 &#x3D; (n- 3*times3)&#x2F;2 return (2.0.pow(times2.toDouble())* 3.0.pow(times3.toDouble())).toInt() &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[]},{"title":"11.机器人的运动范围","slug":"算法/11. 机器人的运动范围","date":"2020-04-22T16:00:00.000Z","updated":"2020-04-24T09:40:36.437Z","comments":true,"path":"2020/04/23/suan-fa/11.ji-qi-ren-de-yun-dong-fan-wei/","link":"","permalink":"https://eriecorner.github.io/2020/04/23/suan-fa/11.ji-qi-ren-de-yun-dong-fan-wei/","excerpt":"","text":"题目描述NowCoder 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 解题思路 从(0,0)开始走，每成功走一步标记当前位置为true,然后从当前位置往四个方向探索，返回1 + 44个方向的探索值之和。 探索时，判断当前节点是否可达的标准为： 当前节点在矩阵内； 当前节点未被访问过； 当前节点满足limit限制。 代码实现java 实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&#x2F;** * 机器人的运动范围 * * @param threshold * @param rows * @param cols * @return *&#x2F; public int movingCount(int threshold, int rows, int cols) &#123; if (rows &lt; 0 || cols &lt; 0 || threshold &lt; 0) &#123; return 0; &#125; &#x2F;&#x2F;标记矩阵中的格子是否走过 boolean[][] visit &#x3D; new boolean[rows][cols]; return findPathCount(threshold, rows, cols, 0, 0, visit); &#125; &#x2F;** * @param k * @param rows * @param cols * @param i * @param j * @param visit * @return 可走格子数 *&#x2F; public int findPathCount(int k, int rows, int cols, int i, int j, boolean[][] visit) &#123; &#x2F;&#x2F;若越界或者已经走过或者当前位置的坐标不满足条件，则返回0 if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; rows || j &gt;&#x3D; cols || visit[i][j] || !(sumIsOk(k, i, j))) &#123; return 0; &#125; &#x2F;&#x2F; 标记当前位置已走过 visit[i][j] &#x3D; true; &#x2F;&#x2F;当前位置的上下左右可走格子的和+1（当前格子） return 1 + findPathCount(k, rows, cols, i + 1, j, visit) + findPathCount(k, rows, cols, i - 1, j, visit) + findPathCount(k, rows, cols, i, j - 1, visit) + findPathCount(k, rows, cols, i, j + 1, visit); &#125; &#x2F;** * @param k * @param row * @param col * @return 行坐标和列坐标的数位之和是否大于k *&#x2F; public boolean sumIsOk(int k, int row, int col) &#123; int sum &#x3D; 0; while (row !&#x3D; 0) &#123; sum +&#x3D; row % 10; row &#x3D; row &#x2F; 10; &#125; while (col !&#x3D; 0) &#123; sum +&#x3D; col % 10; col &#x3D; col &#x2F; 10; &#125; return sum &lt;&#x3D; k; &#125; Kotlin实现123456789101112131415161718192021222324252627282930313233343536373839404142434445&#x2F;** *机器人的运动范围 *&#x2F; fun movingCount(k: Int, rows: Int, cols: Int): Int &#123; if (k &lt; 0 || rows &lt; 0 || cols &lt; 0) &#123; return 0; &#125; val visit &#x3D; Array(rows) &#123; BooleanArray(cols) &#125; return findPathCount(k, rows, cols, 0, 0, visit) &#125; &#x2F;** *回溯法寻找可行走的格子 *&#x2F; fun findPathCount(k: Int, rows: Int, cols: Int, i: Int, j: Int, visit: Array&lt;BooleanArray&gt;): Int &#123; &#x2F;&#x2F;若越界或者已经走过或者当前位置的坐标不满足条件，则返回0 if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; rows || j &gt;&#x3D; cols || visit[i][j] || !sumIsOk(k, i, j)) &#123; return 0 &#125; &#x2F;&#x2F; 标记当前位置已走过 visit[i][j] &#x3D; true &#x2F;&#x2F;当前位置的上下左右可走格子的和+1（当前格子） return (1 + findPathCount(k, rows, cols, i + 1, j, visit) + findPathCount(k, rows, cols, i - 1, j, visit) + findPathCount(k, rows, cols, i, j - 1, visit) + findPathCount(k, rows, cols, i, j + 1, visit)) &#125; &#x2F;** * 判断 限制条件是否ok *&#x2F; fun sumIsOk(k: Int, row: Int, col: Int): Boolean &#123; var row &#x3D; row var col &#x3D; col var sum &#x3D; 0 while (row !&#x3D; 0) &#123; sum +&#x3D; row % 10 row &#x3D; row &#x2F; 10 &#125; while (col !&#x3D; 0) &#123; sum +&#x3D; col % 10 col &#x3D; col &#x2F; 10 &#125; return sum &lt;&#x3D; k &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"10. 矩阵中的路径","slug":"算法/10. 矩阵中的路径","date":"2020-04-21T16:00:00.000Z","updated":"2020-04-24T09:40:10.629Z","comments":true,"path":"2020/04/22/suan-fa/10.ju-zhen-zhong-de-lu-jing/","link":"","permalink":"https://eriecorner.github.io/2020/04/22/suan-fa/10.ju-zhen-zhong-de-lu-jing/","excerpt":"","text":"题目描述： 题目来源：NowCoder 题设：判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 题解： 本题使用回溯法进行求解（回溯法：从一条路往前走,能进则进,不能进则退回来,换一条路再试。） 根据给定的数组初始化一个标志位数组，初始化都位false，表示未走过，true表示走过，不能再走； 因为给定的matrix是一个一维数组，先根据二维数组的行数遍历的下标确定一维数组的位置：index = i*cols+j; 确定递归终止条件：越界、当前找到的矩阵值不等于字符串数组对应位置的值、已经走过的，这三类情况，都直接false，说明这条路不通 若k，就是待判定的字符串数组str的索引已经判断到了最后一位，此时说明是匹配成功的。 然后递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。 走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。 代码实现：JAVA实现 核心方法123456789101112131415161718192021222324252627282930313233343536373839404142434445private boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if (matrix &#x3D;&#x3D; null || rows &lt; 0 || cols &lt; 0) &#123; return false; &#125; if (str &#x3D;&#x3D; null) &#123; return true; &#125; &#x2F;&#x2F;标志位，初始化为false boolean[] visit &#x3D; new boolean[matrix.length]; for (int i &#x3D; 0; i &lt; rows; i++) &#123; for (int j &#x3D; 0; j &lt; cols; j++) &#123; &#x2F;&#x2F;循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法 if (find(matrix, i, j, rows, cols, visit, str, 0)) &#123; return true; &#125; &#125; &#125; return false; &#125; &#x2F;&#x2F;find(初始矩阵，索引行坐标，索引列坐标，矩阵行数，矩阵列数，矩阵当前索引位置是否走过的标记，待判断的字符串，字符串初始位置为0 ，即先判断字符串的第一位) private boolean find(char[] matrix, int row, int col, int rows, int cols, boolean[] visit, char[] str, int k) &#123; &#x2F;&#x2F;先根据i和j计算匹配的第一个元素转为一维数组的位置 int index &#x3D; row * cols + col; &#x2F;&#x2F;递归终止的条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的 if (row &lt; 0 || col &lt; 0 || row&gt;&#x3D;rows||col&gt;&#x3D;cols||matrix[index] !&#x3D; str[k] || visit[index] &#x3D;&#x3D; true) &#123; return false; &#125; &#x2F;&#x2F;若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可 if (k &#x3D;&#x3D; str.length - 1) return true; &#x2F;&#x2F;要走的第一个位置置为true，表示已经走过了 visit[index] &#x3D; true; &#x2F;&#x2F;回溯，递归寻找，每次找到了就给k加一，找不到，还原 if (find(matrix, row + 1, col, rows, cols, visit, str, k + 1) || find(matrix, row - 1, col, rows, cols, visit, str, k + 1) || find(matrix, row, col+1, rows, cols, visit, str, k + 1) || find(matrix, row, col-1, rows, cols, visit, str, k + 1)) &#123; return true; &#125; visit[index] &#x3D; false; &#x2F;&#x2F;走到这，说明这一条路不通，还原，再试其他的路径 return false; &#125; 测试1234567891011@Testpublic void hasPath() &#123; char[] matrix &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;f&#39;, &#39;g&#39;, &#39;y&#39;, &#39;r&#39;, &#39;y&#39;, &#39;u&#39;, &#39;i&#39;, &#39;o&#39;, &#39;q&#39;&#125;; int rows &#x3D; 3; int cols &#x3D; 4; char[] str &#x3D; &#123;&#39;y&#39;, &#39;r&#39;, &#39;i&#39;&#125;; System.out.println(hasPath(matrix, rows, cols, str));&#125;&#x2F;&#x2F;返回 false&#x2F;&#x2F;str &#x3D; &#123;&#39;b&#39;,&#39;y&#39;,&#39;r&#39;&#125;时返回true Kotlin实现 核心方法1234567891011121314151617181920212223242526272829303132333435fun hasPath(matrix: CharArray, rows: Int, cols: Int, str: CharArray): Boolean &#123; if (matrix &#x3D;&#x3D; null || rows &lt; 0 || cols &lt; 0) &#123; return false &#125; if (str &#x3D;&#x3D; null) &#123; return true &#125; var visit &#x3D; BooleanArray(matrix.size); for (i in 0 until rows) &#123; for (j in 0 until cols) &#123; if (find(matrix, i, j, rows, cols, str, 0, visit)) &#123; return true &#125; &#125; &#125; return false &#125; fun find(matrix: CharArray, i: Int, j: Int, rows: Int, cols: Int, str: CharArray, k: Int, visit: BooleanArray): Boolean &#123; var index &#x3D; i * cols + j; if (i &lt; 0 || j &lt; 0 || j &gt;&#x3D; cols || i &gt;&#x3D; rows || matrix[index] !&#x3D; str[k] || visit[index]) &#123; return false &#125; if (k &#x3D;&#x3D; str.size - 1) &#123; return true &#125; if (find(matrix, i + 1, j, rows, cols, str, k + 1, visit) || find(matrix, i - 1, j, rows, cols, str, k + 1, visit) || find(matrix, i, j + 1, rows, cols, str, k + 1, visit) || find(matrix, i, j - 1, rows, cols, str, k + 1, visit)) &#123; return true &#125; visit[index] &#x3D; false return false &#125; 测试123456789@Test fun testhasPath() &#123; val matrix &#x3D; charArrayOf1(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;f&#39;, &#39;g&#39;, &#39;y&#39;, &#39;r&#39;, &#39;y&#39;, &#39;u&#39;, &#39;i&#39;, &#39;o&#39;, &#39;q&#39;) val str &#x3D; charArrayOf1(&#39;y&#39;, &#39;r&#39;, &#39;i&#39;) val rows &#x3D; 4 val cols &#x3D; 3 print(hasPath(matrix,rows,cols,str)) &#125; &#x2F;&#x2F;输出true","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"9. 两个栈实现一个队列","slug":"算法/9. 两个栈实现一个队列","date":"2020-04-17T16:00:00.000Z","updated":"2020-04-21T12:33:05.298Z","comments":true,"path":"2020/04/18/suan-fa/9.liang-ge-zhan-shi-xian-yi-ge-dui-lie/","link":"","permalink":"https://eriecorner.github.io/2020/04/18/suan-fa/9.liang-ge-zhan-shi-xian-yi-ge-dui-lie/","excerpt":"","text":"题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 题解栈是先进后出，队列是先进先出。即一序列元素入栈后，出站顺序被翻转，则一个栈（暂且称为inStack）中的元素出站时先放入另一个栈(暂且称为outStack)），然后outStack栈的出站顺序和inStack的入栈顺序一致，就是队列的入队出队顺序。 代码实现java实现 定义队列及其入队出队的方法 123456789101112131415161718192021222324252627282930313233343536373839class Queue &#123; private Stack&lt;Integer&gt; inStack &#x3D; new Stack&lt;&gt;(); private Stack&lt;Integer&gt; outStack &#x3D; new Stack&lt;&gt;(); &#x2F;** * @param node * 进栈操作 *&#x2F; public void push(int node) &#123; inStack.push(node); &#125; &#x2F;** * @return 队列中是否有元素 *&#x2F; public boolean hasElement() &#123; if (outStack.isEmpty() &amp;&amp; inStack.isEmpty()) &#123; return false; &#125; return true; &#125; &#x2F;** * @return 出栈操作 * @throws Exception *&#x2F; public int pop() throws Exception &#123; if (outStack.isEmpty()) &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()); &#125; &#125; if (outStack.isEmpty()) &#123; throw new Exception(&quot;queue is empty&quot;); &#125; return outStack.pop(); &#125; &#125; 测试 123456789101112 @Test public void getResult() throws Exception &#123; Queue queue &#x3D; new Queue(); for (int i &#x3D; 0; i &lt; 5; i++) &#123; queue.push(i); &#125; while (queue.hasElement()) &#123; System.out.println(queue.pop()); &#125; &#125;&#x2F;&#x2F;输出01234 Kotlin 实现 构造队列并实现入队出队操作 12345678910111213141516171819202122232425262728class Queue &#123; val inStack &#x3D; Stack&lt;Int&gt;(); val outStack &#x3D; Stack&lt;Int&gt;(); &#x2F;&#x2F;入栈操作 fun push(node: Int) &#123; inStack.push(node) &#125; &#x2F;&#x2F;出站操作 fun pop(): Int &#123; if (outStack.isEmpty()) &#123; while (!inStack.isEmpty()) &#123; outStack.push(inStack.pop()) &#125; &#125; if (outStack.isEmpty()) &#123; throw Exception(&quot;queue is empty!&quot;) &#125; return outStack.pop() &#125; fun hasElement(): Boolean &#123; if (inStack.isEmpty() &amp;&amp; outStack.isEmpty()) &#123; return false &#125; return true &#125; &#125; 测试 123456789101112@Test fun getResult() &#123; val queue &#x3D; Queue() for (i:Int in 0..4)&#123; queue.push(i) &#125; while (queue.hasElement())&#123; print(queue.pop()) &#125; &#125; &#x2F;&#x2F;输出 01234","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"队列","slug":"队列","permalink":"https://eriecorner.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"https://eriecorner.github.io/tags/%E6%A0%88/"}]},{"title":"7. 重建二叉树","slug":"算法/7. 重建二叉树","date":"2020-04-16T16:00:00.000Z","updated":"2020-04-21T12:46:25.927Z","comments":true,"path":"2020/04/17/suan-fa/7.chong-jian-er-cha-shu/","link":"","permalink":"https://eriecorner.github.io/2020/04/17/suan-fa/7.chong-jian-er-cha-shu/","excerpt":"","text":"题目描述根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 题解 前序遍历：中左右 中序遍历：左中右 后序遍历：左右中 前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。 代码实现JAVA实现 首先定义树结构 123456789101112131415private class TreeNode &#123; int node;&#x2F;&#x2F;节点 TreeNode left;&#x2F;&#x2F;左子树 TreeNode right;&#x2F;&#x2F;右子树 public TreeNode(int node) &#123; this.node &#x3D; node; &#125; public String toString() &#123; return &quot;TreeNode [data&#x3D;&quot; + node + &quot;, left&#x3D;&quot; + left + &quot;, right&#x3D;&quot; + right + &quot;]&quot;; &#125; &#125; 核心算法 12345678910111213141516171819202122232425262728293031public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; if (pre.length &#x3D;&#x3D; 0 || in.length &#x3D;&#x3D; 0) &#123; return null; &#125; TreeNode root &#x3D; rebuildBinaryTreeCoreAfter(pre,0,pre.length-1,in,0,in.length-1); return root; &#125; public TreeNode rebuildBinaryTreeCore(int preorder[], int startPreorder, int endPreorder, int inorder[], int startInorder, int endInorder) &#123; if (startPreorder &gt; endPreorder || startInorder &gt; endInorder) &#123; &#x2F;&#x2F;停止递归的条件 return null; &#125; TreeNode root &#x3D; new TreeNode(preorder[startPreorder]); for (int i &#x3D; startInorder; i &lt;&#x3D; endInorder; i++) &#123; if (preorder[startPreorder] &#x3D;&#x3D; inorder[i]) &#123; &#x2F;&#x2F; 其中（i - startInorder）为中序排序中左子树结点的个数 &#x2F;&#x2F;左子树 root.left &#x3D; rebuildBinaryTreeCore(preorder, startPreorder + 1, startPreorder + (i - startInorder), inorder, startInorder, i-1 ); &#x2F;&#x2F;右子树 root.right &#x3D; rebuildBinaryTreeCore(preorder, (i - startInorder) + startPreorder + 1, endPreorder, inorder, i + 1, endInorder); &#125; &#125; return root; &#125; 验证 123456789101112131415public void getResult() &#123; int[] pre &#x3D; &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;; int[] mid &#x3D; &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;; System.out.println(reConstructBinaryTree(pre,mid)); &#125; &#x2F;&#x2F;树结构： 1 2 3 4 5 6 7 8 Kotlin实现 首先定义树结构 12data class TreeNode(val data: Int, var left: TreeNode? &#x3D; null, var right: TreeNode? &#x3D; null) &#123; &#125; 核心算法 12345678910111213141516171819202122232425262728private fun reConstructBinaryTree(pre: IntArray, mid: IntArray): TreeNode? &#123; if (pre.isEmpty() || mid.isEmpty()) &#123; return null &#125; return reConstructBinaryTreeCore(pre, 0, pre.size - 1, mid, 0, mid.size - 1) &#125; private fun reConstructBinaryTreeCore(pre: IntArray, preStart: Int, preEnd: Int, mid: IntArray, midStart: Int, midEnd: Int): TreeNode? &#123; if (preStart &gt; preEnd || midStart &gt; midEnd) &#123; return null &#125; val root &#x3D; TreeNode(pre[preStart]); for (i in mid.indices) &#123; if (mid[i] &#x3D;&#x3D; pre[preStart]) &#123; &#x2F;&#x2F;（）i - midStart） 是为中序排序中左子树结点的个数 &#x2F;&#x2F;左子树 root.left &#x3D; reConstructBinaryTreeCore(pre, preStart + 1, preStart + (i - midStart), mid, midStart, i - 1) &#x2F;&#x2F;右子树 root.right &#x3D; reConstructBinaryTreeCore(pre, preStart + (i - midStart) + 1, preEnd, mid, i + 1, midEnd) &#125; &#125; return root; &#125; 验证 123456789101112131415fun getResult() &#123; val pre &#x3D; intArrayOf(1, 2, 4, 7, 3, 5, 6, 8) val mid &#x3D; intArrayOf(4, 7, 2, 1, 5, 3, 8, 6) print(reConstructBinaryTree(pre, mid )); &#125; &#x2F;&#x2F;树结构 1 2 3 4 5 6 7 8 举一反三根据二叉树的后序遍历和中序遍历的结果，重建出该二叉树。假设输入的后序遍历和中序遍历的结果中都不含重复的数字。 题解思路同上，后序序遍历的最后一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。 代码实现JAVA实现 核心算法123456789101112131415private TreeNode rebuildBinaryTreeCoreAfter(int[] after,int afterStart,int afterEnd,int[]mid ,int midStart,int midEnd )&#123; if (afterStart&gt;afterEnd||midStart&gt;midEnd)&#123; return null; &#125; TreeNode root &#x3D; new TreeNode(after[afterEnd]); for (int i &#x3D; 0; i &lt;&#x3D; midEnd; i++) &#123; if (after[afterEnd]&#x3D;&#x3D;mid[i])&#123; root.left &#x3D; rebuildBinaryTreeCoreAfter(after,afterStart,afterStart-1+(i-midStart), mid,midStart,i-1); root.right &#x3D; rebuildBinaryTreeCoreAfter(after,afterStart+(i-midStart),afterEnd-1, mid,i+1,midEnd); &#125; &#125; return root; &#125; 验证1234567891011121314151617public void getResult() &#123; &#x2F;&#x2F;int[] pre &#x3D; &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;; &#x2F;&#x2F;int[] mid &#x3D; &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;; &#x2F;&#x2F;System.out.println(reConstructBinaryTree(pre,mid)); int[] after &#x3D; &#123;2,4,3,1,6,7,5&#125;; int[] mid &#x3D; &#123;1,2,3,4,5,6,7&#125;; System.out.println(reConstructBinaryTree(after,mid)); &#125; &#x2F;&#x2F;树结构 5 1 7 3 6 2 4 Kotlin实现 核心算法12345678910111213141516171819202122232425private fun reConstructBinaryTreeAfter(pre: Array&lt;Int&gt;, mid: Array&lt;Int&gt;): TreeNode? &#123; if (pre.isEmpty() || mid.isEmpty()) &#123; return null &#125; val root &#x3D; reConstructBinaryTreeCoreAfter(pre, 0, pre.size - 1, mid, 0, mid.size - 1) return root&#125; private fun reConstructBinaryTreeCoreAfter(after: Array&lt;Int&gt;, afterStart: Int, afterEnd: Int, mid: Array&lt;Int&gt;, midStart: Int, midEnd: Int): TreeNode? &#123; if (afterStart &gt; afterEnd || midStart &gt; midEnd) return null val root &#x3D; TreeNode(after[afterEnd]) for (i in mid.indices) &#123; if (mid[i] &#x3D;&#x3D; after[afterEnd]) &#123; root.left &#x3D; reConstructBinaryTreeCoreAfter(after, afterStart, afterStart - 1 + (i - midStart), mid, midStart, i - 1) root.right &#x3D; reConstructBinaryTreeCoreAfter(after, afterStart + (i - midStart), afterEnd - 1, mid, i + 1, midEnd) &#125; &#125; return root;&#125; 验证1234567891011121314151617fun getResult() &#123;&#x2F;&#x2F; val pre &#x3D; intArrayOf(1, 2, 4, 7, 3, 5, 6, 8)&#x2F;&#x2F; val mid &#x3D; intArrayOf(4, 7, 2, 1, 5, 3, 8, 6)&#x2F;&#x2F; print(reConstructBinaryTree(pre, mid )); val after &#x3D; arrayOf(2,4,3,1,6,7,5) val ins &#x3D; arrayOf(1,2,3,4,5,6,7) print(reConstructBinaryTreeAfter(after, ins)); &#125; &#x2F;&#x2F;树结构 5 1 7 3 6 2 4","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"8. 查找二叉树的下一个节点","slug":"算法/8. 查找二叉树的下一个节点","date":"2020-04-16T16:00:00.000Z","updated":"2020-04-21T12:44:05.123Z","comments":true,"path":"2020/04/17/suan-fa/8.cha-zhao-er-cha-shu-de-xia-yi-ge-jie-dian/","link":"","permalink":"https://eriecorner.github.io/2020/04/17/suan-fa/8.cha-zhao-er-cha-shu-de-xia-yi-ge-jie-dian/","excerpt":"","text":"题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回 。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 题解二叉树的中序遍历为：先遍历树的左子树，再遍历根节点，最后再遍历右子树。所以最左节点是中序遍历的第一个节点。 如果一个节点的右子树不为空，则该节点的下一个节点是右子树的最左节点； 如果该节点的右子树为空，则不断向上找该节点的父节点的左子树，直到找到第一个左子树包含该节点，则该节点的下一个节点为此父节点。 若这两种都没有找到，则该节点没有下一个节点。代码实现java实现 构造二叉树12345678910public class TreeLinkNode &#123; int val; TreeLinkNode left &#x3D; null; TreeLinkNode right &#x3D; null; TreeLinkNode next &#x3D; null; TreeLinkNode(int val) &#123; this.val &#x3D; val; &#125;&#125; 核心算法12345678910111213141516171819public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode.right!&#x3D;null)&#123; TreeLinkNode node &#x3D; pNode.right; while (node.left!&#x3D;null)&#123; node &#x3D; node.left; &#125; return node; &#125;else &#123; while (pNode.next!&#x3D;null)&#123; TreeLinkNode parent &#x3D; pNode.next; if (parent.left&#x3D;&#x3D;pNode)&#123; return parent; &#125; pNode &#x3D; pNode.next; &#125; &#125; return null; &#125; Kotlin实现 构造二叉树1data class TreeLinkNode(val data: Int, var left: TreeLinkNode?, var right: TreeLinkNode?, var next: TreeLinkNode?) &#123;&#125; 核心算法12345678910111213141516171819private fun getNext( pNode: TreeLinkNode): TreeLinkNode? &#123; if (pNode.right !&#x3D; null) &#123; var node: TreeLinkNode &#x3D; pNode.right!! while (node.left !&#x3D; null) &#123; node &#x3D; node.left!! &#125; return node &#125; else &#123; var nextNode &#x3D; pNode while (nextNode.next !&#x3D; null) &#123; var parent &#x3D; pNode.next!! if (parent.left &#x3D;&#x3D; pNode) &#123; return parent &#125; nextNode &#x3D; pNode.next!! &#125; &#125; return null &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"}]},{"title":"5. 替换空格","slug":"算法/5. 替换空格","date":"2020-04-15T16:00:00.000Z","updated":"2020-04-21T12:32:15.089Z","comments":true,"path":"2020/04/16/suan-fa/5.ti-huan-kong-ge/","link":"","permalink":"https://eriecorner.github.io/2020/04/16/suan-fa/5.ti-huan-kong-ge/","excerpt":"","text":"题目描述：将一个字符串中的空格替换成 “%20”。 题解：从后往前复制，数组长度会增加，或使用StringBuffer，StringBuild类。 代码实现：时间复杂度O（N），空间复杂度O（N） 123456789101112131415public String replaceSpace(String value)&#123; if (value&#x3D;&#x3D;null)&#123; return null; &#125; StringBuilder builder &#x3D; new StringBuilder(); for (int i &#x3D; 0; i &lt;value.length() ; i++) &#123; if (String.valueOf(value.charAt(i)).equals(&quot; &quot;))&#123; builder.append(&quot;%20&quot;); &#125;else &#123; builder.append(value.charAt(i)); &#125; &#125; return builder.toString(); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://eriecorner.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"6. 从尾到头打印链表","slug":"算法/6. 从尾到头打印链表","date":"2020-04-15T16:00:00.000Z","updated":"2020-04-21T12:44:26.941Z","comments":true,"path":"2020/04/16/suan-fa/6.cong-wei-dao-tou-da-yin-lian-biao/","link":"","permalink":"https://eriecorner.github.io/2020/04/16/suan-fa/6.cong-wei-dao-tou-da-yin-lian-biao/","excerpt":"","text":"题目描述：从尾到头反过来打印出每个结点的值。 题解：1. 使用栈栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。 代码实现：12345678910111213141516171819202122232425262728293031323334353637&#x2F;&#x2F;先定义一个节点 public static class ListNode &#123; private int value; private ListNode next; public ListNode(int node) &#123; this.value &#x3D; node; &#125; &#125; &#x2F;&#x2F;构建链表 private ListNode BuildLinkList() &#123; ListNode head &#x3D; new ListNode(0); ListNode cur &#x3D; head; for (int i &#x3D; 1; i &lt; 10; i++) &#123; ListNode tmp &#x3D; new ListNode(i); cur.next&#x3D; tmp; cur &#x3D; tmp; &#125; return head; &#125; public ArrayList&lt;Integer&gt; printListFromTrilToHead(ListNode listNode)&#123; Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;(); while (listNode!&#x3D;null)&#123; stack.add(listNode.value); listNode &#x3D; listNode.next; &#125; ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;(); while (!stack.isEmpty())&#123; ret.add(stack.pop()); &#125; return ret; &#125; 2.递归时间复杂度：O(n)空间复杂度：O(n) 123456789public ArrayList&lt;Integer&gt; printListFromTrilToHead1(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;(); if (listNode !&#x3D; null) &#123; ret.addAll(printListFromTrilToHead1(listNode.next)); ret.add(listNode.value); &#125; return ret; &#125; 3.遍历node的每一个节点插入到集合的第一个位置时间复杂度：O(n)空间复杂度：O(n) 12345678910public ArrayList&lt;Integer&gt; printListFromTrilToHead2(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;(); ListNode tmp &#x3D; listNode; while (tmp !&#x3D; null) &#123; ret.add(0,tmp.value); tmp &#x3D; tmp.next; &#125; return ret; &#125; 4. 头插法123456789101112131415161718public ArrayList&lt;Integer&gt; printListFromTrilToHead3(ListNode listNode) &#123; ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;(); ListNode head &#x3D; new ListNode(-1); while (listNode !&#x3D; null) &#123; ListNode tmp &#x3D; listNode.next; listNode.next &#x3D; head.next; head.next &#x3D; listNode; listNode &#x3D; tmp; &#125; head &#x3D; head.next; while (head !&#x3D; null) &#123; ret.add(head.value); head &#x3D; head.next; &#125; return ret; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"2. 旋转数组中的最小元素","slug":"算法/2. 旋转数组中的最小元素","date":"2020-04-14T16:00:00.000Z","updated":"2020-04-21T12:43:53.289Z","comments":true,"path":"2020/04/15/suan-fa/2.xuan-zhuan-shu-zu-zhong-de-zui-xiao-yuan-su/","link":"","permalink":"https://eriecorner.github.io/2020/04/15/suan-fa/2.xuan-zhuan-shu-zu-zhong-de-zui-xiao-yuan-su/","excerpt":"","text":"题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 题解：利用折半查找的思想，时间复杂度度为O（logN），为了方便，这里将 log2N 写为 logN 将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。 （l 代表 low，m 代表 mid，h 代表 high）当 nums[m] &lt;= nums[h] 时，表示 [m, h] 区间内的数组是非递减数组，[l, m] 区间内的数组是旋转数组，此时令 h = m； 否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。 代码实现：123456789101112131415private int findMixNumInRotateArray(int[] nums) &#123; if (nums.length &#x3D;&#x3D; 0) &#123; return 0; &#125; int l &#x3D; 0, h &#x3D; nums.length - 1; while (l &lt; h) &#123; int m &#x3D; l + (h - 1) &#x2F; 2; if (nums[m] &lt; nums[h]) &#123; h &#x3D; m; &#125; else &#123; l &#x3D; m + 1; &#125; &#125; return nums[l]; &#125; 如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。 例如对于数组{1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。 1234567891011121314151617181920212223242526private int findMixNumInRotateArray2(int[] nums) &#123; if (nums.length &#x3D;&#x3D; 0) &#123; return 0; &#125; int l &#x3D; 0, h &#x3D; nums.length - 1; while (l &lt; h) &#123; int m &#x3D; l + (h - 1) &#x2F; 2; if (nums[l] &#x3D;&#x3D; nums[m] || nums[m] &#x3D;&#x3D; nums[h]) &#123; return minNums(nums, l, h); &#125; else if (nums[m] &lt; nums[h]) &#123; h &#x3D; m; &#125; else &#123; l &#x3D; m + 1; &#125; &#125; return nums[l]; &#125; private int minNums(int[] nums, int l, int h) &#123; for (int i &#x3D; l; i &lt; h; i++) &#123; if (nums[i] &gt; nums[i + 1]) &#123; return nums[i + 1]; &#125; &#125; return nums[l]; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"3. 数组中重复的数字","slug":"算法/3. 数组中重复的数字","date":"2020-04-14T16:00:00.000Z","updated":"2020-04-21T12:31:42.739Z","comments":true,"path":"2020/04/15/suan-fa/3.shu-zu-zhong-chong-fu-de-shu-zi/","link":"","permalink":"https://eriecorner.github.io/2020/04/15/suan-fa/3.shu-zu-zhong-chong-fu-de-shu-zi/","excerpt":"","text":"题目描述在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的， 也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 题解：对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。本题要求找出重复的数字，因此在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。 代码实现：时间复杂度O（N），空间复杂度 O(1)。 123456789101112131415161718public boolean duplicate(int numbers[], int length, int[] duplication) &#123; if (numbers &#x3D;&#x3D; null || length &#x3D;&#x3D; 0) &#123; return false; &#125; for (int i &#x3D; 0; i &lt; length; i++) &#123; while (numbers[i] !&#x3D; i) &#123; if (numbers[i] &#x3D;&#x3D; numbers[numbers[i]]) &#123; duplication[0] &#x3D; numbers[i]; return true; &#125; else &#123; int temp &#x3D; numbers[i]; numbers[i] &#x3D; numbers[temp]; numbers[temp] &#x3D; temp; &#125; &#125; &#125; return false; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"4 二维数组中查找目标值","slug":"算法/4.  二维数组中查找目标值","date":"2020-04-14T16:00:00.000Z","updated":"2020-04-21T12:32:03.184Z","comments":true,"path":"2020/04/15/suan-fa/4.er-wei-shu-zu-zhong-cha-zhao-mu-biao-zhi/","link":"","permalink":"https://eriecorner.github.io/2020/04/15/suan-fa/4.er-wei-shu-zu-zhong-cha-zhao-mu-biao-zhi/","excerpt":"","text":"题目描述给定一个二维数组int num[M][N]，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。 题解：该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。 代码实现：时间复杂度O(MN) ，空间复杂度O(1) 12345678910111213141516public boolean find(int target, int[][] nums) &#123; if (nums &#x3D;&#x3D; null || nums.length &#x3D;&#x3D; 0 || nums[0].length &#x3D;&#x3D; 0) &#123; return false; &#125; int r &#x3D; 0, c &#x3D; nums[0].length - 1; while (r &lt; nums.length - 1 &amp;&amp; c &gt;&#x3D; 0) &#123; if (target &#x3D;&#x3D; nums[r][c]) &#123; return true; &#125;else if (target&gt;nums[r][c])&#123; r++; &#125;else &#123; c--; &#125; &#125; return false; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"1.1 斐波那契数列","slug":"算法/ 1.1 斐波那契数列","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-21T12:36:01.069Z","comments":true,"path":"2020/04/14/suan-fa/1.1-fei-bo-na-qi-shu-lie/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/suan-fa/1.1-fei-bo-na-qi-shu-lie/","excerpt":"","text":"题目描述：现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。n&lt;=39 题解：斐波那契数列如：1,1,2,3,5,8,13…；所以得知F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）。 代码实现 递归实现 —— 时间复杂度O(2^n）123456789public long fibonacci(int n) &#123; if (n &lt; 0) &#123; return 0; &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123; return 1; &#125; else &#123; return fibonacci(n - 1) + fibonacci(n - 2); &#125; &#125; 顺序求法——时间复杂度O(n）1234567891011121314151617public long fibonacci2(int n) &#123; long result &#x3D; 0; long preOne &#x3D; 1; long preTwo &#x3D; 1; if (n &lt; 0) &#123; return 0; &#125; if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123; return 1; &#125; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; result &#x3D; preOne + preTwo; preTwo &#x3D; preOne; preOne &#x3D; result; &#125; return result; &#125; 状态矩阵相乘法——时间复杂度O(log n）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 public long fibonacci3(int n) &#123; if (n &lt; 0) &#123; return 0; &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123; return 1; &#125; &#x2F;&#x2F;状态矩阵 int[][] base &#x3D; &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;; &#x2F;&#x2F;最后的结果需要求矩阵的n-2次 int[][] res &#x3D; matrixPower(base, n - 2); return res[0][0] + res[1][0]; &#125; &#x2F;&#x2F;求矩阵m的p次幂的值 private int[][] matrixPower(int[][] m, int p) &#123; int[][] res &#x3D; new int[m.length][m[0].length]; &#x2F;&#x2F;先把res设为单位矩阵，相当于整数中的1 for (int i &#x3D; 0; i &lt; res.length; i++) &#123; res[i][i] &#x3D; 1; &#125; &#x2F;&#x2F;临时矩阵 int[][] tmp &#x3D; m; for (; p !&#x3D; 0; p &gt;&gt;&#x3D; 1) &#123; if ((p &amp; 1) !&#x3D; 0) &#123;&#x2F;&#x2F;按位与操作，其实也就是位置为1的乘把这个矩阵乘一下 res &#x3D; muliMatrix(res, tmp); &#125; &#x2F;&#x2F; &#x2F;&#x2F;等于0 的时候我临时矩阵自己乘一下 tmp &#x3D; muliMatrix(tmp, tmp); &#125; return res; &#125; private int[][] muliMatrix(int[][] m1, int[][] m2) &#123; &#x2F;&#x2F;构造出一个m1行和m2列的矩阵（矩阵相乘规则） int[][] res &#x3D; new int[m1.length][m2[0].length]; &#x2F;&#x2F;给我们要得到的矩阵的每一个元素的值进行赋值操作 for (int i &#x3D; 0; i &lt; m1.length; i++) &#123; for (int j &#x3D; 0; j &lt; m2[0].length; j++) &#123; for (int k &#x3D; 0; k &lt; m2.length; k++) &#123;&#x2F;&#x2F;i，j位置元素的值就是i行元素和j行元素乘积的加和 res[i][j] +&#x3D; m1[i][k] * m2[k][j]; &#125; &#125; &#125; return res; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]},{"title":"1.2 矩形覆盖问题","slug":"算法/1.2 矩形覆盖问题","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-21T12:36:14.433Z","comments":true,"path":"2020/04/14/suan-fa/1.2-ju-xing-fu-gai-wen-ti/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/suan-fa/1.2-ju-xing-fu-gai-wen-ti/","excerpt":"","text":"题目描述：我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ 题解：f(1) = 1; f(2) = 2; n&gt;2则f(n) = f(n-1)+f(n-2) 代码实现：123456789101112public int coverRect(int n) &#123; if (n &lt;&#x3D; 2) &#123; return n; &#125; int preOne &#x3D; 2, preTwo &#x3D; 1, result &#x3D; 0; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; result &#x3D; preOne + preTwo; preTwo &#x3D; preOne; preOne &#x3D; result; &#125; return result; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]},{"title":"1.4 变态跳台阶问题","slug":"算法/1.4 变态跳台阶问题","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-21T12:36:43.501Z","comments":true,"path":"2020/04/14/suan-fa/1.4-bian-tai-tiao-tai-jie-wen-ti/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/suan-fa/1.4-bian-tai-tiao-tai-jie-wen-ti/","excerpt":"","text":"题目描述一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级… 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 题解： 跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么 f(n-1) = f(n-2) + f(n-3) + ... + f(0)； 同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么 f(n) = f(n-1) + f(n-2) + ... + f(0) 综上可得 f(n) - f(n-1) = f(n-1) 即 f(n) = 2*f(n-1)代码实现：123private int jumpFloorIn(int n) &#123; return (int) Math.pow(2, n - 1); &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]},{"title":"1.3 跳台阶问题","slug":"算法/1.3 跳台阶问题","date":"2020-04-13T16:00:00.000Z","updated":"2020-04-21T12:36:25.298Z","comments":true,"path":"2020/04/14/suan-fa/1.3-tiao-tai-jie-wen-ti/","link":"","permalink":"https://eriecorner.github.io/2020/04/14/suan-fa/1.3-tiao-tai-jie-wen-ti/","excerpt":"","text":"题目描述:一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 题解：f(1) = 1; f(2) = 2; n&gt;2则f(n) = f(n-1)+f(n-2) 代码实现：123456789101112private int jumpFloor(int n) &#123; if (n &lt;&#x3D; 2) &#123; return n; &#125; int preOne &#x3D; 2, preTwo &#x3D; 1, result &#x3D; 0; for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123; result &#x3D; preOne + preTwo; preTwo &#x3D; preOne; preOne &#x3D; result; &#125; return result; &#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]}],"categories":[{"name":"Android","slug":"Android","permalink":"https://eriecorner.github.io/categories/Android/"},{"name":"算法","slug":"算法","permalink":"https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"源码解析","slug":"源码解析","permalink":"https://eriecorner.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"},{"name":"二进制","slug":"二进制","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"数组","slug":"数组","permalink":"https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"队列","slug":"队列","permalink":"https://eriecorner.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"栈","slug":"栈","permalink":"https://eriecorner.github.io/tags/%E6%A0%88/"},{"name":"二叉树","slug":"二叉树","permalink":"https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"字符串","slug":"字符串","permalink":"https://eriecorner.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"链表","slug":"链表","permalink":"https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"斐波那契","slug":"斐波那契","permalink":"https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"}]}