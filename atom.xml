<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>紫依卓兰</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://eriecorner.github.io/"/>
  <updated>2020-04-25T13:04:19.803Z</updated>
  <id>https://eriecorner.github.io/</id>
  
  <author>
    <name>紫依卓兰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>13.二进制中1的个数</title>
    <link href="https://eriecorner.github.io/2020/04/25/13.er-jin-zhi-zhong-1-de-ge-shu/"/>
    <id>https://eriecorner.github.io/2020/04/25/13.er-jin-zhi-zhong-1-de-ge-shu/</id>
    <published>2020-04-24T16:00:00.000Z</published>
    <updated>2020-04-25T13:04:19.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>题目来源：<a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&tqId=11164&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></li><li>题设：输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>先看看二进制的表示：<blockquote><ul><li>正数的二进制原码、反码、补码都是相同的</li><li>负数的二进制原码：负数的绝对值的二进制的最高位变为1（1是标志位，只用来表示正负，1表示负数，0表示是正数。所以八位二进制的取值范围是[-127,127]），其余位与正数原码相同。</li><li>负数的反码：等于原码的最高位不变，其余取反。</li><li>负数的补码：等于原码的最高位不变，其余取反，然后加一。</li><li>正零和负零的补码相同，[+0]补=[-0]补=0000 0000B</li></ul></blockquote></li><li>所以如果一个整数不为0，那么这个整数至少有一位是1。通过二进制的运算可以得到一个规律：把一个整数减1的结果是把其二进制最右边的一个1开始的所有位都取反了。那么n&amp;（n-1）的二进制结果就是n的二进制的最右边一个1那一位开始所有位都会变成0。那么我们就可以使用这个规律进行求解。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int numOf1(int num) &#123;</span><br><span class="line">      int count &#x3D; 0;</span><br><span class="line">      while (num !&#x3D; 0) &#123;</span><br><span class="line">          count++;</span><br><span class="line">          num &#x3D; num &amp; (num - 1);</span><br><span class="line">      &#125;</span><br><span class="line">      return count;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="Kotlin实现"><a href="#Kotlin实现" class="headerlink" title="Kotlin实现"></a>Kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fun numOf1(num: Int): Int &#123;</span><br><span class="line">       var num &#x3D; num</span><br><span class="line">       var count &#x3D; 0</span><br><span class="line">       while (num !&#x3D; 0) &#123;</span><br><span class="line">           count++</span><br><span class="line">           num &#x3D; num and num - 1</span><br><span class="line">       &#125;</span><br><span class="line">       return count</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源：&lt;a href=&quot;https://www.nowcoder.com/practice/8ee967e4
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二进制" scheme="https://eriecorner.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>12. 剪绳子</title>
    <link href="https://eriecorner.github.io/2020/04/24/12.jian-sheng-zi/"/>
    <id>https://eriecorner.github.io/2020/04/24/12.jian-sheng-zi/</id>
    <published>2020-04-23T16:00:00.000Z</published>
    <updated>2020-04-24T09:39:40.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ul><li>来源：<a href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8" target="_blank" rel="noopener">NewCoder</a></li><li>题设：给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>先举几个例子找找规律：</p><blockquote><ul><li>2 :  1*1</li><li>3 :  1*2</li><li>4 ： 2*2</li><li>5 ： 2*3<ul><li>6 ： 3*3</li><li>7 ： 2*2*3 或者4*3</li></ul></li><li>8 ： 2*3*3</li><li>9 ： 3*3*3</li><li>10：2*2*3*3 或者4*3*3</li><li>11：2*3*3*3</li><li>12：3*3*3*3</li><li>13：2*2*3*3*3 或者4*3*3*3</li></ul></blockquote></li><li><p>由此可见：2，3包含于各个问题中，如果再往下剪得话，乘积就会变小。所以选择2，3作为做小的子问题。</p></li><li><p>当n≥5时，3(n−3)≥2(n−2)，所以我们尽可能多的剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。 </p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 剪绳子问题</span><br><span class="line">    *</span><br><span class="line">    * @param n 绳子长度 是整数且&gt;1</span><br><span class="line">    *          把绳子剪成整数长的m段，m是整数，且&gt;1</span><br><span class="line">    * @return</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public int cutRope(int n) &#123;</span><br><span class="line">       if (n &lt; 2) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       if (n &#x3D;&#x3D; 2) &#123;&#x2F;&#x2F;因为m&gt;1,所以只能是1*1</span><br><span class="line">           return 1;</span><br><span class="line">       &#125;</span><br><span class="line">       if (n &#x3D;&#x3D; 3) &#123;</span><br><span class="line">           return 2;</span><br><span class="line">       &#125;</span><br><span class="line">       int times3 &#x3D; n &#x2F; 3;</span><br><span class="line"></span><br><span class="line">       if (n % 3 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">           times3--;</span><br><span class="line">       &#125;</span><br><span class="line">       int times2 &#x3D; (n -3*times3) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">       return (int) (Math.pow(2, times2) * Math.pow(3, times3));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Kotlin-实现"><a href="#Kotlin-实现" class="headerlink" title="Kotlin 实现"></a>Kotlin 实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 剪绳子问题</span><br><span class="line">   *</span><br><span class="line">   * @param n 绳子长度 是整数且&gt;1</span><br><span class="line">   *          把绳子剪成整数长的m段，m是整数，且&gt;1</span><br><span class="line">   * @return</span><br><span class="line">   *&#x2F;</span><br><span class="line"> fun cutRope(n:Int):Int&#123;</span><br><span class="line">      if(n&lt;2)&#123;</span><br><span class="line">          return 0</span><br><span class="line">      &#125;</span><br><span class="line">      if (n&#x3D;&#x3D;2)&#123;&#x2F;&#x2F;因为m&gt;1,所以只能1*1</span><br><span class="line">          return 1</span><br><span class="line">      &#125;</span><br><span class="line">      if (n&#x3D;&#x3D;3)&#123;</span><br><span class="line">          return 2</span><br><span class="line">      &#125;</span><br><span class="line">      var times3 &#x3D; n&#x2F;3</span><br><span class="line">      if (times3%3&#x3D;&#x3D;1)&#123;</span><br><span class="line">          times3--</span><br><span class="line">      &#125;</span><br><span class="line">      val times2 &#x3D; (n- 3*times3)&#x2F;2</span><br><span class="line">      return (2.0.pow(times2.toDouble())* 3.0.pow(times3.toDouble())).toInt()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;来源：&lt;a href=&quot;https://www.nowcoder.com/practice/57d859
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>11.机器人的运动范围</title>
    <link href="https://eriecorner.github.io/2020/04/23/11.ji-qi-ren-de-yun-dong-fan-wei/"/>
    <id>https://eriecorner.github.io/2020/04/23/11.ji-qi-ren-de-yun-dong-fan-wei/</id>
    <published>2020-04-22T16:00:00.000Z</published>
    <updated>2020-04-24T09:40:36.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>从(0,0)开始走，每成功走一步标记当前位置为true,然后从当前位置往四个方向探索，返回1 + 44个方向的探索值之和。</li><li>探索时，判断当前节点是否可达的标准为：<ol><li>当前节点在矩阵内；</li><li>当前节点未被访问过；</li><li>当前节点满足limit限制。</li></ol></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 机器人的运动范围</span><br><span class="line">     *</span><br><span class="line">     * @param threshold</span><br><span class="line">     * @param rows</span><br><span class="line">     * @param cols</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int movingCount(int threshold, int rows, int cols) &#123;</span><br><span class="line"></span><br><span class="line">        if (rows &lt; 0 || cols &lt; 0 || threshold &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;标记矩阵中的格子是否走过</span><br><span class="line">        boolean[][] visit &#x3D; new boolean[rows][cols];</span><br><span class="line"></span><br><span class="line">        return findPathCount(threshold, rows, cols, 0, 0, visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param k </span><br><span class="line">     * @param rows</span><br><span class="line">     * @param cols</span><br><span class="line">     * @param i</span><br><span class="line">     * @param j</span><br><span class="line">     * @param visit</span><br><span class="line">     * @return 可走格子数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int findPathCount(int k, int rows, int cols, int i, int j, boolean[][] visit) &#123;</span><br><span class="line">        &#x2F;&#x2F;若越界或者已经走过或者当前位置的坐标不满足条件，则返回0</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; rows || j &gt;&#x3D; cols || visit[i][j] || !(sumIsOk(k, i, j))) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 标记当前位置已走过</span><br><span class="line">        visit[i][j] &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;当前位置的上下左右可走格子的和+1（当前格子）</span><br><span class="line">        return 1 + findPathCount(k, rows, cols, i + 1, j, visit)</span><br><span class="line">                + findPathCount(k, rows, cols, i - 1, j, visit)</span><br><span class="line">                + findPathCount(k, rows, cols, i, j - 1, visit)</span><br><span class="line">                + findPathCount(k, rows, cols, i, j + 1, visit);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param k</span><br><span class="line">     * @param row</span><br><span class="line">     * @param col</span><br><span class="line">     * @return 行坐标和列坐标的数位之和是否大于k</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean sumIsOk(int k, int row, int col) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        while (row !&#x3D; 0) &#123;</span><br><span class="line">            sum +&#x3D; row % 10;</span><br><span class="line">            row &#x3D; row &#x2F; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        while (col !&#x3D; 0) &#123;</span><br><span class="line">            sum +&#x3D; col % 10;</span><br><span class="line">            col &#x3D; col &#x2F; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum &lt;&#x3D; k;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Kotlin实现"><a href="#Kotlin实现" class="headerlink" title="Kotlin实现"></a>Kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     *机器人的运动范围</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun movingCount(k: Int, rows: Int, cols: Int): Int &#123;</span><br><span class="line">        if (k &lt; 0 || rows &lt; 0 || cols &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        val visit &#x3D; Array(rows) &#123; BooleanArray(cols) &#125;</span><br><span class="line">        return findPathCount(k, rows, cols, 0, 0, visit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *回溯法寻找可行走的格子</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun findPathCount(k: Int, rows: Int, cols: Int, i: Int, j: Int, visit: Array&lt;BooleanArray&gt;): Int &#123;</span><br><span class="line">        &#x2F;&#x2F;若越界或者已经走过或者当前位置的坐标不满足条件，则返回0</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; rows || j &gt;&#x3D; cols || visit[i][j] || !sumIsOk(k, i, j)) &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 标记当前位置已走过</span><br><span class="line">        visit[i][j] &#x3D; true</span><br><span class="line">        &#x2F;&#x2F;当前位置的上下左右可走格子的和+1（当前格子）</span><br><span class="line">        return (1 + findPathCount(k, rows, cols, i + 1, j, visit)</span><br><span class="line">                + findPathCount(k, rows, cols, i - 1, j, visit)</span><br><span class="line">                + findPathCount(k, rows, cols, i, j - 1, visit)</span><br><span class="line">                + findPathCount(k, rows, cols, i, j + 1, visit))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断 限制条件是否ok</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun sumIsOk(k: Int, row: Int, col: Int): Boolean &#123;</span><br><span class="line">        var row &#x3D; row</span><br><span class="line">        var col &#x3D; col</span><br><span class="line">        var sum &#x3D; 0</span><br><span class="line">        while (row !&#x3D; 0) &#123;</span><br><span class="line">            sum +&#x3D; row % 10</span><br><span class="line">            row &#x3D; row &#x2F; 10</span><br><span class="line">        &#125;</span><br><span class="line">        while (col !&#x3D; 0) &#123;</span><br><span class="line">            sum +&#x3D; col % 10</span><br><span class="line">            col &#x3D; col &#x2F; 10</span><br><span class="line">        &#125;</span><br><span class="line">        return sum &lt;&#x3D; k</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/6e5207314b5241fb83f
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>10. 矩阵中的路径</title>
    <link href="https://eriecorner.github.io/2020/04/22/10.ju-zhen-zhong-de-lu-jing/"/>
    <id>https://eriecorner.github.io/2020/04/22/10.ju-zhen-zhong-de-lu-jing/</id>
    <published>2020-04-21T16:00:00.000Z</published>
    <updated>2020-04-24T09:40:10.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ul><li>题目来源：<a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></li><li>题设：判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</li></ul><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><ul><li>本题使用回溯法进行求解（回溯法：从一条路往前走,能进则进,不能进则退回来,换一条路再试。）</li></ul><ol><li>根据给定的数组初始化一个标志位数组，初始化都位false，表示未走过，true表示走过，不能再走；</li><li>因为给定的matrix是一个一维数组，先根据二维数组的行数遍历的下标确定一维数组的位置：index = i*cols+j;</li><li>确定递归终止条件：越界、当前找到的矩阵值不等于字符串数组对应位置的值、已经走过的，这三类情况，都直接false，说明这条路不通</li><li>若k，就是待判定的字符串数组str的索引已经判断到了最后一位，此时说明是匹配成功的。</li><li>然后递归不断地寻找周围四个格子是否符合条件，只要有一个格子符合条件，就继续再找这个符合条件的格子的四周是否存在符合条件的格子，直到k到达末尾或者不满足递归条件就停止。</li><li>走到这一步，说明本次是不成功的，我们要还原一下标志位数组index处的标志位，进入下一轮的判断。</li></ol><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><ul><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123;</span><br><span class="line">       if (matrix &#x3D;&#x3D; null || rows &lt; 0 || cols &lt; 0) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       if (str &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;标志位，初始化为false</span><br><span class="line">       boolean[] visit &#x3D; new boolean[matrix.length];</span><br><span class="line">       for (int i &#x3D; 0; i &lt; rows; i++) &#123;</span><br><span class="line">           for (int j &#x3D; 0; j &lt; cols; j++) &#123;</span><br><span class="line">               &#x2F;&#x2F;循环遍历二维数组，找到起点等于str第一个元素的值，再递归判断四周是否有符合条件的----回溯法</span><br><span class="line">               if (find(matrix, i, j, rows, cols, visit, str, 0)) &#123;</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;find(初始矩阵，索引行坐标，索引列坐标，矩阵行数，矩阵列数，矩阵当前索引位置是否走过的标记，待判断的字符串，字符串初始位置为0 ，即先判断字符串的第一位)</span><br><span class="line">   private boolean find(char[] matrix, int row, int col, int rows, int cols, boolean[] visit, char[] str, int k) &#123;</span><br><span class="line">       &#x2F;&#x2F;先根据i和j计算匹配的第一个元素转为一维数组的位置</span><br><span class="line">       int index &#x3D; row * cols + col;</span><br><span class="line">       &#x2F;&#x2F;递归终止的条件：越界，当前找到的矩阵值不等于数组对应位置的值，已经走过的</span><br><span class="line">       if (row &lt; 0 || col &lt; 0 || row&gt;&#x3D;rows||col&gt;&#x3D;cols||matrix[index] !&#x3D; str[k] || visit[index] &#x3D;&#x3D; true) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       &#x2F;&#x2F;若k已经到达str末尾了，说明之前的都已经匹配成功了，直接返回true即可</span><br><span class="line">       if (k &#x3D;&#x3D; str.length - 1)</span><br><span class="line">           return true;</span><br><span class="line">       &#x2F;&#x2F;要走的第一个位置置为true，表示已经走过了</span><br><span class="line">       visit[index] &#x3D; true;</span><br><span class="line">       &#x2F;&#x2F;回溯，递归寻找，每次找到了就给k加一，找不到，还原</span><br><span class="line">       if (find(matrix, row + 1, col, rows, cols, visit, str, k + 1)</span><br><span class="line">               || find(matrix, row - 1, col, rows, cols, visit, str, k + 1)</span><br><span class="line">               || find(matrix, row, col+1, rows, cols, visit, str, k + 1)</span><br><span class="line">               || find(matrix, row, col-1, rows, cols, visit, str, k + 1)) &#123;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       visit[index] &#x3D; false;</span><br><span class="line">       &#x2F;&#x2F;走到这，说明这一条路不通，还原，再试其他的路径</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void hasPath() &#123;</span><br><span class="line">    char[] matrix &#x3D; &#123;&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;f&#39;, &#39;g&#39;, &#39;y&#39;, &#39;r&#39;, &#39;y&#39;, &#39;u&#39;, &#39;i&#39;, &#39;o&#39;, &#39;q&#39;&#125;;</span><br><span class="line">    int rows &#x3D; 3;</span><br><span class="line">    int cols &#x3D; 4;</span><br><span class="line">    char[] str &#x3D; &#123;&#39;y&#39;, &#39;r&#39;, &#39;i&#39;&#125;;</span><br><span class="line">    System.out.println(hasPath(matrix, rows, cols, str));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;返回 false</span><br><span class="line">&#x2F;&#x2F;str &#x3D; &#123;&#39;b&#39;,&#39;y&#39;,&#39;r&#39;&#125;时返回true</span><br></pre></td></tr></table></figure><h4 id="Kotlin实现"><a href="#Kotlin实现" class="headerlink" title="Kotlin实现"></a>Kotlin实现</h4></li><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">fun hasPath(matrix: CharArray, rows: Int, cols: Int, str: CharArray): Boolean &#123;</span><br><span class="line">        if (matrix &#x3D;&#x3D; null || rows &lt; 0 || cols &lt; 0) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        if (str &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        var visit &#x3D; BooleanArray(matrix.size);</span><br><span class="line">        for (i in 0 until rows) &#123;</span><br><span class="line">            for (j in 0 until cols) &#123;</span><br><span class="line">                if (find(matrix, i, j, rows, cols, str, 0, visit)) &#123;</span><br><span class="line">                    return true</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun find(matrix: CharArray, i: Int, j: Int, rows: Int, cols: Int, str: CharArray, k: Int, visit: BooleanArray): Boolean &#123;</span><br><span class="line">        var index &#x3D; i * cols + j;</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || j &gt;&#x3D; cols || i &gt;&#x3D; rows || matrix[index] !&#x3D; str[k] || visit[index]) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        if (k &#x3D;&#x3D; str.size - 1) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        if (find(matrix, i + 1, j, rows, cols, str, k + 1, visit) ||</span><br><span class="line">                find(matrix, i - 1, j, rows, cols, str, k + 1, visit) ||</span><br><span class="line">                find(matrix, i, j + 1, rows, cols, str, k + 1, visit) ||</span><br><span class="line">                find(matrix, i, j - 1, rows, cols, str, k + 1, visit)) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        visit[index] &#x3D; false</span><br><span class="line">        return false</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   fun testhasPath() &#123;</span><br><span class="line">       val matrix &#x3D; charArrayOf1(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;f&#39;, &#39;g&#39;, &#39;y&#39;, &#39;r&#39;, &#39;y&#39;, &#39;u&#39;, &#39;i&#39;, &#39;o&#39;, &#39;q&#39;)</span><br><span class="line">       val str &#x3D; charArrayOf1(&#39;y&#39;, &#39;r&#39;, &#39;i&#39;)</span><br><span class="line">       val rows &#x3D; 4</span><br><span class="line">       val cols &#x3D; 3</span><br><span class="line">      print(hasPath(matrix,rows,cols,str))</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;输出true</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源：&lt;a href=&quot;https://www.nowcoder.com/practice/c61c
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>9. 两个栈实现一个队列</title>
    <link href="https://eriecorner.github.io/2020/04/18/9.liang-ge-zhan-shi-xian-yi-ge-dui-lie/"/>
    <id>https://eriecorner.github.io/2020/04/18/9.liang-ge-zhan-shi-xian-yi-ge-dui-lie/</id>
    <published>2020-04-17T16:00:00.000Z</published>
    <updated>2020-04-21T12:33:05.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>栈是先进后出，队列是先进先出。即一序列元素入栈后，出站顺序被翻转，则一个栈（暂且称为inStack）中的元素出站时先放入另一个栈(暂且称为outStack)），然后outStack栈的出站顺序和inStack的入栈顺序一致，就是队列的入队出队顺序。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h4><ul><li><p>定义队列及其入队出队的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Queue &#123;</span><br><span class="line">       private Stack&lt;Integer&gt; inStack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">       private Stack&lt;Integer&gt; outStack &#x3D; new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * @param node</span><br><span class="line">        * 进栈操作</span><br><span class="line">        *&#x2F;</span><br><span class="line">       public void push(int node) &#123;</span><br><span class="line">           inStack.push(node);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * @return 队列中是否有元素</span><br><span class="line">        *&#x2F;</span><br><span class="line">       public boolean hasElement() &#123;</span><br><span class="line">           if (outStack.isEmpty() &amp;&amp; inStack.isEmpty()) &#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * @return 出栈操作</span><br><span class="line">        * @throws Exception</span><br><span class="line">        *&#x2F;</span><br><span class="line">       public int pop() throws Exception &#123;</span><br><span class="line">           if (outStack.isEmpty()) &#123;</span><br><span class="line">               while (!inStack.isEmpty()) &#123;</span><br><span class="line">                   outStack.push(inStack.pop());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (outStack.isEmpty()) &#123;</span><br><span class="line">               throw new Exception(&quot;queue is empty&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           return outStack.pop();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line"> public void getResult() throws Exception &#123;</span><br><span class="line">        Queue queue &#x3D; new Queue();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            queue.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while (queue.hasElement()) &#123;</span><br><span class="line">            System.out.println(queue.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;输出01234</span><br></pre></td></tr></table></figure><h4 id="Kotlin-实现"><a href="#Kotlin-实现" class="headerlink" title="Kotlin 实现"></a>Kotlin 实现</h4></li><li><p>构造队列并实现入队出队操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Queue &#123;</span><br><span class="line">        val inStack &#x3D; Stack&lt;Int&gt;();</span><br><span class="line">        val outStack &#x3D; Stack&lt;Int&gt;();</span><br><span class="line">        &#x2F;&#x2F;入栈操作</span><br><span class="line">        fun push(node: Int) &#123;</span><br><span class="line">            inStack.push(node)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;出站操作</span><br><span class="line">        fun pop(): Int &#123;</span><br><span class="line">            if (outStack.isEmpty()) &#123;</span><br><span class="line">                while (!inStack.isEmpty()) &#123;</span><br><span class="line">                    outStack.push(inStack.pop())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (outStack.isEmpty()) &#123;</span><br><span class="line">                throw Exception(&quot;queue is empty!&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            return outStack.pop()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fun hasElement(): Boolean &#123;</span><br><span class="line">            if (inStack.isEmpty() &amp;&amp; outStack.isEmpty()) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   fun getResult() &#123;</span><br><span class="line">      val queue &#x3D; Queue()</span><br><span class="line">       for (i:Int in 0..4)&#123;</span><br><span class="line">           queue.push(i)</span><br><span class="line">       &#125;</span><br><span class="line">       while (queue.hasElement())&#123;</span><br><span class="line">           print(queue.pop())</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;输出 01234</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
&lt;h2 id=&quot;题解&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="队列" scheme="https://eriecorner.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="栈" scheme="https://eriecorner.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>7. 重建二叉树</title>
    <link href="https://eriecorner.github.io/2020/04/17/7.chong-jian-er-cha-shu/"/>
    <id>https://eriecorner.github.io/2020/04/17/7.chong-jian-er-cha-shu/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-04-21T12:46:25.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><ul><li><p>首先定义树结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private class TreeNode &#123;</span><br><span class="line">      int node;&#x2F;&#x2F;节点</span><br><span class="line">      TreeNode left;&#x2F;&#x2F;左子树</span><br><span class="line">      TreeNode right;&#x2F;&#x2F;右子树</span><br><span class="line"></span><br><span class="line">      public TreeNode(int node) &#123;</span><br><span class="line">          this.node &#x3D; node;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public String toString() &#123;</span><br><span class="line">          return &quot;TreeNode [data&#x3D;&quot; + node + &quot;, left&#x3D;&quot; + left + &quot;, right&#x3D;&quot; + right</span><br><span class="line">                  + &quot;]&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>核心算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123;</span><br><span class="line">       if (pre.length &#x3D;&#x3D; 0 || in.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       TreeNode root &#x3D; rebuildBinaryTreeCoreAfter(pre,0,pre.length-1,in,0,in.length-1);</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public TreeNode rebuildBinaryTreeCore(int preorder[], int startPreorder,</span><br><span class="line">                                         int endPreorder, int inorder[], int startInorder, int endInorder) &#123;</span><br><span class="line">       if (startPreorder &gt; endPreorder || startInorder &gt; endInorder) &#123; &#x2F;&#x2F;停止递归的条件</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       TreeNode root &#x3D; new TreeNode(preorder[startPreorder]);</span><br><span class="line">       for (int i &#x3D; startInorder; i &lt;&#x3D; endInorder; i++) &#123;</span><br><span class="line">           if (preorder[startPreorder] &#x3D;&#x3D; inorder[i]) &#123;</span><br><span class="line">               &#x2F;&#x2F; 其中（i - startInorder）为中序排序中左子树结点的个数</span><br><span class="line">               &#x2F;&#x2F;左子树</span><br><span class="line">               root.left &#x3D; rebuildBinaryTreeCore(preorder, startPreorder + 1,</span><br><span class="line">                       startPreorder + (i - startInorder), inorder,</span><br><span class="line">                       startInorder, i-1 );</span><br><span class="line">               &#x2F;&#x2F;右子树</span><br><span class="line">               root.right &#x3D; rebuildBinaryTreeCore(preorder, (i - startInorder)</span><br><span class="line">                               + startPreorder + 1, endPreorder, inorder, i + 1,</span><br><span class="line">                       endInorder);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void getResult() &#123;</span><br><span class="line">        int[] pre &#x3D; &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;;</span><br><span class="line">        int[] mid &#x3D; &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;;</span><br><span class="line">        System.out.println(reConstructBinaryTree(pre,mid));</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F;树结构：</span><br><span class="line">              1</span><br><span class="line">              </span><br><span class="line">        2          3</span><br><span class="line">        </span><br><span class="line">    4           5     6</span><br><span class="line">                     </span><br><span class="line">      7             8</span><br></pre></td></tr></table></figure><h4 id="Kotlin实现"><a href="#Kotlin实现" class="headerlink" title="Kotlin实现"></a>Kotlin实现</h4></li><li><p>首先定义树结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data class TreeNode(val data: Int, var left: TreeNode? &#x3D; null, var right: TreeNode? &#x3D; null) &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>核心算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private fun reConstructBinaryTree(pre: IntArray, mid: IntArray): TreeNode? &#123;</span><br><span class="line">      if (pre.isEmpty() || mid.isEmpty()) &#123;</span><br><span class="line">          return null</span><br><span class="line">      &#125;</span><br><span class="line">      return reConstructBinaryTreeCore(pre, 0, pre.size - 1, mid, 0, mid.size - 1)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  private fun reConstructBinaryTreeCore(pre: IntArray, preStart: Int, preEnd: Int,</span><br><span class="line">                                        mid: IntArray, midStart: Int, midEnd: Int): TreeNode? &#123;</span><br><span class="line">      if (preStart &gt; preEnd || midStart &gt; midEnd) &#123;</span><br><span class="line">          return null</span><br><span class="line">      &#125;</span><br><span class="line">      val root &#x3D; TreeNode(pre[preStart]);</span><br><span class="line">      for (i in mid.indices) &#123;</span><br><span class="line">          if (mid[i] &#x3D;&#x3D; pre[preStart]) &#123;</span><br><span class="line">              &#x2F;&#x2F;（）i - midStart） 是为中序排序中左子树结点的个数</span><br><span class="line">              &#x2F;&#x2F;左子树</span><br><span class="line">              root.left &#x3D; reConstructBinaryTreeCore(pre, preStart + 1, preStart + (i - midStart),</span><br><span class="line">                      mid, midStart, i - 1)</span><br><span class="line">              &#x2F;&#x2F;右子树</span><br><span class="line">              root.right &#x3D; reConstructBinaryTreeCore(pre, preStart + (i - midStart) + 1, preEnd,</span><br><span class="line">                      mid, i + 1, midEnd)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun getResult() &#123;</span><br><span class="line">        val pre &#x3D; intArrayOf(1, 2, 4, 7, 3, 5, 6, 8)</span><br><span class="line">        val mid &#x3D; intArrayOf(4, 7, 2, 1, 5, 3, 8, 6)</span><br><span class="line">        print(reConstructBinaryTree(pre, mid ));</span><br><span class="line">    &#125;   </span><br><span class="line">    &#x2F;&#x2F;树结构</span><br><span class="line">    </span><br><span class="line">             1</span><br><span class="line">              </span><br><span class="line">        2          3</span><br><span class="line">        </span><br><span class="line">    4           5     6</span><br><span class="line">                     </span><br><span class="line">      7             8</span><br></pre></td></tr></table></figure></li></ul><h2 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h2><p>根据二叉树的后序遍历和中序遍历的结果，重建出该二叉树。假设输入的后序遍历和中序遍历的结果中都不含重复的数字。</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>思路同上，后序序遍历的最后一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现-1"><a href="#JAVA实现-1" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><ul><li>核心算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private TreeNode rebuildBinaryTreeCoreAfter(int[] after,int afterStart,int afterEnd,int[]mid ,int midStart,int midEnd )&#123;</span><br><span class="line">        if (afterStart&gt;afterEnd||midStart&gt;midEnd)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root &#x3D; new TreeNode(after[afterEnd]);</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; midEnd; i++) &#123;</span><br><span class="line">            if (after[afterEnd]&#x3D;&#x3D;mid[i])&#123;</span><br><span class="line">                root.left &#x3D; rebuildBinaryTreeCoreAfter(after,afterStart,afterStart-1+(i-midStart),</span><br><span class="line">                        mid,midStart,i-1);</span><br><span class="line">                root.right &#x3D; rebuildBinaryTreeCoreAfter(after,afterStart+(i-midStart),afterEnd-1,</span><br><span class="line">                        mid,i+1,midEnd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>验证<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void getResult() &#123;</span><br><span class="line">       &#x2F;&#x2F;int[] pre &#x3D; &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;;</span><br><span class="line">       &#x2F;&#x2F;int[] mid &#x3D; &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;;</span><br><span class="line">       &#x2F;&#x2F;System.out.println(reConstructBinaryTree(pre,mid));</span><br><span class="line">       int[] after &#x3D; &#123;2,4,3,1,6,7,5&#125;;</span><br><span class="line">       int[] mid &#x3D; &#123;1,2,3,4,5,6,7&#125;;</span><br><span class="line">       System.out.println(reConstructBinaryTree(after,mid));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;树结构</span><br><span class="line">        5</span><br><span class="line">   </span><br><span class="line">   1        7</span><br><span class="line">   </span><br><span class="line">     3     6</span><br><span class="line">      </span><br><span class="line">   2   4</span><br></pre></td></tr></table></figure><h4 id="Kotlin实现-1"><a href="#Kotlin实现-1" class="headerlink" title="Kotlin实现"></a>Kotlin实现</h4></li><li>核心算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private fun reConstructBinaryTreeAfter(pre: Array&lt;Int&gt;, mid: Array&lt;Int&gt;): TreeNode? &#123;</span><br><span class="line">    if (pre.isEmpty() || mid.isEmpty()) &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">    val root &#x3D; reConstructBinaryTreeCoreAfter(pre, 0, pre.size - 1, mid, 0, mid.size - 1)</span><br><span class="line">    return root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private fun reConstructBinaryTreeCoreAfter(after: Array&lt;Int&gt;, afterStart: Int, afterEnd: Int,</span><br><span class="line">                                           mid: Array&lt;Int&gt;, midStart: Int, midEnd: Int): TreeNode? &#123;</span><br><span class="line">    if (afterStart &gt; afterEnd || midStart &gt; midEnd)</span><br><span class="line">        return null</span><br><span class="line">    val root &#x3D; TreeNode(after[afterEnd])</span><br><span class="line">    for (i in mid.indices) &#123;</span><br><span class="line">        if (mid[i] &#x3D;&#x3D; after[afterEnd]) &#123;</span><br><span class="line">            root.left &#x3D; reConstructBinaryTreeCoreAfter(after, afterStart, afterStart - 1 + (i - midStart),</span><br><span class="line">                    mid, midStart, i - 1)</span><br><span class="line">            root.right &#x3D; reConstructBinaryTreeCoreAfter(after, afterStart + (i - midStart),</span><br><span class="line">                    afterEnd - 1, mid, i + 1, midEnd)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>验证<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun getResult() &#123;</span><br><span class="line">&#x2F;&#x2F;        val pre &#x3D; intArrayOf(1, 2, 4, 7, 3, 5, 6, 8)</span><br><span class="line">&#x2F;&#x2F;        val mid &#x3D; intArrayOf(4, 7, 2, 1, 5, 3, 8, 6)</span><br><span class="line">&#x2F;&#x2F;        print(reConstructBinaryTree(pre, mid ));</span><br><span class="line"></span><br><span class="line">        val after &#x3D; arrayOf(2,4,3,1,6,7,5)</span><br><span class="line">        val ins  &#x3D; arrayOf(1,2,3,4,5,6,7)</span><br><span class="line">        print(reConstructBinaryTreeAfter(after, ins));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;树结构</span><br><span class="line">         5</span><br><span class="line">    </span><br><span class="line">    1        7</span><br><span class="line">    </span><br><span class="line">      3     6</span><br><span class="line">       </span><br><span class="line">    2   4</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>8. 查找二叉树的下一个节点</title>
    <link href="https://eriecorner.github.io/2020/04/17/8.cha-zhao-er-cha-shu-de-xia-yi-ge-jie-dian/"/>
    <id>https://eriecorner.github.io/2020/04/17/8.cha-zhao-er-cha-shu-de-xia-yi-ge-jie-dian/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-04-21T12:44:05.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回 。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>二叉树的中序遍历为：先遍历树的左子树，再遍历根节点，最后再遍历右子树。所以最左节点是中序遍历的第一个节点。</p><ul><li>如果一个节点的右子树不为空，则该节点的下一个节点是右子树的最左节点；</li><li>如果该节点的右子树为空，则不断向上找该节点的父节点的左子树，直到找到第一个左子树包含该节点，则该节点的下一个节点为此父节点。</li><li>若这两种都没有找到，则该节点没有下一个节点。<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h4></li><li>构造二叉树<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeLinkNode left &#x3D; null;</span><br><span class="line">    TreeLinkNode right &#x3D; null;</span><br><span class="line">    TreeLinkNode next &#x3D; null;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode(int val) &#123;</span><br><span class="line">        this.val &#x3D; val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>核心算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public TreeLinkNode GetNext(TreeLinkNode pNode)</span><br><span class="line">   &#123; if (pNode.right!&#x3D;null)&#123;</span><br><span class="line">           TreeLinkNode node &#x3D; pNode.right;</span><br><span class="line">           while (node.left!&#x3D;null)&#123;</span><br><span class="line">               node &#x3D; node.left;</span><br><span class="line">           &#125;</span><br><span class="line">           return node;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           while (pNode.next!&#x3D;null)&#123;</span><br><span class="line">               TreeLinkNode parent &#x3D; pNode.next;</span><br><span class="line">               if (parent.left&#x3D;&#x3D;pNode)&#123;</span><br><span class="line">                   return parent;</span><br><span class="line">               &#125;</span><br><span class="line">               pNode &#x3D; pNode.next;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Kotlin实现"><a href="#Kotlin实现" class="headerlink" title="Kotlin实现"></a>Kotlin实现</h4></li><li>构造二叉树<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class TreeLinkNode(val data: Int, var left: TreeLinkNode?, var right: TreeLinkNode?, var next: TreeLinkNode?) &#123;&#125;</span><br></pre></td></tr></table></figure></li><li>核心算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private fun getNext( pNode: TreeLinkNode): TreeLinkNode? &#123;</span><br><span class="line">       if (pNode.right !&#x3D; null) &#123;</span><br><span class="line">           var node: TreeLinkNode &#x3D; pNode.right!!</span><br><span class="line">           while (node.left !&#x3D; null) &#123;</span><br><span class="line">               node &#x3D; node.left!!</span><br><span class="line">           &#125;</span><br><span class="line">           return node</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           var nextNode &#x3D; pNode</span><br><span class="line">           while (nextNode.next !&#x3D; null) &#123;</span><br><span class="line">               var parent &#x3D; pNode.next!!</span><br><span class="line">               if (parent.left &#x3D;&#x3D; pNode) &#123;</span><br><span class="line">                   return parent</span><br><span class="line">               &#125;</span><br><span class="line">               nextNode &#x3D; pNode.next!!</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return null</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回 。注意，树中的结点不仅包含左右子结点，同时包含指向父
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>5. 替换空格</title>
    <link href="https://eriecorner.github.io/2020/04/16/5.ti-huan-kong-ge/"/>
    <id>https://eriecorner.github.io/2020/04/16/5.ti-huan-kong-ge/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-04-21T12:32:15.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>将一个字符串中的空格替换成 “%20”。</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>从后往前复制，数组长度会增加，或使用StringBuffer，StringBuild类。</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>时间复杂度O（N），空间复杂度O（N）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public String replaceSpace(String value)&#123;</span><br><span class="line">       if (value&#x3D;&#x3D;null)&#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line">       for (int i &#x3D; 0; i &lt;value.length() ; i++) &#123;</span><br><span class="line">           if (String.valueOf(value.charAt(i)).equals(&quot; &quot;))&#123;</span><br><span class="line">               builder.append(&quot;%20&quot;);</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               builder.append(value.charAt(i));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return builder.toString();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;将一个字符串中的空格替换成 “%20”。&lt;/p&gt;
&lt;h2 id=&quot;题解：&quot;&gt;&lt;a href=&quot;#题解：&quot; class
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="https://eriecorner.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>6. 从尾到头打印链表</title>
    <link href="https://eriecorner.github.io/2020/04/16/6.cong-wei-dao-tou-da-yin-lian-biao/"/>
    <id>https://eriecorner.github.io/2020/04/16/6.cong-wei-dao-tou-da-yin-lian-biao/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-04-21T12:44:26.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>从尾到头反过来打印出每个结点的值。</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h3 id="1-使用栈"><a href="#1-使用栈" class="headerlink" title="1. 使用栈"></a>1. 使用栈</h3><p>栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。</p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先定义一个节点</span><br><span class="line">    public static class ListNode &#123;</span><br><span class="line">        private int value;</span><br><span class="line">        private ListNode next;</span><br><span class="line"></span><br><span class="line">        public ListNode(int node) &#123;</span><br><span class="line">            this.value &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;构建链表</span><br><span class="line">      private ListNode BuildLinkList() &#123;</span><br><span class="line">        ListNode head &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; head;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 10; i++) &#123;</span><br><span class="line">            ListNode tmp &#x3D; new ListNode(i);</span><br><span class="line">            cur.next&#x3D; tmp;</span><br><span class="line">            cur &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> public ArrayList&lt;Integer&gt; printListFromTrilToHead(ListNode listNode)&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        while (listNode!&#x3D;null)&#123;</span><br><span class="line">            stack.add(listNode.value);</span><br><span class="line">            listNode &#x3D; listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            ret.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h4><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTrilToHead1(ListNode listNode) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (listNode !&#x3D; null) &#123;</span><br><span class="line">            ret.addAll(printListFromTrilToHead1(listNode.next));</span><br><span class="line">            ret.add(listNode.value);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-遍历node的每一个节点插入到集合的第一个位置"><a href="#3-遍历node的每一个节点插入到集合的第一个位置" class="headerlink" title="3.遍历node的每一个节点插入到集合的第一个位置"></a>3.遍历node的每一个节点插入到集合的第一个位置</h4><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTrilToHead2(ListNode listNode) &#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">       ListNode tmp &#x3D; listNode;</span><br><span class="line">       while (tmp !&#x3D; null) &#123;</span><br><span class="line">           ret.add(0,tmp.value);</span><br><span class="line">           tmp &#x3D; tmp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="4-头插法"><a href="#4-头插法" class="headerlink" title="4. 头插法"></a>4. 头插法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTrilToHead3(ListNode listNode) &#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">       ListNode head &#x3D; new ListNode(-1);</span><br><span class="line">       while (listNode !&#x3D; null) &#123;</span><br><span class="line">           ListNode tmp &#x3D; listNode.next;</span><br><span class="line">           listNode.next &#x3D; head.next;</span><br><span class="line">           head.next &#x3D; listNode;</span><br><span class="line">           listNode &#x3D; tmp;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       head &#x3D; head.next;</span><br><span class="line">       while (head !&#x3D; null) &#123;</span><br><span class="line">           ret.add(head.value);</span><br><span class="line">           head &#x3D; head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;从尾到头反过来打印出每个结点的值。&lt;/p&gt;
&lt;h2 id=&quot;题解：&quot;&gt;&lt;a href=&quot;#题解：&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>2. 旋转数组中的最小元素</title>
    <link href="https://eriecorner.github.io/2020/04/15/2.xuan-zhuan-shu-zu-zhong-de-zui-xiao-yuan-su/"/>
    <id>https://eriecorner.github.io/2020/04/15/2.xuan-zhuan-shu-zu-zhong-de-zui-xiao-yuan-su/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-04-21T12:43:53.289Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>利用折半查找的思想，时间复杂度度为O（logN），为了方便，这里将 log2N 写为 logN</p><p>将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。</p><p>（l 代表 low，m 代表 mid，h 代表 high）<br>当 nums[m] &lt;= nums[h] 时，表示 [m, h]</p><p>区间内的数组是非递减数组，[l, m]</p><p>区间内的数组是旋转数组，此时令 h = m；</p><p>否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int findMixNumInRotateArray(int[] nums) &#123;</span><br><span class="line">       if (nums.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       int l &#x3D; 0, h &#x3D; nums.length - 1;</span><br><span class="line">       while (l &lt; h) &#123;</span><br><span class="line">           int m &#x3D; l + (h - 1) &#x2F; 2;</span><br><span class="line">           if (nums[m] &lt; nums[h]) &#123;</span><br><span class="line">               h &#x3D; m;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               l &#x3D; m + 1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return nums[l];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。</strong></p><p><em>例如对于数组{1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。</em> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private int findMixNumInRotateArray2(int[] nums) &#123;</span><br><span class="line">     if (nums.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">         return 0;</span><br><span class="line">     &#125;</span><br><span class="line">     int l &#x3D; 0, h &#x3D; nums.length - 1;</span><br><span class="line">     while (l &lt; h) &#123;</span><br><span class="line">         int m &#x3D; l + (h - 1) &#x2F; 2;</span><br><span class="line">         if (nums[l] &#x3D;&#x3D; nums[m] || nums[m] &#x3D;&#x3D; nums[h]) &#123;</span><br><span class="line">             return minNums(nums, l, h);</span><br><span class="line">         &#125; else if (nums[m] &lt; nums[h]) &#123;</span><br><span class="line">             h &#x3D; m;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             l &#x3D; m + 1;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return nums[l];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private int minNums(int[] nums, int l, int h) &#123;</span><br><span class="line">     for (int i &#x3D; l; i &lt; h; i++) &#123;</span><br><span class="line">         if (nums[i] &gt; nums[i + 1]) &#123;</span><br><span class="line">             return nums[i + 1];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return nums[l];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>4 二维数组中查找目标值</title>
    <link href="https://eriecorner.github.io/2020/04/15/4.er-wei-shu-zu-zhong-cha-zhao-mu-biao-zhi/"/>
    <id>https://eriecorner.github.io/2020/04/15/4.er-wei-shu-zu-zhong-cha-zhao-mu-biao-zhi/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-04-21T12:32:03.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二维数组int num[M][N]，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>时间复杂度O(MN) ，空间复杂度O(1)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public boolean find(int target, int[][] nums) &#123;</span><br><span class="line">       if (nums &#x3D;&#x3D; null || nums.length &#x3D;&#x3D; 0 || nums[0].length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       int r &#x3D; 0, c &#x3D; nums[0].length - 1;</span><br><span class="line">       while (r &lt; nums.length - 1 &amp;&amp; c &gt;&#x3D; 0) &#123;</span><br><span class="line">           if (target &#x3D;&#x3D; nums[r][c]) &#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125;else if (target&gt;nums[r][c])&#123;</span><br><span class="line">               r++;</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               c--;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;给定一个二维数组int num[M][N]，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>3. 数组中重复的数字</title>
    <link href="https://eriecorner.github.io/2020/04/15/3.shu-zu-zhong-chong-fu-de-shu-zi/"/>
    <id>https://eriecorner.github.io/2020/04/15/3.shu-zu-zhong-chong-fu-de-shu-zi/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-04-21T12:31:42.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的， 也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。本题要求找出重复的数字，<br>因此在调整过程中，如果第 i 位置上已经有一个值为 i 的元素，就可以知道 i 值重复。</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>时间复杂度O（N），空间复杂度 O(1)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean duplicate(int numbers[], int length, int[] duplication) &#123;</span><br><span class="line">        if (numbers &#x3D;&#x3D; null || length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            while (numbers[i] !&#x3D; i) &#123;</span><br><span class="line">                if (numbers[i] &#x3D;&#x3D; numbers[numbers[i]]) &#123;</span><br><span class="line">                    duplication[0] &#x3D; numbers[i];</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    int temp &#x3D; numbers[i];</span><br><span class="line">                    numbers[i] &#x3D; numbers[temp];</span><br><span class="line">                    numbers[temp] &#x3D; temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的， 也
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>1.1 斐波那契数列</title>
    <link href="https://eriecorner.github.io/2020/04/14/1.1-fei-bo-na-qi-shu-lie/"/>
    <id>https://eriecorner.github.io/2020/04/14/1.1-fei-bo-na-qi-shu-lie/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-04-21T12:36:01.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。n&lt;=39</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>斐波那契数列如：1,1,2,3,5,8,13…；所以得知F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li>递归实现 —— 时间复杂度O(2^n）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public long fibonacci(int n) &#123;</span><br><span class="line">       if (n &lt; 0) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">           return 1;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>顺序求法——时间复杂度O(n）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public long fibonacci2(int n) &#123;</span><br><span class="line">       long result &#x3D; 0;</span><br><span class="line">       long preOne &#x3D; 1;</span><br><span class="line">       long preTwo &#x3D; 1;</span><br><span class="line">       if (n &lt; 0) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">           return 1;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">           result &#x3D; preOne + preTwo;</span><br><span class="line">           preTwo &#x3D; preOne;</span><br><span class="line">           preOne &#x3D; result;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>状态矩阵相乘法——时间复杂度O(log n）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> public long fibonacci3(int n) &#123;</span><br><span class="line">        if (n &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;状态矩阵</span><br><span class="line">        int[][] base &#x3D; &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;</span><br><span class="line">        &#x2F;&#x2F;最后的结果需要求矩阵的n-2次</span><br><span class="line">        int[][] res &#x3D; matrixPower(base, n - 2);</span><br><span class="line">        return res[0][0] + res[1][0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;求矩阵m的p次幂的值</span><br><span class="line">    private int[][] matrixPower(int[][] m, int p) &#123;</span><br><span class="line">        int[][] res &#x3D; new int[m.length][m[0].length];</span><br><span class="line">        &#x2F;&#x2F;先把res设为单位矩阵，相当于整数中的1</span><br><span class="line">        for (int i &#x3D; 0; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i][i] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;临时矩阵</span><br><span class="line">        int[][] tmp &#x3D; m;</span><br><span class="line">        for (; p !&#x3D; 0; p &gt;&gt;&#x3D; 1) &#123;</span><br><span class="line">            if ((p &amp; 1) !&#x3D; 0) &#123;</span><br><span class="line">&#x2F;&#x2F;按位与操作，其实也就是位置为1的乘把这个矩阵乘一下</span><br><span class="line">                res &#x3D; muliMatrix(res, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;</span><br><span class="line">            &#x2F;&#x2F;等于0 的时候我临时矩阵自己乘一下</span><br><span class="line">            tmp &#x3D; muliMatrix(tmp, tmp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private int[][] muliMatrix(int[][] m1, int[][] m2) &#123;</span><br><span class="line">        &#x2F;&#x2F;构造出一个m1行和m2列的矩阵（矩阵相乘规则）</span><br><span class="line">        int[][] res &#x3D; new int[m1.length][m2[0].length];</span><br><span class="line">        &#x2F;&#x2F;给我们要得到的矩阵的每一个元素的值进行赋值操作</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m1.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; m2[0].length; j++) &#123;</span><br><span class="line">                for (int k &#x3D; 0; k &lt; m2.length; k++) &#123;</span><br><span class="line">&#x2F;&#x2F;i，j位置元素的值就是i行元素和j行元素乘积的加和</span><br><span class="line">                    res[i][j] +&#x3D; m1[i][k] * m2[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。n&amp;lt;=39&lt;/p&gt;
&lt;h2 id=&quot;题解：&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="斐波那契" scheme="https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
  </entry>
  
  <entry>
    <title>1.2 矩形覆盖问题</title>
    <link href="https://eriecorner.github.io/2020/04/14/1.2-ju-xing-fu-gai-wen-ti/"/>
    <id>https://eriecorner.github.io/2020/04/14/1.2-ju-xing-fu-gai-wen-ti/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-04-21T12:36:14.433Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>f(1) = 1; f(2) = 2; n&gt;2则f(n) = f(n-1)+f(n-2)</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int coverRect(int n) &#123;</span><br><span class="line">        if (n &lt;&#x3D; 2) &#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int preOne &#x3D; 2, preTwo &#x3D; 1, result &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            result &#x3D; preOne + preTwo;</span><br><span class="line">            preTwo &#x3D; preOne;</span><br><span class="line">            preOne &#x3D; result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="斐波那契" scheme="https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
  </entry>
  
  <entry>
    <title>1.3 跳台阶问题</title>
    <link href="https://eriecorner.github.io/2020/04/14/1.3-tiao-tai-jie-wen-ti/"/>
    <id>https://eriecorner.github.io/2020/04/14/1.3-tiao-tai-jie-wen-ti/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-04-21T12:36:25.298Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h4><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>f(1) = 1; f(2) = 2; n&gt;2则f(n) = f(n-1)+f(n-2)</p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private int jumpFloor(int n) &#123;</span><br><span class="line">        if (n &lt;&#x3D; 2) &#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int preOne &#x3D; 2, preTwo &#x3D; 1, result &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            result &#x3D; preOne + preTwo;</span><br><span class="line">            preTwo &#x3D; preOne;</span><br><span class="line">            preOne &#x3D; result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述:&quot;&gt;&lt;/a&gt;题目描述:&lt;/h4&gt;&lt;p&gt;一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;h4 
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="斐波那契" scheme="https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
  </entry>
  
  <entry>
    <title>1.4 变态跳台阶问题</title>
    <link href="https://eriecorner.github.io/2020/04/14/1.4-bian-tai-tiao-tai-jie-wen-ti/"/>
    <id>https://eriecorner.github.io/2020/04/14/1.4-bian-tai-tiao-tai-jie-wen-ti/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-04-21T12:36:43.501Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级… 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><pre><code>  跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么f(n-1) = f(n-2) + f(n-3) + ... + f(0)；同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么  f(n) = f(n-1) + f(n-2) + ... + f(0)综上可得  f(n) - f(n-1) = f(n-1)即  f(n) = 2*f(n-1)</code></pre><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private int jumpFloorIn(int n) &#123;</span><br><span class="line">       return (int) Math.pow(2, n - 1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级… 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="斐波那契" scheme="https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
  </entry>
  
</feed>
