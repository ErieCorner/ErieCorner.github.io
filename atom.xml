<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>紫依卓兰</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://eriecorner.github.io/"/>
  <updated>2020-05-18T13:43:59.417Z</updated>
  <id>https://eriecorner.github.io/</id>
  
  <author>
    <name>紫依卓兰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【剑指Offer】21. 顺时针打印矩阵</title>
    <link href="https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/21.shun-shi-zhen-da-yin-ju-zhen/"/>
    <id>https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/21.shun-shi-zhen-da-yin-ju-zhen/</id>
    <published>2020-05-18T13:41:05.531Z</published>
    <updated>2020-05-18T13:43:59.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li><p>题目来源： <a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github" target="_blank" rel="noopener">Nowcoder</a></p></li><li><p>题设： 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;bmatrix&#125;</span><br><span class="line">1&amp;2&amp;3&amp;4\\</span><br><span class="line">5&amp;6&amp;7&amp;8\\</span><br><span class="line">9&amp;10&amp;11&amp;12\\</span><br><span class="line">13&amp;14&amp;15&amp;16</span><br><span class="line">\end&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><p>则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>顺时针遍历即从左到右，再从右上到右下，从右到左，再从左下到左上这个环形遍历。</li><li>则标记left = 0，top = 0，right = row-1;bottom = col-1；</li><li>从左到右（left<del>right）遍历完一行后，top向下移动一位（top+1）；从右上到右下遍历（top</del>bottom）一列后，right向左移动一位（right-1）；当bottom&gt;=tops时，有必要从右到左（right<del>left）遍历，这一行遍历完后bottom向上移动一位（bottom-1）;当right&gt;=left时，有必要从下向上遍历（bottom</del>top）,这一边遍历完后，left向右移动一位（left+1）;</li><li>当左边标记（left）大于右边（right）标记或者上边标记（top）大于下边标记（bottom）时，证明已经遍历完。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * @param matrix</span><br><span class="line">     * @return 顺时针打印矩阵</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) &#123;</span><br><span class="line">        ArrayList result &#x3D; new ArrayList();</span><br><span class="line">        int left &#x3D; 0, right &#x3D; matrix[0].length - 1, top &#x3D; 0, bottom &#x3D; matrix.length - 1;</span><br><span class="line">        while (left &lt;&#x3D; right &amp;&amp; top &lt;&#x3D; bottom) &#123;</span><br><span class="line">            for (int i &#x3D; left; i &lt;&#x3D; right; i++) &#123;&#x2F;&#x2F;左到右</span><br><span class="line">                result.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            for (int i &#x3D; top; i &lt;&#x3D; bottom; i++) &#123;&#x2F;&#x2F;右上到右下</span><br><span class="line">                result.add(matrix[i][right]);</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">            if (bottom &gt;&#x3D; top) &#123;</span><br><span class="line">                for (int i &#x3D; right; i &gt;&#x3D; left; i--) &#123;&#x2F;&#x2F;右到左</span><br><span class="line">                    result.add(matrix[bottom][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                bottom--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (right &gt;&#x3D; left) &#123;</span><br><span class="line">                for (int i &#x3D; bottom; i &gt;&#x3D; top; i--) &#123;&#x2F;&#x2F;左下到左上</span><br><span class="line">                    result.add(matrix[i][left]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><ul><li>核心实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 顺时针打印矩阵</span><br><span class="line">    *&#x2F;</span><br><span class="line">   fun printMatrix(matrix: Array&lt;IntArray&gt;): java.util.ArrayList&lt;Int&gt; &#123;</span><br><span class="line">       val result &#x3D; java.util.ArrayList&lt;Int&gt;()</span><br><span class="line">       var left &#x3D; 0</span><br><span class="line">       var right: Int &#x3D; matrix[0].size - 1</span><br><span class="line">       var top &#x3D; 0</span><br><span class="line">       var bottom &#x3D; matrix.size - 1</span><br><span class="line">       while (left &lt;&#x3D; right &amp;&amp; top &lt;&#x3D; bottom) &#123; &#x2F;&#x2F;当左标记不大于有标记并且上标记不大于下标记的时候进行循环打印</span><br><span class="line">           for (i in left..right) &#123; &#x2F;&#x2F;左到右</span><br><span class="line">               result.add(matrix[top][i])</span><br><span class="line">           &#125;</span><br><span class="line">           top++ &#x2F;&#x2F;行加一</span><br><span class="line">           for (i in top..bottom) &#123; &#x2F;&#x2F;右上到右下</span><br><span class="line">               result.add(matrix[i][right])</span><br><span class="line">           &#125;</span><br><span class="line">           right-- &#x2F;&#x2F;列减一</span><br><span class="line">           if (bottom &gt;&#x3D; top) &#123;</span><br><span class="line">               for (i in right downTo left) &#123; &#x2F;&#x2F;右到左</span><br><span class="line">                   result.add(matrix[bottom][i])</span><br><span class="line">               &#125;</span><br><span class="line">               bottom-- &#x2F;&#x2F;行减一</span><br><span class="line">           &#125;</span><br><span class="line">           if (right &gt;&#x3D; left) &#123;</span><br><span class="line">               for (i in bottom downTo top) &#123; &#x2F;&#x2F;左下到左上</span><br><span class="line">                   result.add(matrix[i][left])</span><br><span class="line">               &#125;</span><br><span class="line">               left++ &#x2F;&#x2F;列加一</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return result</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   fun getResult4() &#123;</span><br><span class="line">       val arr &#x3D; arrayOf(intArrayOf(1, 2, 3, 4, 5), intArrayOf(6, 7, 8, 9, 10), intArrayOf(11, 12, 13, 14, 15), intArrayOf(16, 17, 18, 19, 20))</span><br><span class="line">       println(printMatrix(arr))</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;题目来源： &lt;a href=&quot;https://www.nowcoder.com/practice/9b4c
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】20. 二叉树的镜像</title>
    <link href="https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/20.er-cha-shu-de-jing-xiang/"/>
    <id>https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/20.er-cha-shu-de-jing-xiang/</id>
    <published>2020-05-18T13:41:00.346Z</published>
    <updated>2020-05-18T13:44:49.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>题目来源： <a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&tqId=11171&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github" target="_blank" rel="noopener">Nowcoder</a></li><li>题设：操作给定的二叉树，将其变换为源二叉树的镜像。</li><li>输入描述: 二叉树的镜像定义：源二叉树 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       8</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  6   10</span><br><span class="line"> &#x2F; \  &#x2F; \</span><br><span class="line">5  7 9 11</span><br><span class="line">镜像二叉树</span><br><span class="line">    8</span><br><span class="line">   &#x2F;  \</span><br><span class="line">  10   6</span><br><span class="line"> &#x2F; \  &#x2F; \</span><br><span class="line">11 9 7  5</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>当左右节点不为空时将左右节点交换位置<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2></li></ul><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><ul><li>定义树节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private class TreeNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int node) &#123;</span><br><span class="line">            this.val &#x3D; node;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;TreeNode [data&#x3D;&quot; + val + &quot;, left&#x3D;&quot; + left + &quot;, right&#x3D;&quot; + right</span><br><span class="line">                    + &quot;]&quot;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param root 求一个二叉树的镜像</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void Mirror(TreeNode root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode tmp &#x3D; root.left;</span><br><span class="line">    root.left &#x3D; root.right;</span><br><span class="line">    root.right &#x3D; tmp;</span><br><span class="line">    if (root.left!&#x3D;null)&#123;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root.right!&#x3D;null)&#123;</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><ul><li>定义树节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class TreeNode(val data: Int, var left: TreeNode? &#x3D; null, var right: TreeNode? &#x3D; null)</span><br></pre></td></tr></table></figure></li><li>核心方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * @param root 求一个二叉树的镜像</span><br><span class="line">    *&#x2F;</span><br><span class="line">   fun mirror(root: TreeNode) &#123;</span><br><span class="line"></span><br><span class="line">       if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return</span><br><span class="line">       &#125;</span><br><span class="line">       if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return</span><br><span class="line">       &#125;</span><br><span class="line">       var tmp: TreeNode? &#x3D; root.left</span><br><span class="line">       root.left &#x3D; root.right</span><br><span class="line">       root.right &#x3D; tmp</span><br><span class="line">       while (root.left !&#x3D; null) &#123;</span><br><span class="line">           mirror(root.left!!)</span><br><span class="line">       &#125;</span><br><span class="line">       while (root.right !&#x3D; null) &#123;</span><br><span class="line">           mirror(root.right!!)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://www.nowcoder.com/practice/564f4c2
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】19. 树的子结构</title>
    <link href="https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/19.shu-de-zi-jie-gou/"/>
    <id>https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/19.shu-de-zi-jie-gou/</id>
    <published>2020-05-18T13:40:16.248Z</published>
    <updated>2020-05-18T13:45:07.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>题目来源： <a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&tqId=11170&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github" target="_blank" rel="noopener">Nowcoder</a></li><li>题设： 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>先从跟节点开始判断，若两个根节点的值对应，则继续比较两个节点的左节点和右节点是否都对应；</li><li>若在上一步没有找到，则从左子树开始找；</li><li>若左子树中没有找到，则从右子树开始找；</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><ul><li>定义树节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private class TreeNode &#123;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        public TreeNode(int node) &#123;</span><br><span class="line">            this.val &#x3D; node;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public String toString() &#123;</span><br><span class="line">            return &quot;TreeNode [data&#x3D;&quot; + val + &quot;, left&#x3D;&quot; + left + &quot;, right&#x3D;&quot; + right</span><br><span class="line">                    + &quot;]&quot;;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param root1</span><br><span class="line"> * @param root2</span><br><span class="line"> * @return 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123;</span><br><span class="line"></span><br><span class="line">    boolean result &#x3D; false;</span><br><span class="line">    &#x2F;&#x2F;有一个树是空的，就直接返回false</span><br><span class="line">    if (root1 &#x3D;&#x3D; null || root2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;若找到了Tree2的根节点，则以此根节点为起点判断是不是包含Tree2</span><br><span class="line">    if (root1.val &#x3D;&#x3D; root2.val) &#123;</span><br><span class="line">        result &#x3D; isSubtree(root1, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果不包含，则以root Tree的左子树作为起点判断是否包含Tree2</span><br><span class="line">    if (!result) &#123;</span><br><span class="line">        result &#x3D; HasSubtree(root1.left, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;否则 以root的右子树为起点，判断是否包含Tree2</span><br><span class="line">    if (!result) &#123;</span><br><span class="line">        result &#x3D; HasSubtree(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @param node1</span><br><span class="line"> * @param node2</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean isSubtree(TreeNode node1, TreeNode node2) &#123;</span><br><span class="line">    &#x2F;&#x2F; 如果Tree2已经遍历完了都能对应的上，返回true</span><br><span class="line">    if (node2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果Tree2还没有遍历完，Tree1却遍历完了。返回false</span><br><span class="line">    if (node1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果其中有一个点没有对应上，返回false</span><br><span class="line">    if (node1.val !&#x3D; node2.val) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;如果根节点对应的上，那么就分别去左右子节点里面匹配</span><br><span class="line">    return isSubtree(node1.left, node2.left) &amp;&amp; isSubtree(node1.right, node2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><ul><li>定义树节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class TreeNode(val data: Int, var left: TreeNode? &#x3D; null, var right: TreeNode? &#x3D; null)</span><br></pre></td></tr></table></figure></li><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * @param node1</span><br><span class="line">   * @param node2</span><br><span class="line">   * @return 求 node2 是node1的子树</span><br><span class="line">   *&#x2F;</span><br><span class="line">  fun hasSubtree(node1: TreeNode, node2: TreeNode): Boolean &#123;</span><br><span class="line">      var result &#x3D; false</span><br><span class="line">      &#x2F;&#x2F;有一个树是空的就返回false</span><br><span class="line">      if (node1 &#x3D;&#x3D; null || node2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">          return false</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (node1.data &#x3D;&#x3D; node2.data) &#123;</span><br><span class="line">          result &#x3D; isSubtree(node1, node2)</span><br><span class="line">      &#125;</span><br><span class="line">      if (!result) &#123;</span><br><span class="line">          result &#x3D; hasSubtree(node1.left!!, node2)</span><br><span class="line">      &#125;</span><br><span class="line">      if (!result) &#123;</span><br><span class="line">          result &#x3D; hasSubtree(node1.right!!, node2)</span><br><span class="line">      &#125;</span><br><span class="line">      return result</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fun isSubtree(node1: TreeNode, node2: TreeNode): Boolean &#123;</span><br><span class="line">      if (node2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">          return true</span><br><span class="line">      &#125;</span><br><span class="line">      if (node1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">          return false</span><br><span class="line">      &#125;</span><br><span class="line">      if (node1.data !&#x3D; node2.data) &#123;</span><br><span class="line">          return false</span><br><span class="line">      &#125;</span><br><span class="line">      return isSubtree(node1.left!!, node2.left!!) &amp;&amp; isSubtree(node1.right!!, node2.right!!)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://www.nowcoder.com/practice/6e196c4
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】18. 合并两个排序的链表</title>
    <link href="https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/18.he-bing-liang-ge-pai-xu-de-lian-biao/"/>
    <id>https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/18.he-bing-liang-ge-pai-xu-de-lian-biao/</id>
    <published>2020-05-18T13:40:07.575Z</published>
    <updated>2020-05-18T13:45:25.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>题目来源： <a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&tqId=11169&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github" target="_blank" rel="noopener">Nowcoder</a></li><li>题设： 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>定义一个head节点存储合并后的链表的头结点和一个p节点存储合并后的工作指针；</li><li>将两个链表中较小值的节点指向定义的头结点；并将头结点也指向P节点；</li><li>接下来比较两个链表中将较小值的节点加入到工作节点，并将该结点和工作节点都向后移动一个节点，直到至少有一个链表到尾部；</li><li>最后将没有遍历完的链表添加到工作链表。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><ul><li>首先定义节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static class ListNode &#123;</span><br><span class="line">    private int val;</span><br><span class="line">    private ListNode next;</span><br><span class="line"></span><br><span class="line">    public ListNode(int node) &#123;</span><br><span class="line">        this.val &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * @param list1</span><br><span class="line">     * @param list2</span><br><span class="line">     * @return 合并两个排序的链表</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public ListNode Merge(ListNode list1, ListNode list2) &#123;</span><br><span class="line">        if (list1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return list2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head;&#x2F;&#x2F;存储头结点</span><br><span class="line">        ListNode p;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 取较小值作头结点，并将该链表向后移动一位</span><br><span class="line">        if (list1.val &lt; list2.val) &#123;</span><br><span class="line">            head &#x3D; list1;</span><br><span class="line">            list1 &#x3D; list1.next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            head &#x3D; list2;</span><br><span class="line">            list2 &#x3D; list2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p &#x3D; head;&#x2F;&#x2F;合并后链表的工作节点</span><br><span class="line">        while (list1 !&#x3D; null &amp;&amp; list2 !&#x3D; null) &#123;</span><br><span class="line">            &#x2F;&#x2F;取较小值的节点加入合并节点，并将该节点向后移动一位，工作节点也向后移动一位</span><br><span class="line">            if (list1.val &lt;&#x3D; list2.val) &#123;</span><br><span class="line">                p.next &#x3D; list1;</span><br><span class="line">                list1 &#x3D; list1.next;</span><br><span class="line">                p &#x3D; p.next;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                p.next &#x3D; list2;</span><br><span class="line">                list2 &#x3D; list2.next;</span><br><span class="line">                p &#x3D; p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;未结束的链表连接到合并后的链表尾部</span><br><span class="line">        if (list1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            p.next &#x3D; list2;</span><br><span class="line">        &#125;</span><br><span class="line">        if (list2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">            p.next &#x3D; list1;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><ul><li>定义节点对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data class ListNode(val value: Int,var next: ListNode? &#x3D; null)</span><br></pre></td></tr></table></figure></li><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">fun merge(list1: ListNode?, list2: ListNode?): ListNode? &#123;</span><br><span class="line">       var list1 &#x3D; list1</span><br><span class="line">       var list2 &#x3D; list2</span><br><span class="line">       if (list1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return list2</span><br><span class="line">       &#125;</span><br><span class="line">       if (list2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return list1</span><br><span class="line">       &#125;</span><br><span class="line">       var head: ListNode</span><br><span class="line">       var p: ListNode</span><br><span class="line">       if (list1.value &lt; list2.value) &#123;</span><br><span class="line">           head &#x3D; list1</span><br><span class="line">           list1 &#x3D; list1.next!!</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           head &#x3D; list2</span><br><span class="line">           list2 &#x3D; list2.next!!</span><br><span class="line">       &#125;</span><br><span class="line">       p &#x3D; head</span><br><span class="line">       while (list1 !&#x3D; null &amp;&amp; list2 !&#x3D; null) &#123;</span><br><span class="line">           if (list1.value &lt;&#x3D; list2.value) &#123;</span><br><span class="line">               p.next &#x3D; list1</span><br><span class="line">               list1 &#x3D; list1.next</span><br><span class="line">               p &#x3D; p.next!!</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               p.next &#x3D; list2</span><br><span class="line">               list2 &#x3D; list2.next</span><br><span class="line">               p &#x3D; p.next!!</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (list1 &#x3D;&#x3D; null) &#123;</span><br><span class="line">           p.next &#x3D; list2!!</span><br><span class="line">       &#125;</span><br><span class="line">       if (list2 &#x3D;&#x3D; null) &#123;</span><br><span class="line">           p.next &#x3D; list1!!</span><br><span class="line">       &#125;</span><br><span class="line">       return head</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>构建链表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun buildLinkList1(num: Int): ListNode? &#123;</span><br><span class="line">       var num &#x3D; num</span><br><span class="line">       val head &#x3D; ListNode(0)</span><br><span class="line">       var cur &#x3D; head</span><br><span class="line">       for (i in 1..9) &#123;</span><br><span class="line">           if (i % 2 &#x3D;&#x3D; num) &#123;</span><br><span class="line">               cur.next &#x3D; ListNode(i)</span><br><span class="line">               cur &#x3D; cur.next!!</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return head</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   fun printLinkList() &#123;</span><br><span class="line">       var list1 &#x3D; buildLinkList1(0)</span><br><span class="line">       println(list1)</span><br><span class="line">       var list2 &#x3D; buildLinkList1(1)</span><br><span class="line">       println(list2)</span><br><span class="line">       println(merge(list1,list2))</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>输出结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List1:</span><br><span class="line">ListNode(value&#x3D;0, next&#x3D;ListNode(value&#x3D;2, next&#x3D;ListNode(value&#x3D;4, next&#x3D;ListNode(value&#x3D;6, next&#x3D;ListNode(value&#x3D;8, next&#x3D;null)))))</span><br><span class="line"></span><br><span class="line">List2:</span><br><span class="line">ListNode(value&#x3D;0, next&#x3D;ListNode(value&#x3D;1, next&#x3D;ListNode(value&#x3D;3, next&#x3D;ListNode(value&#x3D;5, next&#x3D;ListNode(value&#x3D;7, next&#x3D;ListNode(value&#x3D;9, next&#x3D;null))))))</span><br><span class="line"></span><br><span class="line">合并后的链表;</span><br><span class="line">ListNode(value&#x3D;0, next&#x3D;ListNode(value&#x3D;0, next&#x3D;ListNode(value&#x3D;1, next&#x3D;ListNode(value&#x3D;2, next&#x3D;ListNode(value&#x3D;3, next&#x3D;ListNode(value&#x3D;4, next&#x3D;ListNode(value&#x3D;5, next&#x3D;ListNode(value&#x3D;6, next&#x3D;ListNode(value&#x3D;7, next&#x3D;ListNode(value&#x3D;8, next&#x3D;ListNode(value&#x3D;9, next&#x3D;null)))))))))))</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://www.nowcoder.com/practice/d8b6b43
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】17. 反转链表，输出新链表的表头</title>
    <link href="https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/17.fan-zhuan-lian-biao-shu-chu-xin-lian-biao-de-biao-tou/"/>
    <id>https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/17.fan-zhuan-lian-biao-shu-chu-xin-lian-biao-de-biao-tou/</id>
    <published>2020-05-18T13:40:03.270Z</published>
    <updated>2020-05-18T13:45:39.937Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>题目来源： <a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&tqId=11168&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github" target="_blank" rel="noopener">Nowcoder</a></li><li>题设：<br>输入一个链表，反转链表后，输出新链表的表头。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>用两个节点（pre，next）分别存储当前节点的前一个节点后后一个节点</li><li>当前节点不为null的时候，循环执行如下操作：<ol><li>用next保存当前节点的下一个节点，目的是不让当前节点反指向其前一个节点后，原来的节点断裂；</li><li>保存了next节点后，就让当前节点从指向next变成指向pre</li><li>当前节点指向pre后，就继续一次反转下一个节点；</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">node1(a) --&gt; node2(b)</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><ul><li>先定义节点对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static class ListNode &#123;</span><br><span class="line">    private int value;</span><br><span class="line">    private ListNode next;</span><br><span class="line"></span><br><span class="line">    public ListNode(int node) &#123;</span><br><span class="line">        this.value &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * @param head</span><br><span class="line">    * @return 反转链表后输出表头</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public ListNode ReverseList(ListNode head) &#123;</span><br><span class="line">       &#x2F;&#x2F;head为当前节点，如果当前节点为空的话，那就什么也不做，直接返回null；</span><br><span class="line">       if (head &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       ListNode pre &#x3D; null;&#x2F;&#x2F;当前节点的前一节点</span><br><span class="line">       ListNode next &#x3D; null;&#x2F;&#x2F;当前节点的下一个节点，为了使当前节点（head）反转指向其前面的节点（pre）后，原来的next节点（head.next）不断裂</span><br><span class="line">       &#x2F;&#x2F;pre-&gt;head-&gt;next1-&gt;next2变成pre&lt;-head next1-&gt;next2</span><br><span class="line">       while (head !&#x3D; null) &#123;&#x2F;&#x2F;循环让当前节点从指向next到指向pre</span><br><span class="line">           next &#x3D; head.next;&#x2F;&#x2F;先用next保存head的下一个节点的信息，保证单链表不会因为失去head节点的原next节点而就此断裂</span><br><span class="line">           head.next &#x3D; pre;&#x2F;&#x2F;保存完next，就可以让head从指向next变成指向pre了，代码如下</span><br><span class="line">           &#x2F;&#x2F;head指向pre后，就继续依次反转下一个节点</span><br><span class="line">           &#x2F;&#x2F;让pre，head，next依次向后移动一个节点，继续下一次的指针反转</span><br><span class="line">           pre &#x3D; head;</span><br><span class="line">           head &#x3D; next;</span><br><span class="line">       &#125;</span><br><span class="line">       return pre;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>构建链表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构建链表</span><br><span class="line"> private ListNode BuildLinkList() &#123;</span><br><span class="line">        ListNode head &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; head;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 10; i++) &#123;</span><br><span class="line">            ListNode tmp &#x3D; new ListNode(i);</span><br><span class="line">            cur.next&#x3D; tmp;</span><br><span class="line">            cur &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void printResult() &#123;</span><br><span class="line">    ListNode head &#x3D; BuildLinkList();</span><br><span class="line">    System.out.println(ReverseList(head));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><ul><li>定义节点对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data class ListNode( val value: Int) &#123;</span><br><span class="line">     var next: ListNode? &#x3D; null</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun reverseList(head: ListNode?): ListNode? &#123;</span><br><span class="line">       var head: ListNode? &#x3D; head ?: return null</span><br><span class="line">       var pre: ListNode? &#x3D; null</span><br><span class="line">       var next: ListNode? &#x3D; null</span><br><span class="line">       while (head !&#x3D; null) &#123;</span><br><span class="line">           next &#x3D; head.next</span><br><span class="line"></span><br><span class="line">           head.next &#x3D; pre</span><br><span class="line"></span><br><span class="line">           pre &#x3D; head</span><br><span class="line">           head &#x3D; next!!</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return pre</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>构建测试链表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private fun buildLinkList(): ListNode? &#123;</span><br><span class="line">       val head &#x3D; ListNode(0)</span><br><span class="line">       var cur &#x3D; head</span><br><span class="line">       for (i in 1..9) &#123;</span><br><span class="line">           val tmp &#x3D; ListNode(i)</span><br><span class="line">           cur.next &#x3D; tmp</span><br><span class="line">           cur &#x3D; tmp</span><br><span class="line">       &#125;</span><br><span class="line">       return head</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line"> fun printResult() &#123;</span><br><span class="line">     print(reverseList(buildLinkList()))</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F;结果：ListNode(value&#x3D;9)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://www.nowcoder.com/practice/75e878d
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】16. 链表中倒数第k个节点</title>
    <link href="https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/16.lian-biao-zhong-dao-shu-di-k-ge-jie-dian/"/>
    <id>https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/16.lian-biao-zhong-dao-shu-di-k-ge-jie-dian/</id>
    <published>2020-05-18T13:39:55.711Z</published>
    <updated>2020-05-18T13:45:52.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>题目来源： <a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&tqId=11167&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github" target="_blank" rel="noopener">Nowcoder</a></li><li>题设： 输入一个链表，输出该链表中倒数第k个结点。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>定义两个指针（fast，slow）分别都指向头节点；</li><li>当fast指针走到k的位置时，slow指针开始走；</li><li>当fast指针走到最后时，当前slow所指指针就是的倒数第k个节点；</li><li>当链表的节点数小于k时，则返回null。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><ul><li>先定义节点对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static class ListNode &#123;</span><br><span class="line">    private int value;</span><br><span class="line">    private ListNode next;</span><br><span class="line"></span><br><span class="line">    public ListNode(int node) &#123;</span><br><span class="line">        this.value &#x3D; node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * @param head</span><br><span class="line"> * @param k</span><br><span class="line"> * @return 链表中倒数第k个结点</span><br><span class="line"> *&#x2F;</span><br><span class="line">public ListNode FindKthToTail(ListNode head, int k) &#123;</span><br><span class="line">    &#x2F;&#x2F;定义两个指针都指向头结点</span><br><span class="line">    ListNode fast,slow;</span><br><span class="line">    fast &#x3D; slow &#x3D; head;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    for (; fast!&#x3D;null; i++) &#123;</span><br><span class="line">        fast &#x3D; fast.next;</span><br><span class="line">        if (i&gt;&#x3D;k)&#123;&#x2F;&#x2F;当fast走到k位置时</span><br><span class="line">            slow &#x3D; slow.next;&#x2F;&#x2F;slow也开始走</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return i&lt;k?null:slow;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>构建链表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;构建链表</span><br><span class="line"> private ListNode BuildLinkList() &#123;</span><br><span class="line">        ListNode head &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; head;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 10; i++) &#123;</span><br><span class="line">            ListNode tmp &#x3D; new ListNode(i);</span><br><span class="line">            cur.next&#x3D; tmp;</span><br><span class="line">            cur &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void printResult() &#123;</span><br><span class="line">    ListNode head &#x3D; BuildLinkList();</span><br><span class="line">    System.out.println(FindKthToTail(head,2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><ul><li>定义节点对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data class ListNode( val value: Int) &#123;</span><br><span class="line">     var next: ListNode? &#x3D; null</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fun findKthToTail(head: ListNode?, k: Int): ListNode? &#123;</span><br><span class="line">       var fast &#x3D; head</span><br><span class="line">       var slow &#x3D; head</span><br><span class="line">       var count: Int &#x3D; 0;</span><br><span class="line">       while (fast !&#x3D; null) &#123;</span><br><span class="line">           fast &#x3D; fast.next</span><br><span class="line">           if (count &gt;&#x3D; k) &#123; &#x2F;&#x2F;当fast走到k位置时</span><br><span class="line">               slow &#x3D; slow?.next &#x2F;&#x2F;slow也开始走</span><br><span class="line">           &#125;</span><br><span class="line">           count++</span><br><span class="line">       &#125;</span><br><span class="line">       return if (count &lt; k) null else slow</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>构建测试链表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private fun buildLinkList(): ListNode? &#123;</span><br><span class="line">       val head &#x3D; ListNode(0)</span><br><span class="line">       var cur &#x3D; head</span><br><span class="line">       for (i in 1..9) &#123;</span><br><span class="line">           val tmp &#x3D; ListNode(i)</span><br><span class="line">           cur.next &#x3D; tmp</span><br><span class="line">           cur &#x3D; tmp</span><br><span class="line">       &#125;</span><br><span class="line">       return head</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>测试<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   fun printResult() &#123;</span><br><span class="line">       print(findKthToTail(buildLinkList(), 6))</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;打印结果：ListNode(value&#x3D;4)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://www.nowcoder.com/practice/529d3ae
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="-链表" scheme="https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】15. 调整数组顺序使奇数位于偶数前面</title>
    <link href="https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/15.diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian/"/>
    <id>https://eriecorner.github.io/2020/05/18/suan-fa/jian-zhi-offer/15.diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian/</id>
    <published>2020-05-18T13:39:44.259Z</published>
    <updated>2020-05-18T13:45:57.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>题目来源： <a href="https://www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593?tpId=13&tqId=11166&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github" target="_blank" rel="noopener">Nowcoder</a></li><li>题设： 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>要使奇数偶数的相对位置不变，则需将相邻的两个偶数和奇数交换位置；</li><li>若当前位置的数是偶数，其后面的数是奇数，则这两个数交换位置，循环遍历，则一次遍历结束，最右边沉淀一位偶数。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * @param array 调整数组顺序使奇数位于偶数前面</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public void reOrderArray(int[] array) &#123;</span><br><span class="line">       if (array !&#x3D; null &amp;&amp; array.length &gt; 0) &#123;</span><br><span class="line">           for (int i &#x3D; 0; i &lt; array.length; i++) &#123;</span><br><span class="line">               for (int j &#x3D; 0; j &lt; array.length-1-i; j++) &#123;</span><br><span class="line">                   if(array[j]%2&#x3D;&#x3D;0&amp;&amp;array[j+1]%2&#x3D;&#x3D;1)&#123;&#x2F;&#x2F;前偶后奇交换</span><br><span class="line">                       int t &#x3D; array[j];</span><br><span class="line">                       array[j]&#x3D;array[j+1];</span><br><span class="line">                       array[j+1]&#x3D;t;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">     * @param array 调整数组顺序使奇数位于偶数前面</span><br><span class="line">     *&#x2F;</span><br><span class="line">fun reOrderArray(array:ArrayList&lt;Int&gt;)&#123;</span><br><span class="line">        if (array!&#x3D;null&amp;&amp;array.size&gt;0)&#123;</span><br><span class="line">            for (i in 0 until array.size)&#123;</span><br><span class="line">                for (j in 0 until (array.size-1-i))&#123;</span><br><span class="line">                    if (array[j]%2&#x3D;&#x3D;0&amp;&amp;array[j+1]%2&#x3D;&#x3D;1)&#123;</span><br><span class="line">                        var temp &#x3D; array[j]</span><br><span class="line">                        array[j] &#x3D; array[j+1]</span><br><span class="line">                        array[j+1] &#x3D; temp</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://www.nowcoder.com/practice/beb5aa2
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码解析（Kotlin版）</title>
    <link href="https://eriecorner.github.io/2020/05/17/san-fang-kuang-jia-yuan-ma-jie-xi/okhttp-kotlin-ban-yuan-ma-jie-xi/"/>
    <id>https://eriecorner.github.io/2020/05/17/san-fang-kuang-jia-yuan-ma-jie-xi/okhttp-kotlin-ban-yuan-ma-jie-xi/</id>
    <published>2020-05-17T13:34:27.475Z</published>
    <updated>2020-05-18T13:26:55.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OkHttp 是一款非常优秀的网络请求框架，随着Kotlin语言的不断完善，OkHttp 自 4.0 版本开始使用Kotlin编写，对于巩固Kotlin语法知识及实践，研读OkHttp 4.0及以上版本的源码是一个不错的选择。</p><p>首先列出一些前置知识点：</p><ol><li><a href="https://www.kotlincn.net/docs/reference/android-overview.html" target="_blank" rel="noopener">Kotlin基础知识</a></li><li><a href="https://developer.android.google.cn/kotlin/learn" target="_blank" rel="noopener">Kotlin学习平台</a></li><li><a href="https://www.cnblogs.com/xiaomage666/p/11918864.html" target="_blank" rel="noopener">网络请求响应码含义</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx：信息，请求收到，继续处理</span><br><span class="line">2xx：成功，行为被成功地接受、理解和采纳</span><br><span class="line">3xx：重定向，为了完成请求，必须进一步执行的动作</span><br><span class="line">4xx：客户端错误，请求包含语法错误或者请求无法实现</span><br><span class="line">5xx：服务器错误，服务器不能实现一种明显无效的请求</span><br></pre></td></tr></table></figure></li><li><a href="https://www.cnblogs.com/ranyonsue/p/8918908.html" target="_blank" rel="noopener">Http缓存机制</a></li></ol><h2 id="OkHttp的基本使用"><a href="#OkHttp的基本使用" class="headerlink" title="OkHttp的基本使用"></a>OkHttp的基本使用</h2><ul><li>首先添加依赖库（去官网找最新的或想要的版本）</li><li>Http 请求有多种类型，常用的分为 Get 和 Post，而 POST 又分为 Form 和 Multiple 等，下面我们以Get请求为例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.创建OkHttpClient 对象，</span><br><span class="line">&#x2F;&#x2F; var client &#x3D; OkHttpClient();&#x2F;&#x2F;方式一</span><br><span class="line"> &#x2F;&#x2F;方式二：</span><br><span class="line"> val client &#x3D; OkHttpClient.Builder().readTimeout(5, TimeUnit.SECONDS).build()</span><br><span class="line"> &#x2F;&#x2F;2.创建请求对象并添加请求参数信息</span><br><span class="line"> val request &#x3D; Request.Builder().url(&quot;&quot;).build()</span><br><span class="line"> &#x2F;&#x2F;3.构建进行请求操作的call对象</span><br><span class="line"> val call &#x3D; client.newCall(request)</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;同步请求 Call （RealCall）—&gt;execute() 返回response</span><br><span class="line"> &#x2F;&#x2F; val response &#x3D; client.newCall(request).execute()</span><br><span class="line"> &#x2F;&#x2F;异步请求 Call （RealCall）—&gt;enqueue()</span><br><span class="line"> call.enqueue(</span><br><span class="line">         object : Callback &#123;</span><br><span class="line">             override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line">                 println(e.stackTrace.toString())</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             @Throws(IOException::class)</span><br><span class="line">             override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">                 println(response.body.toString())</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;)</span><br></pre></td></tr></table></figure></li><li>首先使用OkHttpClint的构造<code>OkHttpClient()</code>或者Build模式构建一个OkHttpClint的对象实例；</li><li>使用构建者模式构建一个Request对象，通过OkHttpClient和Request对象，构建出Call对象；</li><li>执行call的<code>enqueue()</code>或者<code>execute()</code>。</li></ul><p><strong>注意</strong>：在实际开发中建议将OkHttpClint对象的创建封装成单列， 因为每个 OkHttpClient 对象都管理自己独有的线程池和连接池，复用连接池和线程池能够减少延迟、节省内存。</p><h2 id="OkHttp-源码分析"><a href="#OkHttp-源码分析" class="headerlink" title="OkHttp 源码分析"></a>OkHttp 源码分析</h2><h4 id="一-OkHttpClient"><a href="#一-OkHttpClient" class="headerlink" title="一. OkHttpClient"></a>一. OkHttpClient</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">constructor() : this(Builder())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里是默认的参数设置</span><br><span class="line">class Builder constructor() &#123;</span><br><span class="line">   internal var dispatcher: Dispatcher &#x3D; Dispatcher()&#x2F;&#x2F;调度器，通过双端队列保存Calls（同步&amp;异步Call）</span><br><span class="line">   internal var connectionPool: ConnectionPool &#x3D; ConnectionPool()&#x2F;&#x2F;链接池</span><br><span class="line">   internal val interceptors: MutableList&lt;Interceptor&gt; &#x3D; mutableListOf()&#x2F;&#x2F;拦截器</span><br><span class="line">   internal val networkInterceptors: MutableList&lt;Interceptor&gt; &#x3D; mutableListOf()&#x2F;&#x2F;网络拦截器</span><br><span class="line">   internal var eventListenerFactory: EventListener.Factory &#x3D; EventListener.NONE.asFactory()&#x2F;&#x2F;一个Call的状态监听器</span><br><span class="line">   internal var retryOnConnectionFailure &#x3D; true</span><br><span class="line">   internal var authenticator: Authenticator &#x3D; Authenticator.NONE</span><br><span class="line">   internal var followRedirects &#x3D; true</span><br><span class="line">   internal var followSslRedirects &#x3D; true</span><br><span class="line">   internal var cookieJar: CookieJar &#x3D; CookieJar.NO_COOKIES&#x2F;&#x2F;默认没有Cookie</span><br><span class="line">   internal var cache: Cache? &#x3D; null</span><br><span class="line">   internal var dns: Dns &#x3D; Dns.SYSTEM&#x2F;&#x2F;域名解析系统 domain name -&gt; ip address</span><br><span class="line">   internal var proxy: Proxy? &#x3D; null</span><br><span class="line">   internal var proxySelector: ProxySelector? &#x3D; null&#x2F;&#x2F;使用默认的代理选择器</span><br><span class="line">   internal var proxyAuthenticator: Authenticator &#x3D; Authenticator.NONE</span><br><span class="line">   internal var socketFactory: SocketFactory &#x3D; SocketFactory.getDefault()&#x2F;&#x2F;默认的Socket 工厂生产Socket </span><br><span class="line">   internal var sslSocketFactoryOrNull: SSLSocketFactory? &#x3D; null</span><br><span class="line">   internal var x509TrustManagerOrNull: X509TrustManager? &#x3D; null</span><br><span class="line">   internal var connectionSpecs: List&lt;ConnectionSpec&gt; &#x3D; DEFAULT_CONNECTION_SPECS&#x2F;&#x2F;OKHttp连接（Connection）配置</span><br><span class="line">   internal var protocols: List&lt;Protocol&gt; &#x3D; DEFAULT_PROTOCOLS</span><br><span class="line">   internal var hostnameVerifier: HostnameVerifier &#x3D; OkHostnameVerifier</span><br><span class="line">   internal var certificatePinner: CertificatePinner &#x3D; CertificatePinner.DEFAULT</span><br><span class="line">   internal var certificateChainCleaner: CertificateChainCleaner? &#x3D; null</span><br><span class="line">   internal var callTimeout &#x3D; 0</span><br><span class="line">   internal var connectTimeout &#x3D; 10_000</span><br><span class="line">   internal var readTimeout &#x3D; 10_000</span><br><span class="line">   internal var writeTimeout &#x3D; 10_000</span><br><span class="line">   internal var pingInterval &#x3D; 0&#x2F;&#x2F;和WebSocket有关,为了保持长连接，我们必须间隔一段时间发送一个ping指令进行保活</span><br><span class="line">   internal var minWebSocketMessageToCompress &#x3D; RealWebSocket.DEFAULT_MINIMUM_DEFLATE_SIZE</span><br><span class="line">   internal var routeDatabase: RouteDatabase? &#x3D; null</span><br></pre></td></tr></table></figure><p><strong>connectionSpecs：</strong>   OKHttp连接（Connection）配置 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">companion object &#123;</span><br><span class="line">    internal val DEFAULT_PROTOCOLS &#x3D; immutableListOf(HTTP_2, HTTP_1_1)</span><br><span class="line"></span><br><span class="line">    internal val DEFAULT_CONNECTION_SPECS &#x3D; immutableListOf(</span><br><span class="line">        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT)</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;**</span><br><span class="line">     * A modern TLS configuration that works on most client platforms and can connect to most servers.</span><br><span class="line">     * This is OkHttp&#39;s default configuration.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;针对TLS的， 是OkHttp 的默认配置</span><br><span class="line">   @JvmField</span><br><span class="line">    val MODERN_TLS &#x3D; Builder(true)</span><br><span class="line">        .cipherSuites(*APPROVED_CIPHER_SUITES)</span><br><span class="line">        .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)</span><br><span class="line">        .supportsTlsExtensions(true)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#x2F;** URL的未经加密，未经身份验证的连接 *&#x2F;</span><br><span class="line">    @JvmField</span><br><span class="line">    val CLEARTEXT &#x3D; Builder(false).build()</span><br></pre></td></tr></table></figure><h4 id="二-同步请求流程分析"><a href="#二-同步请求流程分析" class="headerlink" title="二. 同步请求流程分析"></a>二. 同步请求流程分析</h4><p>以下代码为同步请求流程中的核心代码，按照调用次序呈现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;  1.</span><br><span class="line">  val response &#x3D; client.newCall(request).execute()</span><br><span class="line">  &#x2F;&#x2F;  2.</span><br><span class="line">   &#x2F;** Prepares the [request] to be executed at some point in the future. *&#x2F;</span><br><span class="line">  override fun newCall(request: Request): Call &#x3D; RealCall(this, request, forWebSocket &#x3D; false)</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;RealCall的execute()</span><br><span class="line">  &#x2F;&#x2F;  3. 真正执行请求的是在call的实现类 RealCall的execute()中</span><br><span class="line">   override fun execute(): Response &#123;</span><br><span class="line">   &#x2F;&#x2F;标记请求执行状态：一个请求只能执行一次</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">      executed &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">    timeout.enter()</span><br><span class="line">    callStart()</span><br><span class="line">    try &#123;</span><br><span class="line">     &#x2F;&#x2F; 4. 通知dispatcher已经进入执行状态</span><br><span class="line">      client.dispatcher.executed(this)</span><br><span class="line">      &#x2F;&#x2F; 5. 通过连接器的链式调用进行请求处理并返回最终响应结果</span><br><span class="line">      return getResponseWithInterceptorChain()</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; 6. 通知dispatcher自己已执行完毕</span><br><span class="line">      client.dispatcher.finished(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   &#x2F;&#x2F;4 . dispatcher.executed()</span><br><span class="line">  &#x2F;** Used by &#96;Call#execute&#96; to signal it is in-flight. *&#x2F;</span><br><span class="line">  @Synchronized internal fun executed(call: RealCall) &#123;</span><br><span class="line">    runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;Dispatcher中维护的ArrayDeque</span><br><span class="line">   &#x2F;** 准备执行的异步请求队列. *&#x2F;</span><br><span class="line">  private val readyAsyncCalls &#x3D; ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line">  &#x2F;** 正在执行的异步请求队列 *&#x2F;</span><br><span class="line">  private val runningAsyncCalls &#x3D; ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line">  &#x2F;** 正在执行的同步请求队列 *&#x2F;</span><br><span class="line">  private val runningSyncCalls &#x3D; ArrayDeque&lt;RealCall&gt;()</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;5 .RealCall的getResponseWithInterceptorChain()</span><br><span class="line">  @Throws(IOException::class)</span><br><span class="line">  internal fun getResponseWithInterceptorChain(): Response &#123;</span><br><span class="line">    &#x2F;&#x2F; Build a full stack of interceptors.</span><br><span class="line">    val interceptors &#x3D; mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors +&#x3D; client.interceptors&#x2F;&#x2F;用户在构建OkHttpClient是配置的连接器</span><br><span class="line">    interceptors +&#x3D; RetryAndFollowUpInterceptor(client)&#x2F;&#x2F;负责请求失败后的重试和重定向</span><br><span class="line">    interceptors +&#x3D; BridgeInterceptor(client.cookieJar)&#x2F;&#x2F;对请求和响应的参数进行必要的处理</span><br><span class="line">    interceptors +&#x3D; CacheInterceptor(client.cache)&#x2F;&#x2F;读取缓存数据返回、更新缓存</span><br><span class="line">    interceptors +&#x3D; ConnectInterceptor&#x2F;&#x2F;负责跟服务器的链接操作</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">    &#x2F;&#x2F;创建OkHttpClient时设置的networkInterceptor</span><br><span class="line">      interceptors +&#x3D; client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;向服务器发送请求数据，读取响应数据</span><br><span class="line">    interceptors +&#x3D; CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;将请求对象及OkHttpClient的一些配置封装在RealInterceptorChain中</span><br><span class="line">    val chain &#x3D; RealInterceptorChain(</span><br><span class="line">        call &#x3D; this,</span><br><span class="line">        interceptors &#x3D; interceptors,</span><br><span class="line">        index &#x3D; 0,</span><br><span class="line">        exchange &#x3D; null,</span><br><span class="line">        request &#x3D; originalRequest,</span><br><span class="line">        connectTimeoutMillis &#x3D; client.connectTimeoutMillis,</span><br><span class="line">        readTimeoutMillis &#x3D; client.readTimeoutMillis,</span><br><span class="line">        writeTimeoutMillis &#x3D; client.writeTimeoutMillis</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    var calledNoMoreExchanges &#x3D; false</span><br><span class="line">    try &#123;</span><br><span class="line">    &#x2F;&#x2F;开启链式调用</span><br><span class="line">      val response &#x3D; chain.proceed(originalRequest)</span><br><span class="line">      if (isCanceled()) &#123;</span><br><span class="line">        response.closeQuietly()</span><br><span class="line">        throw IOException(&quot;Canceled&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      return response</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      calledNoMoreExchanges &#x3D; true</span><br><span class="line">      throw noMoreExchanges(e) as Throwable</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (!calledNoMoreExchanges) &#123;</span><br><span class="line">        noMoreExchanges(null)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;7. RealInterceptorChain的proceed()</span><br><span class="line">@Throws(IOException::class)</span><br><span class="line">  override fun proceed(request: Request): Response &#123;</span><br><span class="line">    check(index &lt; interceptors.size)</span><br><span class="line"></span><br><span class="line">    calls++</span><br><span class="line"></span><br><span class="line">    if (exchange !&#x3D; null) &#123;</span><br><span class="line">      check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class="line">        &quot;network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      check(calls &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &quot;network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call the next interceptor in the chain. 实例化下一个拦截器</span><br><span class="line">    val next &#x3D; copy(index &#x3D; index + 1, request &#x3D; request)</span><br><span class="line">    &#x2F;&#x2F;获取当前拦截器</span><br><span class="line">    val interceptor &#x3D; interceptors[index]</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调用当前拦截器的intercept(),并将下一个拦截器的RealIterceptorChain对象传递下去,最后返回响应结果</span><br><span class="line">    @Suppress(&quot;USELESS_ELVIS&quot;)</span><br><span class="line">    val response &#x3D; interceptor.intercept(next) ?: throw NullPointerException(</span><br><span class="line">        &quot;interceptor $interceptor returned null&quot;)</span><br><span class="line"></span><br><span class="line">    if (exchange !&#x3D; null) &#123;</span><br><span class="line">      check(index + 1 &gt;&#x3D; interceptors.size || next.calls &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &quot;network interceptor $interceptor must call proceed() exactly once&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check(response.body !&#x3D; null) &#123; &quot;interceptor $interceptor returned a response with no body&quot; &#125;</span><br><span class="line"></span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="三-异步请求流程分析"><a href="#三-异步请求流程分析" class="headerlink" title="三. 异步请求流程分析"></a>三. 异步请求流程分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;1. 异步请求 Call （RealCall）—&gt;enqueue()</span><br><span class="line">    client.newCall(request).enqueue(</span><br><span class="line">       object : Callback &#123;</span><br><span class="line">       override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line">            println(e.stackTrace.toString())</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">          @Throws(IOException::class)</span><br><span class="line">             override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">               println(response.body.toString())</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">               </span><br><span class="line">    &#x2F;&#x2F;2. RealCall 的enqueue()     </span><br><span class="line">   override fun enqueue(responseCallback: Callback) &#123;</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">     check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">     executed &#x3D; true</span><br><span class="line">   &#125;</span><br><span class="line">   callStart()</span><br><span class="line">   client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line"> &#125;   </span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;3. dispatcher 的enqueue()</span><br><span class="line"> internal fun enqueue(call: AsyncCall) &#123;</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">   &#x2F;&#x2F;将请求添加到等待执行的异步请求队列中</span><br><span class="line">     readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span><br><span class="line">     &#x2F;&#x2F; the same host.</span><br><span class="line">     if (!call.call.forWebSocket) &#123;</span><br><span class="line">       val existingCall &#x3D; findExistingCallWithHost(call.host)</span><br><span class="line">       if (existingCall !&#x3D; null) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   promoteAndExecute()</span><br><span class="line"> &#125;         </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">  * Promotes eligible calls from [readyAsyncCalls] to [runningAsyncCalls] and runs them on the</span><br><span class="line">  * executor service. Must not be called with synchronization because executing calls can call</span><br><span class="line">  * into user code.</span><br><span class="line">  *</span><br><span class="line">  * @return true if the dispatcher is currently running calls.</span><br><span class="line">  *&#x2F;</span><br><span class="line">  &#x2F;&#x2F;4. 不断从readyAsyncCalls中取出要执行的请求放到runningAsyncCalls中，并将readyAsyncCalls中的移除</span><br><span class="line"> private fun promoteAndExecute(): Boolean &#123;</span><br><span class="line">   this.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">   val executableCalls &#x3D; mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">   val isRunning: Boolean</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">     val i &#x3D; readyAsyncCalls.iterator()</span><br><span class="line">     while (i.hasNext()) &#123;</span><br><span class="line">       val asyncCall &#x3D; i.next()</span><br><span class="line">       </span><br><span class="line">    &#x2F;&#x2F; 如果其中的runningAsynCalls不满，且call占用的host小于最大数量，则将call加入到runningAsyncCalls中执行，</span><br><span class="line">  </span><br><span class="line">       if (runningAsyncCalls.size &gt;&#x3D; this.maxRequests) break &#x2F;&#x2F; Max capacity.</span><br><span class="line">       if (asyncCall.callsPerHost.get() &gt;&#x3D; this.maxRequestsPerHost) continue &#x2F;&#x2F; Host max capacity.</span><br><span class="line"></span><br><span class="line">       i.remove()</span><br><span class="line">       asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">       executableCalls.add(asyncCall)</span><br><span class="line">       runningAsyncCalls.add(asyncCall)</span><br><span class="line">     &#125;</span><br><span class="line">     isRunning &#x3D; runningCallsCount() &gt; 0</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (i in 0 until executableCalls.size) &#123;</span><br><span class="line">     val asyncCall &#x3D; executableCalls[i]</span><br><span class="line">      &#x2F;&#x2F; 利用线程池执行call</span><br><span class="line">     asyncCall.executeOn(executorService)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return isRunning</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>异步请求的dispatcher.enqueue(AsyncCall)中传入是call 是一个AsyncCall，接下来看AsyncCall的实现.它是RealCall的内部类，实际是一个Runnable。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">internal inner class AsyncCall(</span><br><span class="line">  private val responseCallback: Callback</span><br><span class="line">) : Runnable &#123;</span><br><span class="line">  @Volatile var callsPerHost &#x3D; AtomicInteger(0)</span><br><span class="line">    private set</span><br><span class="line"></span><br><span class="line">  fun reuseCallsPerHostFrom(other: AsyncCall) &#123;</span><br><span class="line">    this.callsPerHost &#x3D; other.callsPerHost</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val host: String</span><br><span class="line">    get() &#x3D; originalRequest.url.host</span><br><span class="line"></span><br><span class="line">  val request: Request</span><br><span class="line">      get() &#x3D; originalRequest</span><br><span class="line"></span><br><span class="line">  val call: RealCall</span><br><span class="line">      get() &#x3D; this@RealCall</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Attempt to enqueue this async call on [executorService]. This will attempt to clean up</span><br><span class="line">   * if the executor has been shut down by reporting the call as failed.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  fun executeOn(executorService: ExecutorService) &#123;</span><br><span class="line">    client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    var success &#x3D; false</span><br><span class="line">    try &#123;</span><br><span class="line">    &#x2F;&#x2F;在线程迟中执行</span><br><span class="line">      executorService.execute(this)</span><br><span class="line">      success &#x3D; true</span><br><span class="line">    &#125; catch (e: RejectedExecutionException) &#123;</span><br><span class="line">      val ioException &#x3D; InterruptedIOException(&quot;executor rejected&quot;)</span><br><span class="line">      ioException.initCause(e)</span><br><span class="line">      noMoreExchanges(ioException)</span><br><span class="line">      responseCallback.onFailure(this@RealCall, ioException)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (!success) &#123;</span><br><span class="line">        client.dispatcher.finished(this) &#x2F;&#x2F; This call is no longer running!</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun run() &#123;</span><br><span class="line">    threadName(&quot;OkHttp $&#123;redactedUrl()&#125;&quot;) &#123;</span><br><span class="line">      var signalledCallback &#x3D; false</span><br><span class="line">      timeout.enter()</span><br><span class="line">      try &#123;</span><br><span class="line">      &#x2F;&#x2F;最终进行拦截器的链式调用来处理请求并返回最终的响应结果</span><br><span class="line">        val response &#x3D; getResponseWithInterceptorChain()</span><br><span class="line">        signalledCallback &#x3D; true</span><br><span class="line">        responseCallback.onResponse(this@RealCall, response)</span><br><span class="line">      &#125; catch (e: IOException) &#123;</span><br><span class="line">        if (signalledCallback) &#123;</span><br><span class="line">          &#x2F;&#x2F; Do not signal the callback twice!</span><br><span class="line">          Platform.get().log(&quot;Callback failure for $&#123;toLoggableString()&#125;&quot;, Platform.INFO, e)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          responseCallback.onFailure(this@RealCall, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (t: Throwable) &#123;</span><br><span class="line">        cancel()</span><br><span class="line">        if (!signalledCallback) &#123;</span><br><span class="line">          val canceledException &#x3D; IOException(&quot;canceled due to $t&quot;)</span><br><span class="line">          canceledException.addSuppressed(t)</span><br><span class="line">          responseCallback.onFailure(this@RealCall, canceledException)</span><br><span class="line">        &#125;</span><br><span class="line">        throw t</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher.finished(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过源码看到Dispatcher维护了三个ArrayDeque，一个保存了正在执行的同步任务；一个保存异步正在执行的请求，另一个是异步等待执行的请求，异步右两个ArrayDeque是因为Dispatcher默认支持最大的并发请求是64个，单个Host最多执行5个并发请求，如果超过，则Call会先被放入到readyAsyncCall中，当出现空闲的线程时，再将readyAsyncCall中的线程移入到runningAsynCalls中，执行请求。</p></li><li><p>通过拦截器链处理，得到响应结果后执行finally中的代码<code>dispatcher.finished(this)</code>，<br>现在来看下这个方法，走到这，一个请求流程就结束了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Used by [AsyncCall.run] to signal completion. *&#x2F;</span><br><span class="line">&#x2F;&#x2F;异步请求时调用</span><br><span class="line"> internal fun finished(call: AsyncCall) &#123;</span><br><span class="line">   call.callsPerHost.decrementAndGet()</span><br><span class="line">   finished(runningAsyncCalls, call)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;** Used by [Call.execute] to signal completion. *&#x2F;</span><br><span class="line"> &#x2F;&#x2F;同步请求时调用</span><br><span class="line"> internal fun finished(call: RealCall) &#123;</span><br><span class="line">   finished(runningSyncCalls, call)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F;最终都调用这个方法</span><br><span class="line"> private fun &lt;T&gt; finished(calls: Deque&lt;T&gt;, call: T) &#123;</span><br><span class="line">   val idleCallback: Runnable?</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">   &#x2F;&#x2F;将当前call从其队列中移除</span><br><span class="line">     if (!calls.remove(call)) throw AssertionError(&quot;Call wasn&#39;t in-flight!&quot;)</span><br><span class="line">     idleCallback &#x3D; this.idleCallback</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   val isRunning &#x3D; promoteAndExecute()</span><br><span class="line"></span><br><span class="line">   if (!isRunning &amp;&amp; idleCallback !&#x3D; null) &#123;</span><br><span class="line">     idleCallback.run()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>总结</strong>：网络请求是从<code>OkHttpClient().newCall(request)</code>开始的，通过创建的OkHttpClient对象和Request对象，构建出一个RealCall对象来执行网络请求，同步请求是在<code>RealCall</code>的<code>execute()</code>方法中，异步请求是在<code>enqueue()</code>中，在这两个方法中都用<code>OkHttpClient</code>对象的<code>dispatcher</code>执行对应的请求方法。对于同步请求，<code>dispatcher</code>的<code>execute()</code>就是将请求加入到<code>runningSyncCalls</code>这个双端队列中；对于异步请求，<code>dispatcher</code>进行请求的分发执行。在<code>dispatcher</code>将请求分发后调用<code>getResponseWithInterceptorChain()</code>方法，在这里，==依次==将<code>client.interceptorsRetryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor、ConnectInterceptor、client.networkInterceptors和CallServerInterceptor</code>添加到一个集合中，并创建出一个拦截器链<code>RealInterceptorChain</code>，通过<code>RealInterceptorChain.proceed()</code>使每一个拦截器执行完毕之后会调用下一个拦截器或者不调用并返回结果。显然，我们最终拿到的响应就是这个链条执行之后返回的结果。</p><ul><li>整体的请求流程图如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgkr.cn-bj.ufileos.com/3b02ef84-73e7-45e1-8d74-109685d48deb.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h4 id="四-OkHttp内置拦截器源码分析"><a href="#四-OkHttp内置拦截器源码分析" class="headerlink" title="四.OkHttp内置拦截器源码分析"></a>四.OkHttp内置拦截器源码分析</h4><h4 id="1-RetryAndFollowUpInterceptor"><a href="#1-RetryAndFollowUpInterceptor" class="headerlink" title="1. RetryAndFollowUpInterceptor"></a>1. RetryAndFollowUpInterceptor</h4><p>这个拦截器负责重试和重定向，当一个请求由于各种原因失败了，如果是路由或者连接异常，则尝试恢复，否则，根据响应码（ResponseCode）,followup方法会对Request进行再处理以得到新的Request，然后沿着拦截器链继续新的Request；当尝试次数超过最大次数就抛出异常。代码逻辑相对比较简单，这里就不贴出来了。</p><h4 id="2-BridgeInterceptor"><a href="#2-BridgeInterceptor" class="headerlink" title="2. BridgeInterceptor"></a>2. BridgeInterceptor</h4><p>负责将用户请求转换为网络请求，也就是根据 Request 信息组建请求 Header 以及设置响应数据，包括设置 Cookie 以及gzip。源码就不贴出来了。</p><h4 id="3-CacheInterceptor"><a href="#3-CacheInterceptor" class="headerlink" title="3. CacheInterceptor"></a>3. CacheInterceptor</h4><p>负责根据请求的信息和缓存的响应的信息来判断是否存在可用的缓存，读取缓存直接返回、否则就继续使用责任链模式来从服务器中获取响应。当获取到响应的时候，更新缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">@Throws(IOException::class)</span><br><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line"> &#x2F;&#x2F;从缓存中获取</span><br><span class="line">  val cacheCandidate &#x3D; cache?.get(chain.request())</span><br><span class="line"></span><br><span class="line">  val now &#x3D; System.currentTimeMillis()</span><br><span class="line"> &#x2F;&#x2F;缓存策略，决定使用缓存还是从网络获取</span><br><span class="line">  val strategy &#x3D; CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">  val networkRequest &#x3D; strategy.networkRequest</span><br><span class="line">  val cacheResponse &#x3D; strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;根据缓存策略，更新统计指标：请求次数、使用网络请求次数、使用缓存次数</span><br><span class="line">  cache?.trackResponse(strategy)</span><br><span class="line">   &#x2F;&#x2F;若缓存不可用，关闭</span><br><span class="line">  if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it.</span><br><span class="line">    cacheCandidate.body?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If we&#39;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">  &#x2F;&#x2F;如果既无网络请求可用，又没有缓存，则返回504错误</span><br><span class="line">  if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">        .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">        .body(EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-1L)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If we don&#39;t need the network, we&#39;re done.</span><br><span class="line">  &#x2F;&#x2F;缓存可用，则返回缓存中数据</span><br><span class="line">  if (networkRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return cacheResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var networkResponse: Response? &#x3D; null</span><br><span class="line">  try &#123;</span><br><span class="line">  &#x2F;&#x2F;进行网络请求，返回请求结果</span><br><span class="line">    networkResponse &#x3D; chain.proceed(networkRequest)</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; If we&#39;re crashing on I&#x2F;O or otherwise, don&#39;t leak the cache body.</span><br><span class="line">    if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123;</span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If we have a cache response too, then we&#39;re doing a conditional get.</span><br><span class="line">  &#x2F;&#x2F;HTTP_NOT_MODIFIED缓存有效，合并网络请求和缓存</span><br><span class="line">  if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">    if (networkResponse?.code &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      val response &#x3D; cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build()</span><br><span class="line"></span><br><span class="line">      networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Update the cache after combining headers but before stripping the</span><br><span class="line">      &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">      cache!!.trackConditionalCacheHit()</span><br><span class="line">      cache.update(cacheResponse, response)&#x2F;&#x2F;更新缓存</span><br><span class="line">      return response</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cacheResponse.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val response &#x3D; networkResponse!!.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build()</span><br><span class="line">  &#x2F;&#x2F;允许缓存且请求结果不为空，则写入缓存</span><br><span class="line">  if (cache !&#x3D; null) &#123;</span><br><span class="line">    if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      &#x2F;&#x2F; Offer this request to the cache.</span><br><span class="line">      val cacheRequest &#x3D; cache.put(response)</span><br><span class="line">      return cacheWritingResponse(cacheRequest, response)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cache.remove(networkRequest)</span><br><span class="line">      &#125; catch (_: IOException) &#123;</span><br><span class="line">        &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;  CacheStrategy中的核心方法 computeCandidate()</span><br><span class="line">   </span><br><span class="line">  &#x2F;** Returns a strategy to use assuming the request can use the network. *&#x2F;</span><br><span class="line">  private fun computeCandidate(): CacheStrategy &#123;</span><br><span class="line">    &#x2F;&#x2F; No cached response. 没有缓存，直接进行网络请求</span><br><span class="line">    if (cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Drop the cached response if it&#39;s missing a required handshake. 是https请求，但是没有握手，进行网络请求</span><br><span class="line">    if (request.isHttps &amp;&amp; cacheResponse.handshake &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If this response shouldn&#39;t have been stored, it should never be used as a response source.</span><br><span class="line">    &#x2F;&#x2F; This check should be redundant as long as the persistence store is well-behaved and the</span><br><span class="line">    &#x2F;&#x2F; rules are constant.</span><br><span class="line">    &#x2F;&#x2F;不能进行缓存</span><br><span class="line">    if (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val requestCaching &#x3D; request.cacheControl</span><br><span class="line">      &#x2F;&#x2F;请求头nocache或者请求头包含If-Modified-Since或者If-None-Match(意味着本地缓存过期，需要服务器验证本地缓存是不是还能继续使用)</span><br><span class="line">    if (requestCaching.noCache || hasConditions(request)) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val responseCaching &#x3D; cacheResponse.cacheControl</span><br><span class="line"></span><br><span class="line">    val ageMillis &#x3D; cacheResponseAge()</span><br><span class="line">    var freshMillis &#x3D; computeFreshnessLifetime()</span><br><span class="line"></span><br><span class="line">    if (requestCaching.maxAgeSeconds !&#x3D; -1) &#123;</span><br><span class="line">      freshMillis &#x3D; minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var minFreshMillis: Long &#x3D; 0</span><br><span class="line">    if (requestCaching.minFreshSeconds !&#x3D; -1) &#123;</span><br><span class="line">      minFreshMillis &#x3D; SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var maxStaleMillis: Long &#x3D; 0</span><br><span class="line">    if (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds !&#x3D; -1) &#123;</span><br><span class="line">      maxStaleMillis &#x3D; SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;缓存过期了，但仍然可用，给相应头中添加了Warning，使用缓存</span><br><span class="line">    if (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">      val builder &#x3D; cacheResponse.newBuilder()</span><br><span class="line">      if (ageMillis + minFreshMillis &gt;&#x3D; freshMillis) &#123;</span><br><span class="line">        builder.addHeader(&quot;Warning&quot;, &quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      val oneDayMillis &#x3D; 24 * 60 * 60 * 1000L</span><br><span class="line">      if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">        builder.addHeader(&quot;Warning&quot;, &quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      return CacheStrategy(null, builder.build())&#x2F;&#x2F;使用缓存</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Find a condition to add to the request. If the condition is satisfied, the response body</span><br><span class="line">    &#x2F;&#x2F; will not be transmitted.</span><br><span class="line">    val conditionName: String</span><br><span class="line">    val conditionValue: String?</span><br><span class="line">    &#x2F;&#x2F;流程走到这，说明缓存已经过期了</span><br><span class="line">    &#x2F;&#x2F;添加请求头：If-Modified-Since或者If-None-Match</span><br><span class="line">    &#x2F;&#x2F;etag与If-None-Match配合使用</span><br><span class="line">    &#x2F;&#x2F;lastModified与If-Modified-Since配合使用</span><br><span class="line">    &#x2F;&#x2F;前者和后者的值是相同的</span><br><span class="line">    &#x2F;&#x2F;区别在于前者是响应头，后者是请求头。</span><br><span class="line">    &#x2F;&#x2F;后者用于服务器进行资源比对，看看是资源是否改变了。</span><br><span class="line">    &#x2F;&#x2F; 如果没有，则本地的资源虽过期还是可以用的</span><br><span class="line">    when &#123;</span><br><span class="line">      etag !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-None-Match&quot;</span><br><span class="line">        conditionValue &#x3D; etag</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      lastModified !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-Modified-Since&quot;</span><br><span class="line">        conditionValue &#x3D; lastModifiedString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      servedDate !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-Modified-Since&quot;</span><br><span class="line">        conditionValue &#x3D; servedDateString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      else -&gt; return CacheStrategy(request, null) &#x2F;&#x2F; No condition! Make a regular request.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val conditionalRequestHeaders &#x3D; request.headers.newBuilder()</span><br><span class="line">    conditionalRequestHeaders.addLenient(conditionName, conditionValue!!)</span><br><span class="line"></span><br><span class="line">    val conditionalRequest &#x3D; request.newBuilder()</span><br><span class="line">        .headers(conditionalRequestHeaders.build())</span><br><span class="line">        .build()</span><br><span class="line">    return CacheStrategy(conditionalRequest, cacheResponse)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上述CatchStragety.computeCandidate()方法可知，缓存策略如下：</p><pre><code>1. 没有缓存，直接网络请求；2. 如果是Https，没有进行握手，则进行网络请求；3. 设置了不可缓存，则进行网络请求；4. 请求头nocache或者请求头包含If-Modified-Since或者If-None-Match，则需要服务器验证本地缓存是不是还能继续使用，进行网络请求；5. 可以缓存，并且缓存过期过期了但是还可以使用，这时给响应头添加Warning后，使用缓存；6. 缓存已经过期，添加请求头：If-Modified-Since或者If-None-Match，进行网络请求；</code></pre><p>整个CatcheIncepter的执行依靠CatchStragety的缓存策略，代码中添加了注释，这里整理下流程如下：</p><pre><code>1. 如果网络不可用并且无可用的有效缓存，则返回504错误；2. 如果禁止了网络请求，则直接使用缓存；3. 如果没有缓存且网络请求可用，则进行网络请求；4. 如果此时有缓存，并且网络请求返回HTTP_NOT_MODIFIED（304），说明缓存还是有效的，则合并网络响应和缓存结果。同时更新缓存；5. 如果没有缓存，则将请求回来的结果写入新的缓存中；6. 返回响应数据。</code></pre><p>可以看到，缓存的获取、添加、更新等操作都是在Catche中初始化了一个DiskLruCache来完成的，具体方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取缓存</span><br><span class="line"> internal fun get(request: Request): Response? &#123;</span><br><span class="line">    val key &#x3D; key(request.url)</span><br><span class="line">    val snapshot: DiskLruCache.Snapshot &#x3D; try &#123;</span><br><span class="line">      cache[key] ?: return null</span><br><span class="line">    &#125; catch (_: IOException) &#123;</span><br><span class="line">      return null &#x2F;&#x2F; Give up because the cache cannot be read.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val entry: Entry &#x3D; try &#123;</span><br><span class="line">      Entry(snapshot.getSource(ENTRY_METADATA))</span><br><span class="line">    &#125; catch (_: IOException) &#123;</span><br><span class="line">      snapshot.closeQuietly()</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val response &#x3D; entry.response(snapshot)</span><br><span class="line">    if (!entry.matches(request, response)) &#123;</span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加缓存</span><br><span class="line"> internal fun put(response: Response): CacheRequest? &#123;</span><br><span class="line">    val requestMethod &#x3D; response.request.method</span><br><span class="line"></span><br><span class="line">    if (HttpMethod.invalidatesCache(response.request.method)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        remove(response.request)</span><br><span class="line">      &#125; catch (_: IOException) &#123;</span><br><span class="line">        &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">      &#125;</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (requestMethod !&#x3D; &quot;GET&quot;) &#123;</span><br><span class="line">      &#x2F;&#x2F; Don&#39;t cache non-GET responses. We&#39;re technically allowed to cache HEAD requests and some</span><br><span class="line">      &#x2F;&#x2F; POST requests, but the complexity of doing so is high and the benefit is low.</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (response.hasVaryAll()) &#123;</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val entry &#x3D; Entry(response)</span><br><span class="line">    var editor: DiskLruCache.Editor? &#x3D; null</span><br><span class="line">    try &#123;</span><br><span class="line">      editor &#x3D; cache.edit(key(response.request.url)) ?: return null</span><br><span class="line">      entry.writeTo(editor)</span><br><span class="line">      return RealCacheRequest(editor)</span><br><span class="line">    &#125; catch (_: IOException) &#123;</span><br><span class="line">      abortQuietly(editor)</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新缓存</span><br><span class="line"> internal fun update(cached: Response, network: Response) &#123;</span><br><span class="line">    val entry &#x3D; Entry(network)</span><br><span class="line">    val snapshot &#x3D; (cached.body as CacheResponseBody).snapshot</span><br><span class="line">    var editor: DiskLruCache.Editor? &#x3D; null</span><br><span class="line">    try &#123;</span><br><span class="line">      editor &#x3D; snapshot.edit() ?: return &#x2F;&#x2F; edit() returns null if snapshot is not current.</span><br><span class="line">      entry.writeTo(editor)</span><br><span class="line">      editor.commit()</span><br><span class="line">    &#125; catch (_: IOException) &#123;</span><br><span class="line">      abortQuietly(editor)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="4-ConnectInterceptor"><a href="#4-ConnectInterceptor" class="headerlink" title="4. ConnectInterceptor"></a>4. ConnectInterceptor</h4><p>这个拦截器打开与目标服务器的链接并进入下一个拦截器。<br>通过<code>RealCall</code>的<code>initExchange(chain)</code>创建一个<code>Exchange</code>对象，并调用 <code>Chain.proceed()</code>方法。<br><code>initExchange（）</code>方法中会先通过 <code>ExchangeFinder</code> 尝试去 <code>RealConnectionPool</code> 中寻找已存在的连接，未找到则会重新创建一个<code>RealConnection</code> 并开始连接，然后将其存入<code>RealConnectionPool</code>，现在已经准备好了<code>RealConnection</code> 对象，然后通过请求协议创建不同的<code>ExchangeCodec</code> 并返回，返回的<code>ExchangeCodec</code>正是创建Exchange对象的一个参数。</p><ul><li>下面说一下在建立连接过程中涉及到的几个重要类：</li></ul><h5 id="Route"><a href="#Route" class="headerlink" title="Route:"></a>Route:</h5><p>是连接到服务器的具体路由。其中包含了 IP 地址、端口、代理等参数。<br>由于存在代理或者 DNS 可能返回多个 IP 地址的情况，所以同一个接口地址可能会对应多个 <code>route</code>。<br>在创建 Connection 时将会使用 Route 而不是直接用 IP 地址。</p><h5 id="RouteSelector："><a href="#RouteSelector：" class="headerlink" title="RouteSelector："></a>RouteSelector：</h5><p>路由选择器，其中存储了所有可用的 <code>route</code>，在准备连接时时会通过 <code>RouteSelector.next()</code> 方法获取下一个 <code>Route</code>。<br>值得注意的是，<code>RouteSelector</code>中包含了一个 <code>routeDatabase</code> 对象，其中存放着连接失败的<code>Route</code>，<code>RouteSelector</code> 会将其中存储的上次连接失败的<code>route</code> 放在最后，以此提高连接速度。</p><h5 id="RealConnection"><a href="#RealConnection" class="headerlink" title="RealConnection:"></a>RealConnection:</h5><p><code>RealConnection</code> 实现了 <code>Connection</code>接口，其中使用 <code>Socket</code>建立<code>HTTP/HTTPS</code>连接,并且获取 I/O 流，同一个 <code>Connection</code> 可能会承载多个 HTTP 的请求与响应。</p><h5 id="RealConnectionPool"><a href="#RealConnectionPool" class="headerlink" title="RealConnectionPool:"></a>RealConnectionPool:</h5><p>这是用来存储 <code>RealConnection</code> 的池子，内部使用一个双端队列来进行存储。<br>在 OkHttp 中，一个连接（RealConnection）用完后不会立马被关闭并释放掉，而且是会存储到连接池（RealConnectionPool）中。<br>除了缓存连接外，缓存池还负责定期清理过期的连接，在 RealConnection 中会维护一个用来描述该连接空闲时间的字段，每添加一个新的连接到连接池中时都会进行一次检测，遍历所有的连接，找出当前未被使用且空闲时间最长的那个连接，如果该连接空闲时长超出阈值，或者连接池已满，将会关闭该连接。</p><h5 id="ExchangeCodec："><a href="#ExchangeCodec：" class="headerlink" title="ExchangeCodec："></a>ExchangeCodec：</h5><p><code>ExchangeCodec</code> 负责对<code>Request</code> 编码及解码 <code>Response</code>，也就是写入请求及读取响应，我们的请求及响应数据都通过它来读写。其实现类有两个：<code>Http1ExchangeCodec</code> 及 <code>Http2ExchangeCodec</code>，分别对应两种协议版本。</p><h5 id="Exchange："><a href="#Exchange：" class="headerlink" title="Exchange："></a>Exchange：</h5><p>功能类似 <code>ExchangeCodec</code>，但它是对应的是单个请求，其在 <code>ExchangeCodec</code> 基础上担负了一些连接管理及事件分发的作用。<br>具体而言，<code>Exchange</code> 与 <code>Request</code> 一一对应，新建一个请求时就会创建一个 <code>Exchange</code>，该 <code>Exchange</code> 负责将这个请求发送出去并读取到响应数据，而发送与接收数据使用的是 <code>ExchangeCodec</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">   val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">   val exchange &#x3D; realChain.call.initExchange(chain)</span><br><span class="line">   val connectedChain &#x3D; realChain.copy(exchange &#x3D; exchange)</span><br><span class="line">   return connectedChain.proceed(realChain.request)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;RealCall 中的initExchange（）初始化Exchange对象</span><br><span class="line"> &#x2F;** Finds a new or pooled connection to carry a forthcoming request and response. *&#x2F;</span><br><span class="line"> internal fun initExchange(chain: RealInterceptorChain): Exchange &#123;</span><br><span class="line">   synchronized(connectionPool) &#123;</span><br><span class="line">     check(!noMoreExchanges) &#123; &quot;released&quot; &#125;</span><br><span class="line">     check(exchange &#x3D;&#x3D; null)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   val codec &#x3D; exchangeFinder!!.find(client, chain)</span><br><span class="line">   val result &#x3D; Exchange(this, eventListener, exchangeFinder!!, codec)</span><br><span class="line">   this.interceptorScopedExchange &#x3D; result</span><br><span class="line"></span><br><span class="line">   synchronized(connectionPool) &#123;</span><br><span class="line">     this.exchange &#x3D; result</span><br><span class="line">     this.exchangeRequestDone &#x3D; false</span><br><span class="line">     this.exchangeResponseDone &#x3D; false</span><br><span class="line">     return result</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;找到可用的resultConnection后根据协议创建ExchangeCodec并返回</span><br><span class="line"> fun find(</span><br><span class="line">   client: OkHttpClient,</span><br><span class="line">   chain: RealInterceptorChain</span><br><span class="line"> ): ExchangeCodec &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">     val resultConnection &#x3D; findHealthyConnection(</span><br><span class="line">         connectTimeout &#x3D; chain.connectTimeoutMillis,</span><br><span class="line">         readTimeout &#x3D; chain.readTimeoutMillis,</span><br><span class="line">         writeTimeout &#x3D; chain.writeTimeoutMillis,</span><br><span class="line">         pingIntervalMillis &#x3D; client.pingIntervalMillis,</span><br><span class="line">         connectionRetryEnabled &#x3D; client.retryOnConnectionFailure,</span><br><span class="line">         doExtensiveHealthChecks &#x3D; chain.request.method !&#x3D; &quot;GET&quot;</span><br><span class="line">     )</span><br><span class="line">     return resultConnection.newCodec(client, chain)</span><br><span class="line">   &#125; catch (e: RouteException) &#123;</span><br><span class="line">     trackFailure(e.lastConnectException)</span><br><span class="line">     throw e</span><br><span class="line">   &#125; catch (e: IOException) &#123;</span><br><span class="line">     trackFailure(e)</span><br><span class="line">     throw RouteException(e)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;ExchangeFinder的findConnection方法中找已经存在的可用的链接</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span><br><span class="line">  * then the pool, finally building a new connection.</span><br><span class="line">  *&#x2F;</span><br><span class="line"> @Throws(IOException::class)</span><br><span class="line"> private fun findConnection(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   writeTimeout: Int,</span><br><span class="line">   pingIntervalMillis: Int,</span><br><span class="line">   connectionRetryEnabled: Boolean</span><br><span class="line"> ): RealConnection &#123;</span><br><span class="line">   var foundPooledConnection &#x3D; false</span><br><span class="line">   var result: RealConnection? &#x3D; null</span><br><span class="line">   var selectedRoute: Route? &#x3D; null</span><br><span class="line">   var releasedConnection: RealConnection?</span><br><span class="line">   val toClose: Socket?</span><br><span class="line">   synchronized(connectionPool) &#123;</span><br><span class="line">   </span><br><span class="line">      …………</span><br><span class="line">      </span><br><span class="line">       &#x2F;&#x2F; Attempt to get a connection from the pool.</span><br><span class="line">       &#x2F;&#x2F;从connectPool中找可用的链接并返回</span><br><span class="line">       if (connectionPool.callAcquirePooledConnection(address, call, null, false)) &#123;</span><br><span class="line">         foundPooledConnection &#x3D; true</span><br><span class="line">         result &#x3D; call.connection</span><br><span class="line">       &#125; else if (nextRouteToTry !&#x3D; null) &#123;</span><br><span class="line">         selectedRoute &#x3D; nextRouteToTry</span><br><span class="line">         nextRouteToTry &#x3D; null</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   toClose?.closeQuietly()</span><br><span class="line"></span><br><span class="line">   if (releasedConnection !&#x3D; null) &#123;</span><br><span class="line">     eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">   &#125;</span><br><span class="line">   if (foundPooledConnection) &#123;</span><br><span class="line">     eventListener.connectionAcquired(call, result!!)</span><br><span class="line">   &#125;</span><br><span class="line">   if (result !&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; If we found an already-allocated or pooled connection, we&#39;re done.</span><br><span class="line">     return result!!</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">     …………</span><br><span class="line">     </span><br><span class="line">   &#x2F;&#x2F; Create a connection and assign it to this allocation immediately. This makes it possible</span><br><span class="line">       &#x2F;&#x2F; for an asynchronous cancel() to interrupt the handshake we&#39;re about to do.</span><br><span class="line">       &#x2F;&#x2F;创建一个新的RealConnection</span><br><span class="line">       result &#x3D; RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">       connectingConnection &#x3D; result</span><br><span class="line">       </span><br><span class="line">  var socket: Socket? &#x3D; null</span><br><span class="line">   synchronized(connectionPool) &#123;</span><br><span class="line">     connectingConnection &#x3D; null</span><br><span class="line">     &#x2F;&#x2F; Last attempt at connection coalescing, which only occurs if we attempted multiple</span><br><span class="line">     &#x2F;&#x2F; concurrent connections to the same host.</span><br><span class="line">     if (connectionPool.callAcquirePooledConnection(address, call, routes, true)) &#123;</span><br><span class="line">       &#x2F;&#x2F; We lost the race! Close the connection we created and return the pooled connection.</span><br><span class="line">       result!!.noNewExchanges &#x3D; true</span><br><span class="line">       socket &#x3D; result!!.socket()</span><br><span class="line">       result &#x3D; call.connection</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; It&#39;s possible for us to obtain a coalesced connection that is immediately unhealthy. In</span><br><span class="line">       &#x2F;&#x2F; that case we will retry the route we just successfully connected with.</span><br><span class="line">       nextRouteToTry &#x3D; selectedRoute</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       connectionPool.put(result!!)&#x2F;&#x2F;将新创建的RealConnection添加到connectPool中</span><br><span class="line">       call.acquireConnectionNoEvents(result!!)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">   eventListener.connectionAcquired(call, result!!)</span><br><span class="line">   </span><br><span class="line">   return result!!</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="5-CallServerInterceptor"><a href="#5-CallServerInterceptor" class="headerlink" title="5. CallServerInterceptor"></a>5. CallServerInterceptor</h4><p>这是OkHttp 的连接器链中的最后一个拦截器，负责利用exchange把Request中的数据发送给服务端，并获取到数据写入到Response中。</p><p>到这里，OkHttp框架的核心逻辑已经梳理完了，回顾一下整体的架构实现，用到的设计模式有：Builder模式（OKHttpClient的构建）、工厂方法模式（Call接口提供了内部接口Factory、责任链模式（拦截器链）、享元模式（在Dispatcher的线程池）、策略模式（CacheInterceptor中数据选择等。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>OkHttp 4.6源码</li><li><a href="https://blog.csdn.net/json_it/article/details/78404010" target="_blank" rel="noopener">okhttp源码解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/104813091" target="_blank" rel="noopener">OkHttp 源码分析</a></li><li>感谢您阅读这篇文章，若有不正确的地方，欢迎指正!</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;OkHttp 是一款非常优秀的网络请求框架，随着Kotlin语言的不断完善，OkHttp 自 4.0 版本开始使用Kotlin编写，对于巩固
      
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://eriecorner.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="三方框架源码解析" scheme="https://eriecorner.github.io/tags/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】14.数值的整数次方</title>
    <link href="https://eriecorner.github.io/2020/04/26/suan-fa/jian-zhi-offer/14.shu-zhi-de-zheng-shu-ci-fang/"/>
    <id>https://eriecorner.github.io/2020/04/26/suan-fa/jian-zhi-offer/14.shu-zhi-de-zheng-shu-ci-fang/</id>
    <published>2020-04-26T14:27:25.747Z</published>
    <updated>2020-05-18T13:36:14.313Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><ul><li>题目来源： <a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&tqId=11165&tPage=1&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking&from=cyc_github" target="_blank" rel="noopener">Nowcoder</a></li><li>题设：给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。（保证base和exponent不同时为0 ）</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>负数的幂次方等于其绝对值的幂次方的倒数</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public double power(double base, int exponent) &#123;</span><br><span class="line">        double result &#x3D; 1;</span><br><span class="line">        if (base &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 0.0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (exponent &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return 1.0;</span><br><span class="line">        &#125;</span><br><span class="line">        int t &#x3D; Math.abs(exponent);</span><br><span class="line">       while (t&gt;&#x3D;1)&#123;</span><br><span class="line">           result *&#x3D; base;</span><br><span class="line">           t--;</span><br><span class="line">       &#125;</span><br><span class="line">       if (exponent&gt;0)&#123;</span><br><span class="line">           return result;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           return 1.0&#x2F;result;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">fun power(base: Double, exponent: Int): Double &#123;</span><br><span class="line">       var result &#x3D; 1.0</span><br><span class="line">       if (base &#x3D;&#x3D; 0.0) &#123;</span><br><span class="line">           return 0.0</span><br><span class="line">       &#125;</span><br><span class="line">       if (exponent &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           return 1.0</span><br><span class="line">       &#125;</span><br><span class="line">       var t &#x3D; abs(exponent)</span><br><span class="line">       while (t &gt;&#x3D; 1) &#123;</span><br><span class="line">           result *&#x3D; base</span><br><span class="line">           t--</span><br><span class="line">       &#125;</span><br><span class="line">       return if (exponent &gt; 0) &#123;</span><br><span class="line">           result</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           1.0 &#x2F; result</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://www.nowcoder.com/practice/1a834e5
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数学" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】12. 剪绳子</title>
    <link href="https://eriecorner.github.io/2020/04/24/suan-fa/jian-zhi-offer/12.jian-sheng-zi/"/>
    <id>https://eriecorner.github.io/2020/04/24/suan-fa/jian-zhi-offer/12.jian-sheng-zi/</id>
    <published>2020-04-23T16:00:00.000Z</published>
    <updated>2020-05-18T13:38:58.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><ul><li>来源：<a href="https://www.nowcoder.com/practice/57d85990ba5b440ab888fc72b0751bf8" target="_blank" rel="noopener">NewCoder</a></li><li>题设：给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><p>先举几个例子找找规律：</p><blockquote><ul><li>2 :  1*1</li><li>3 :  1*2</li><li>4 ： 2*2</li><li>5 ： 2*3<ul><li>6 ： 3*3</li><li>7 ： 2*2*3 或者4*3</li></ul></li><li>8 ： 2*3*3</li><li>9 ： 3*3*3</li><li>10：2*2*3*3 或者4*3*3</li><li>11：2*3*3*3</li><li>12：3*3*3*3</li><li>13：2*2*3*3*3 或者4*3*3*3</li></ul></blockquote></li><li><p>由此可见：2，3包含于各个问题中，如果再往下剪得话，乘积就会变小。所以选择2，3作为做小的子问题。</p></li><li><p>当n≥5时，3(n−3)≥2(n−2)，所以我们尽可能多的剪长度为3的绳子；当剩下的绳子长度为4时，把绳子剪成两段长度为2的绳子。 </p></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 剪绳子问题</span><br><span class="line">    *</span><br><span class="line">    * @param n 绳子长度 是整数且&gt;1</span><br><span class="line">    *          把绳子剪成整数长的m段，m是整数，且&gt;1</span><br><span class="line">    * @return</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public int cutRope(int n) &#123;</span><br><span class="line">       if (n &lt; 2) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       if (n &#x3D;&#x3D; 2) &#123;&#x2F;&#x2F;因为m&gt;1,所以只能是1*1</span><br><span class="line">           return 1;</span><br><span class="line">       &#125;</span><br><span class="line">       if (n &#x3D;&#x3D; 3) &#123;</span><br><span class="line">           return 2;</span><br><span class="line">       &#125;</span><br><span class="line">       int times3 &#x3D; n &#x2F; 3;</span><br><span class="line"></span><br><span class="line">       if (n % 3 &#x3D;&#x3D; 1) &#123;</span><br><span class="line">           times3--;</span><br><span class="line">       &#125;</span><br><span class="line">       int times2 &#x3D; (n -3*times3) &#x2F; 2;</span><br><span class="line"></span><br><span class="line">       return (int) (Math.pow(2, times2) * Math.pow(3, times3));</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="Kotlin-实现"><a href="#Kotlin-实现" class="headerlink" title="Kotlin 实现"></a>Kotlin 实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 剪绳子问题</span><br><span class="line">   *</span><br><span class="line">   * @param n 绳子长度 是整数且&gt;1</span><br><span class="line">   *          把绳子剪成整数长的m段，m是整数，且&gt;1</span><br><span class="line">   * @return</span><br><span class="line">   *&#x2F;</span><br><span class="line"> fun cutRope(n:Int):Int&#123;</span><br><span class="line">      if(n&lt;2)&#123;</span><br><span class="line">          return 0</span><br><span class="line">      &#125;</span><br><span class="line">      if (n&#x3D;&#x3D;2)&#123;&#x2F;&#x2F;因为m&gt;1,所以只能1*1</span><br><span class="line">          return 1</span><br><span class="line">      &#125;</span><br><span class="line">      if (n&#x3D;&#x3D;3)&#123;</span><br><span class="line">          return 2</span><br><span class="line">      &#125;</span><br><span class="line">      var times3 &#x3D; n&#x2F;3</span><br><span class="line">      if (times3%3&#x3D;&#x3D;1)&#123;</span><br><span class="line">          times3--</span><br><span class="line">      &#125;</span><br><span class="line">      val times2 &#x3D; (n- 3*times3)&#x2F;2</span><br><span class="line">      return (2.0.pow(times2.toDouble())* 3.0.pow(times3.toDouble())).toInt()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;来源：&lt;a href=&quot;https://www.nowcoder.com/practice/57d859
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数学" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】11.机器人的运动范围</title>
    <link href="https://eriecorner.github.io/2020/04/23/suan-fa/jian-zhi-offer/11.ji-qi-ren-de-yun-dong-fan-wei/"/>
    <id>https://eriecorner.github.io/2020/04/23/suan-fa/jian-zhi-offer/11.ji-qi-ren-de-yun-dong-fan-wei/</id>
    <published>2020-04-22T16:00:00.000Z</published>
    <updated>2020-05-18T13:34:14.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8?tpId=13&tqId=11219&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking&from=cyc_github" target="_blank" rel="noopener">NowCoder</a></p><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>从(0,0)开始走，每成功走一步标记当前位置为true,然后从当前位置往四个方向探索，返回1 + 44个方向的探索值之和。</li><li>探索时，判断当前节点是否可达的标准为：<ol><li>当前节点在矩阵内；</li><li>当前节点未被访问过；</li><li>当前节点满足limit限制。</li></ol></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="java-实现"><a href="#java-实现" class="headerlink" title="java 实现"></a>java 实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 机器人的运动范围</span><br><span class="line">     *</span><br><span class="line">     * @param threshold</span><br><span class="line">     * @param rows</span><br><span class="line">     * @param cols</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int movingCount(int threshold, int rows, int cols) &#123;</span><br><span class="line"></span><br><span class="line">        if (rows &lt; 0 || cols &lt; 0 || threshold &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;标记矩阵中的格子是否走过</span><br><span class="line">        boolean[][] visit &#x3D; new boolean[rows][cols];</span><br><span class="line"></span><br><span class="line">        return findPathCount(threshold, rows, cols, 0, 0, visit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param k </span><br><span class="line">     * @param rows</span><br><span class="line">     * @param cols</span><br><span class="line">     * @param i</span><br><span class="line">     * @param j</span><br><span class="line">     * @param visit</span><br><span class="line">     * @return 可走格子数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public int findPathCount(int k, int rows, int cols, int i, int j, boolean[][] visit) &#123;</span><br><span class="line">        &#x2F;&#x2F;若越界或者已经走过或者当前位置的坐标不满足条件，则返回0</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; rows || j &gt;&#x3D; cols || visit[i][j] || !(sumIsOk(k, i, j))) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 标记当前位置已走过</span><br><span class="line">        visit[i][j] &#x3D; true;</span><br><span class="line">        &#x2F;&#x2F;当前位置的上下左右可走格子的和+1（当前格子）</span><br><span class="line">        return 1 + findPathCount(k, rows, cols, i + 1, j, visit)</span><br><span class="line">                + findPathCount(k, rows, cols, i - 1, j, visit)</span><br><span class="line">                + findPathCount(k, rows, cols, i, j - 1, visit)</span><br><span class="line">                + findPathCount(k, rows, cols, i, j + 1, visit);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @param k</span><br><span class="line">     * @param row</span><br><span class="line">     * @param col</span><br><span class="line">     * @return 行坐标和列坐标的数位之和是否大于k</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public boolean sumIsOk(int k, int row, int col) &#123;</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        while (row !&#x3D; 0) &#123;</span><br><span class="line">            sum +&#x3D; row % 10;</span><br><span class="line">            row &#x3D; row &#x2F; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        while (col !&#x3D; 0) &#123;</span><br><span class="line">            sum +&#x3D; col % 10;</span><br><span class="line">            col &#x3D; col &#x2F; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum &lt;&#x3D; k;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Kotlin实现"><a href="#Kotlin实现" class="headerlink" title="Kotlin实现"></a>Kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     *机器人的运动范围</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun movingCount(k: Int, rows: Int, cols: Int): Int &#123;</span><br><span class="line">        if (k &lt; 0 || rows &lt; 0 || cols &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        val visit &#x3D; Array(rows) &#123; BooleanArray(cols) &#125;</span><br><span class="line">        return findPathCount(k, rows, cols, 0, 0, visit)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *回溯法寻找可行走的格子</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun findPathCount(k: Int, rows: Int, cols: Int, i: Int, j: Int, visit: Array&lt;BooleanArray&gt;): Int &#123;</span><br><span class="line">        &#x2F;&#x2F;若越界或者已经走过或者当前位置的坐标不满足条件，则返回0</span><br><span class="line">        if (i &lt; 0 || j &lt; 0 || i &gt;&#x3D; rows || j &gt;&#x3D; cols || visit[i][j] || !sumIsOk(k, i, j)) &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 标记当前位置已走过</span><br><span class="line">        visit[i][j] &#x3D; true</span><br><span class="line">        &#x2F;&#x2F;当前位置的上下左右可走格子的和+1（当前格子）</span><br><span class="line">        return (1 + findPathCount(k, rows, cols, i + 1, j, visit)</span><br><span class="line">                + findPathCount(k, rows, cols, i - 1, j, visit)</span><br><span class="line">                + findPathCount(k, rows, cols, i, j - 1, visit)</span><br><span class="line">                + findPathCount(k, rows, cols, i, j + 1, visit))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 判断 限制条件是否ok</span><br><span class="line">     *&#x2F;</span><br><span class="line">    fun sumIsOk(k: Int, row: Int, col: Int): Boolean &#123;</span><br><span class="line">        var row &#x3D; row</span><br><span class="line">        var col &#x3D; col</span><br><span class="line">        var sum &#x3D; 0</span><br><span class="line">        while (row !&#x3D; 0) &#123;</span><br><span class="line">            sum +&#x3D; row % 10</span><br><span class="line">            row &#x3D; row &#x2F; 10</span><br><span class="line">        &#125;</span><br><span class="line">        while (col !&#x3D; 0) &#123;</span><br><span class="line">            sum +&#x3D; col % 10</span><br><span class="line">            col &#x3D; col &#x2F; 10</span><br><span class="line">        &#125;</span><br><span class="line">        return sum &lt;&#x3D; k</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/practice/6e5207314b5241fb83f
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】7. 重建二叉树</title>
    <link href="https://eriecorner.github.io/2020/04/17/suan-fa/jian-zhi-offer/7.chong-jian-er-cha-shu/"/>
    <id>https://eriecorner.github.io/2020/04/17/suan-fa/jian-zhi-offer/7.chong-jian-er-cha-shu/</id>
    <published>2020-04-16T16:00:00.000Z</published>
    <updated>2020-05-18T13:33:55.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><ul><li><p>首先定义树结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private class TreeNode &#123;</span><br><span class="line">      int node;&#x2F;&#x2F;节点</span><br><span class="line">      TreeNode left;&#x2F;&#x2F;左子树</span><br><span class="line">      TreeNode right;&#x2F;&#x2F;右子树</span><br><span class="line"></span><br><span class="line">      public TreeNode(int node) &#123;</span><br><span class="line">          this.node &#x3D; node;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public String toString() &#123;</span><br><span class="line">          return &quot;TreeNode [data&#x3D;&quot; + node + &quot;, left&#x3D;&quot; + left + &quot;, right&#x3D;&quot; + right</span><br><span class="line">                  + &quot;]&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>核心算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123;</span><br><span class="line">       if (pre.length &#x3D;&#x3D; 0 || in.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       TreeNode root &#x3D; rebuildBinaryTreeCoreAfter(pre,0,pre.length-1,in,0,in.length-1);</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   public TreeNode rebuildBinaryTreeCore(int preorder[], int startPreorder,</span><br><span class="line">                                         int endPreorder, int inorder[], int startInorder, int endInorder) &#123;</span><br><span class="line">       if (startPreorder &gt; endPreorder || startInorder &gt; endInorder) &#123; &#x2F;&#x2F;停止递归的条件</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       TreeNode root &#x3D; new TreeNode(preorder[startPreorder]);</span><br><span class="line">       for (int i &#x3D; startInorder; i &lt;&#x3D; endInorder; i++) &#123;</span><br><span class="line">           if (preorder[startPreorder] &#x3D;&#x3D; inorder[i]) &#123;</span><br><span class="line">               &#x2F;&#x2F; 其中（i - startInorder）为中序排序中左子树结点的个数</span><br><span class="line">               &#x2F;&#x2F;左子树</span><br><span class="line">               root.left &#x3D; rebuildBinaryTreeCore(preorder, startPreorder + 1,</span><br><span class="line">                       startPreorder + (i - startInorder), inorder,</span><br><span class="line">                       startInorder, i-1 );</span><br><span class="line">               &#x2F;&#x2F;右子树</span><br><span class="line">               root.right &#x3D; rebuildBinaryTreeCore(preorder, (i - startInorder)</span><br><span class="line">                               + startPreorder + 1, endPreorder, inorder, i + 1,</span><br><span class="line">                       endInorder);</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void getResult() &#123;</span><br><span class="line">        int[] pre &#x3D; &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;;</span><br><span class="line">        int[] mid &#x3D; &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;;</span><br><span class="line">        System.out.println(reConstructBinaryTree(pre,mid));</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">      &#x2F;&#x2F;树结构：</span><br><span class="line">              1</span><br><span class="line">              </span><br><span class="line">        2          3</span><br><span class="line">        </span><br><span class="line">    4           5     6</span><br><span class="line">                     </span><br><span class="line">      7             8</span><br></pre></td></tr></table></figure><h4 id="Kotlin实现"><a href="#Kotlin实现" class="headerlink" title="Kotlin实现"></a>Kotlin实现</h4></li><li><p>首先定义树结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data class TreeNode(val data: Int, var left: TreeNode? &#x3D; null, var right: TreeNode? &#x3D; null) &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>核心算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private fun reConstructBinaryTree(pre: IntArray, mid: IntArray): TreeNode? &#123;</span><br><span class="line">      if (pre.isEmpty() || mid.isEmpty()) &#123;</span><br><span class="line">          return null</span><br><span class="line">      &#125;</span><br><span class="line">      return reConstructBinaryTreeCore(pre, 0, pre.size - 1, mid, 0, mid.size - 1)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  private fun reConstructBinaryTreeCore(pre: IntArray, preStart: Int, preEnd: Int,</span><br><span class="line">                                        mid: IntArray, midStart: Int, midEnd: Int): TreeNode? &#123;</span><br><span class="line">      if (preStart &gt; preEnd || midStart &gt; midEnd) &#123;</span><br><span class="line">          return null</span><br><span class="line">      &#125;</span><br><span class="line">      val root &#x3D; TreeNode(pre[preStart]);</span><br><span class="line">      for (i in mid.indices) &#123;</span><br><span class="line">          if (mid[i] &#x3D;&#x3D; pre[preStart]) &#123;</span><br><span class="line">              &#x2F;&#x2F;（）i - midStart） 是为中序排序中左子树结点的个数</span><br><span class="line">              &#x2F;&#x2F;左子树</span><br><span class="line">              root.left &#x3D; reConstructBinaryTreeCore(pre, preStart + 1, preStart + (i - midStart),</span><br><span class="line">                      mid, midStart, i - 1)</span><br><span class="line">              &#x2F;&#x2F;右子树</span><br><span class="line">              root.right &#x3D; reConstructBinaryTreeCore(pre, preStart + (i - midStart) + 1, preEnd,</span><br><span class="line">                      mid, i + 1, midEnd)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun getResult() &#123;</span><br><span class="line">        val pre &#x3D; intArrayOf(1, 2, 4, 7, 3, 5, 6, 8)</span><br><span class="line">        val mid &#x3D; intArrayOf(4, 7, 2, 1, 5, 3, 8, 6)</span><br><span class="line">        print(reConstructBinaryTree(pre, mid ));</span><br><span class="line">    &#125;   </span><br><span class="line">    &#x2F;&#x2F;树结构</span><br><span class="line">    </span><br><span class="line">             1</span><br><span class="line">              </span><br><span class="line">        2          3</span><br><span class="line">        </span><br><span class="line">    4           5     6</span><br><span class="line">                     </span><br><span class="line">      7             8</span><br></pre></td></tr></table></figure></li></ul><h2 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h2><p>根据二叉树的后序遍历和中序遍历的结果，重建出该二叉树。假设输入的后序遍历和中序遍历的结果中都不含重复的数字。</p><h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>思路同上，后序序遍历的最后一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。然后分别对左右子树递归地求解。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现-1"><a href="#JAVA实现-1" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><ul><li>核心算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private TreeNode rebuildBinaryTreeCoreAfter(int[] after,int afterStart,int afterEnd,int[]mid ,int midStart,int midEnd )&#123;</span><br><span class="line">        if (afterStart&gt;afterEnd||midStart&gt;midEnd)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root &#x3D; new TreeNode(after[afterEnd]);</span><br><span class="line">        for (int i &#x3D; 0; i &lt;&#x3D; midEnd; i++) &#123;</span><br><span class="line">            if (after[afterEnd]&#x3D;&#x3D;mid[i])&#123;</span><br><span class="line">                root.left &#x3D; rebuildBinaryTreeCoreAfter(after,afterStart,afterStart-1+(i-midStart),</span><br><span class="line">                        mid,midStart,i-1);</span><br><span class="line">                root.right &#x3D; rebuildBinaryTreeCoreAfter(after,afterStart+(i-midStart),afterEnd-1,</span><br><span class="line">                        mid,i+1,midEnd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li>验证<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void getResult() &#123;</span><br><span class="line">       &#x2F;&#x2F;int[] pre &#x3D; &#123;1, 2, 4, 7, 3, 5, 6, 8&#125;;</span><br><span class="line">       &#x2F;&#x2F;int[] mid &#x3D; &#123;4, 7, 2, 1, 5, 3, 8, 6&#125;;</span><br><span class="line">       &#x2F;&#x2F;System.out.println(reConstructBinaryTree(pre,mid));</span><br><span class="line">       int[] after &#x3D; &#123;2,4,3,1,6,7,5&#125;;</span><br><span class="line">       int[] mid &#x3D; &#123;1,2,3,4,5,6,7&#125;;</span><br><span class="line">       System.out.println(reConstructBinaryTree(after,mid));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F;树结构</span><br><span class="line">        5</span><br><span class="line">   </span><br><span class="line">   1        7</span><br><span class="line">   </span><br><span class="line">     3     6</span><br><span class="line">      </span><br><span class="line">   2   4</span><br></pre></td></tr></table></figure><h4 id="Kotlin实现-1"><a href="#Kotlin实现-1" class="headerlink" title="Kotlin实现"></a>Kotlin实现</h4></li><li>核心算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private fun reConstructBinaryTreeAfter(pre: Array&lt;Int&gt;, mid: Array&lt;Int&gt;): TreeNode? &#123;</span><br><span class="line">    if (pre.isEmpty() || mid.isEmpty()) &#123;</span><br><span class="line">        return null</span><br><span class="line">    &#125;</span><br><span class="line">    val root &#x3D; reConstructBinaryTreeCoreAfter(pre, 0, pre.size - 1, mid, 0, mid.size - 1)</span><br><span class="line">    return root</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private fun reConstructBinaryTreeCoreAfter(after: Array&lt;Int&gt;, afterStart: Int, afterEnd: Int,</span><br><span class="line">                                           mid: Array&lt;Int&gt;, midStart: Int, midEnd: Int): TreeNode? &#123;</span><br><span class="line">    if (afterStart &gt; afterEnd || midStart &gt; midEnd)</span><br><span class="line">        return null</span><br><span class="line">    val root &#x3D; TreeNode(after[afterEnd])</span><br><span class="line">    for (i in mid.indices) &#123;</span><br><span class="line">        if (mid[i] &#x3D;&#x3D; after[afterEnd]) &#123;</span><br><span class="line">            root.left &#x3D; reConstructBinaryTreeCoreAfter(after, afterStart, afterStart - 1 + (i - midStart),</span><br><span class="line">                    mid, midStart, i - 1)</span><br><span class="line">            root.right &#x3D; reConstructBinaryTreeCoreAfter(after, afterStart + (i - midStart),</span><br><span class="line">                    afterEnd - 1, mid, i + 1, midEnd)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>验证<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun getResult() &#123;</span><br><span class="line">&#x2F;&#x2F;        val pre &#x3D; intArrayOf(1, 2, 4, 7, 3, 5, 6, 8)</span><br><span class="line">&#x2F;&#x2F;        val mid &#x3D; intArrayOf(4, 7, 2, 1, 5, 3, 8, 6)</span><br><span class="line">&#x2F;&#x2F;        print(reConstructBinaryTree(pre, mid ));</span><br><span class="line"></span><br><span class="line">        val after &#x3D; arrayOf(2,4,3,1,6,7,5)</span><br><span class="line">        val ins  &#x3D; arrayOf(1,2,3,4,5,6,7)</span><br><span class="line">        print(reConstructBinaryTreeAfter(after, ins));</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;树结构</span><br><span class="line">         5</span><br><span class="line">    </span><br><span class="line">    1        7</span><br><span class="line">    </span><br><span class="line">      3     6</span><br><span class="line">       </span><br><span class="line">    2   4</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】6. 从尾到头打印链表</title>
    <link href="https://eriecorner.github.io/2020/04/16/suan-fa/jian-zhi-offer/6.cong-wei-dao-tou-da-yin-lian-biao/"/>
    <id>https://eriecorner.github.io/2020/04/16/suan-fa/jian-zhi-offer/6.cong-wei-dao-tou-da-yin-lian-biao/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-05-18T13:33:25.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>从尾到头反过来打印出每个结点的值。</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><h3 id="1-使用栈"><a href="#1-使用栈" class="headerlink" title="1. 使用栈"></a>1. 使用栈</h3><p>栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。</p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;先定义一个节点</span><br><span class="line">    public static class ListNode &#123;</span><br><span class="line">        private int value;</span><br><span class="line">        private ListNode next;</span><br><span class="line"></span><br><span class="line">        public ListNode(int node) &#123;</span><br><span class="line">            this.value &#x3D; node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;构建链表</span><br><span class="line">      private ListNode BuildLinkList() &#123;</span><br><span class="line">        ListNode head &#x3D; new ListNode(0);</span><br><span class="line">        ListNode cur &#x3D; head;</span><br><span class="line">        for (int i &#x3D; 1; i &lt; 10; i++) &#123;</span><br><span class="line">            ListNode tmp &#x3D; new ListNode(i);</span><br><span class="line">            cur.next&#x3D; tmp;</span><br><span class="line">            cur &#x3D; tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> public ArrayList&lt;Integer&gt; printListFromTrilToHead(ListNode listNode)&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">        while (listNode!&#x3D;null)&#123;</span><br><span class="line">            stack.add(listNode.value);</span><br><span class="line">            listNode &#x3D; listNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        while (!stack.isEmpty())&#123;</span><br><span class="line">            ret.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-递归"><a href="#2-递归" class="headerlink" title="2.递归"></a>2.递归</h4><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTrilToHead1(ListNode listNode) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">        if (listNode !&#x3D; null) &#123;</span><br><span class="line">            ret.addAll(printListFromTrilToHead1(listNode.next));</span><br><span class="line">            ret.add(listNode.value);</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-遍历node的每一个节点插入到集合的第一个位置"><a href="#3-遍历node的每一个节点插入到集合的第一个位置" class="headerlink" title="3.遍历node的每一个节点插入到集合的第一个位置"></a>3.遍历node的每一个节点插入到集合的第一个位置</h4><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTrilToHead2(ListNode listNode) &#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">       ListNode tmp &#x3D; listNode;</span><br><span class="line">       while (tmp !&#x3D; null) &#123;</span><br><span class="line">           ret.add(0,tmp.value);</span><br><span class="line">           tmp &#x3D; tmp.next;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="4-头插法"><a href="#4-头插法" class="headerlink" title="4. 头插法"></a>4. 头插法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;Integer&gt; printListFromTrilToHead3(ListNode listNode) &#123;</span><br><span class="line">       ArrayList&lt;Integer&gt; ret &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">       ListNode head &#x3D; new ListNode(-1);</span><br><span class="line">       while (listNode !&#x3D; null) &#123;</span><br><span class="line">           ListNode tmp &#x3D; listNode.next;</span><br><span class="line">           listNode.next &#x3D; head.next;</span><br><span class="line">           head.next &#x3D; listNode;</span><br><span class="line">           listNode &#x3D; tmp;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       head &#x3D; head.next;</span><br><span class="line">       while (head !&#x3D; null) &#123;</span><br><span class="line">           ret.add(head.value);</span><br><span class="line">           head &#x3D; head.next;</span><br><span class="line">       &#125;</span><br><span class="line">       return ret;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;从尾到头反过来打印出每个结点的值。&lt;/p&gt;
&lt;h2 id=&quot;题解：&quot;&gt;&lt;a href=&quot;#题解：&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】5. 替换空格</title>
    <link href="https://eriecorner.github.io/2020/04/16/suan-fa/jian-zhi-offer/5.ti-huan-kong-ge/"/>
    <id>https://eriecorner.github.io/2020/04/16/suan-fa/jian-zhi-offer/5.ti-huan-kong-ge/</id>
    <published>2020-04-15T16:00:00.000Z</published>
    <updated>2020-05-18T13:33:10.469Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>将一个字符串中的空格替换成 “%20”。</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>从后往前复制，数组长度会增加，或使用StringBuffer，StringBuild类。</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><p>时间复杂度O（N），空间复杂度O（N）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public String replaceSpace(String value)&#123;</span><br><span class="line">       if (value&#x3D;&#x3D;null)&#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">       StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line">       for (int i &#x3D; 0; i &lt;value.length() ; i++) &#123;</span><br><span class="line">           if (String.valueOf(value.charAt(i)).equals(&quot; &quot;))&#123;</span><br><span class="line">               builder.append(&quot;%20&quot;);</span><br><span class="line">           &#125;else &#123;</span><br><span class="line">               builder.append(value.charAt(i));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return builder.toString();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;将一个字符串中的空格替换成 “%20”。&lt;/p&gt;
&lt;h2 id=&quot;题解：&quot;&gt;&lt;a href=&quot;#题解：&quot; class
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="字符串" scheme="https://eriecorner.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】 2. 旋转数组中的最小元素</title>
    <link href="https://eriecorner.github.io/2020/04/15/suan-fa/jian-zhi-offer/2.xuan-zhuan-shu-zu-zhong-de-zui-xiao-yuan-su/"/>
    <id>https://eriecorner.github.io/2020/04/15/suan-fa/jian-zhi-offer/2.xuan-zhuan-shu-zu-zhong-de-zui-xiao-yuan-su/</id>
    <published>2020-04-14T16:00:00.000Z</published>
    <updated>2020-05-18T13:32:45.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>利用折半查找的思想，时间复杂度度为O（logN），为了方便，这里将 log2N 写为 logN</p><p>将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。</p><p>（l 代表 low，m 代表 mid，h 代表 high）<br>当 nums[m] &lt;= nums[h] 时，表示 [m, h]</p><p>区间内的数组是非递减数组，[l, m]</p><p>区间内的数组是旋转数组，此时令 h = m；</p><p>否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int findMixNumInRotateArray(int[] nums) &#123;</span><br><span class="line">       if (nums.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       int l &#x3D; 0, h &#x3D; nums.length - 1;</span><br><span class="line">       while (l &lt; h) &#123;</span><br><span class="line">           int m &#x3D; l + (h - 1) &#x2F; 2;</span><br><span class="line">           if (nums[m] &lt; nums[h]) &#123;</span><br><span class="line">               h &#x3D; m;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               l &#x3D; m + 1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return nums[l];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。</strong></p><p><em>例如对于数组{1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。</em> </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private int findMixNumInRotateArray2(int[] nums) &#123;</span><br><span class="line">     if (nums.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">         return 0;</span><br><span class="line">     &#125;</span><br><span class="line">     int l &#x3D; 0, h &#x3D; nums.length - 1;</span><br><span class="line">     while (l &lt; h) &#123;</span><br><span class="line">         int m &#x3D; l + (h - 1) &#x2F; 2;</span><br><span class="line">         if (nums[l] &#x3D;&#x3D; nums[m] || nums[m] &#x3D;&#x3D; nums[h]) &#123;</span><br><span class="line">             return minNums(nums, l, h);</span><br><span class="line">         &#125; else if (nums[m] &lt; nums[h]) &#123;</span><br><span class="line">             h &#x3D; m;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             l &#x3D; m + 1;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return nums[l];</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> private int minNums(int[] nums, int l, int h) &#123;</span><br><span class="line">     for (int i &#x3D; l; i &lt; h; i++) &#123;</span><br><span class="line">         if (nums[i] &gt; nums[i + 1]) &#123;</span><br><span class="line">             return nums[i + 1];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     return nums[l];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】1.1 斐波那契数列</title>
    <link href="https://eriecorner.github.io/2020/04/14/suan-fa/jian-zhi-offer/1.1-fei-bo-na-qi-shu-lie/"/>
    <id>https://eriecorner.github.io/2020/04/14/suan-fa/jian-zhi-offer/1.1-fei-bo-na-qi-shu-lie/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-05-18T13:30:55.135Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。n&lt;=39</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>斐波那契数列如：1,1,2,3,5,8,13…；所以得知F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li>递归实现 —— 时间复杂度O(2^n）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public long fibonacci(int n) &#123;</span><br><span class="line">       if (n &lt; 0) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">           return 1;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>顺序求法——时间复杂度O(n）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public long fibonacci2(int n) &#123;</span><br><span class="line">       long result &#x3D; 0;</span><br><span class="line">       long preOne &#x3D; 1;</span><br><span class="line">       long preTwo &#x3D; 1;</span><br><span class="line">       if (n &lt; 0) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">           return 1;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">           result &#x3D; preOne + preTwo;</span><br><span class="line">           preTwo &#x3D; preOne;</span><br><span class="line">           preOne &#x3D; result;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>状态矩阵相乘法——时间复杂度O(log n）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> public long fibonacci3(int n) &#123;</span><br><span class="line">        if (n &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;状态矩阵</span><br><span class="line">        int[][] base &#x3D; &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;</span><br><span class="line">        &#x2F;&#x2F;最后的结果需要求矩阵的n-2次</span><br><span class="line">        int[][] res &#x3D; matrixPower(base, n - 2);</span><br><span class="line">        return res[0][0] + res[1][0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;求矩阵m的p次幂的值</span><br><span class="line">    private int[][] matrixPower(int[][] m, int p) &#123;</span><br><span class="line">        int[][] res &#x3D; new int[m.length][m[0].length];</span><br><span class="line">        &#x2F;&#x2F;先把res设为单位矩阵，相当于整数中的1</span><br><span class="line">        for (int i &#x3D; 0; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i][i] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;临时矩阵</span><br><span class="line">        int[][] tmp &#x3D; m;</span><br><span class="line">        for (; p !&#x3D; 0; p &gt;&gt;&#x3D; 1) &#123;</span><br><span class="line">            if ((p &amp; 1) !&#x3D; 0) &#123;</span><br><span class="line">&#x2F;&#x2F;按位与操作，其实也就是位置为1的乘把这个矩阵乘一下</span><br><span class="line">                res &#x3D; muliMatrix(res, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;</span><br><span class="line">            &#x2F;&#x2F;等于0 的时候我临时矩阵自己乘一下</span><br><span class="line">            tmp &#x3D; muliMatrix(tmp, tmp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private int[][] muliMatrix(int[][] m1, int[][] m2) &#123;</span><br><span class="line">        &#x2F;&#x2F;构造出一个m1行和m2列的矩阵（矩阵相乘规则）</span><br><span class="line">        int[][] res &#x3D; new int[m1.length][m2[0].length];</span><br><span class="line">        &#x2F;&#x2F;给我们要得到的矩阵的每一个元素的值进行赋值操作</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m1.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; m2[0].length; j++) &#123;</span><br><span class="line">                for (int k &#x3D; 0; k &lt; m2.length; k++) &#123;</span><br><span class="line">&#x2F;&#x2F;i，j位置元素的值就是i行元素和j行元素乘积的加和</span><br><span class="line">                    res[i][j] +&#x3D; m1[i][k] * m2[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。n&amp;lt;=39&lt;/p&gt;
&lt;h2 id=&quot;题解：&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="斐波那契" scheme="https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】1.4 变态跳台阶问题</title>
    <link href="https://eriecorner.github.io/2020/04/14/suan-fa/jian-zhi-offer/1.4-bian-tai-tiao-tai-jie-wen-ti/"/>
    <id>https://eriecorner.github.io/2020/04/14/suan-fa/jian-zhi-offer/1.4-bian-tai-tiao-tai-jie-wen-ti/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-05-18T13:32:40.493Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级… 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><pre><code>  跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么f(n-1) = f(n-2) + f(n-3) + ... + f(0)；同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么  f(n) = f(n-1) + f(n-2) + ... + f(0)综上可得  f(n) - f(n-1) = f(n-1)即  f(n) = 2*f(n-1)</code></pre><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private int jumpFloorIn(int n) &#123;</span><br><span class="line">       return (int) Math.pow(2, n - 1);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h4&gt;&lt;p&gt;一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级… 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="斐波那契" scheme="https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】1.3 跳台阶问题</title>
    <link href="https://eriecorner.github.io/2020/04/14/suan-fa/jian-zhi-offer/1.3-tiao-tai-jie-wen-ti/"/>
    <id>https://eriecorner.github.io/2020/04/14/suan-fa/jian-zhi-offer/1.3-tiao-tai-jie-wen-ti/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-05-18T13:32:32.999Z</updated>
    
    <content type="html"><![CDATA[<h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述:"></a>题目描述:</h4><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><h4 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h4><p>f(1) = 1; f(2) = 2; n&gt;2则f(n) = f(n-1)+f(n-2)</p><h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private int jumpFloor(int n) &#123;</span><br><span class="line">        if (n &lt;&#x3D; 2) &#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int preOne &#x3D; 2, preTwo &#x3D; 1, result &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            result &#x3D; preOne + preTwo;</span><br><span class="line">            preTwo &#x3D; preOne;</span><br><span class="line">            preOne &#x3D; result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述:&quot;&gt;&lt;/a&gt;题目描述:&lt;/h4&gt;&lt;p&gt;一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。&lt;/p&gt;
&lt;h4 
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="斐波那契" scheme="https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
  </entry>
  
  <entry>
    <title>【剑指Offer】1.2 矩形覆盖问题</title>
    <link href="https://eriecorner.github.io/2020/04/14/suan-fa/jian-zhi-offer/1.2-ju-xing-fu-gai-wen-ti/"/>
    <id>https://eriecorner.github.io/2020/04/14/suan-fa/jian-zhi-offer/1.2-ju-xing-fu-gai-wen-ti/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-05-18T13:32:28.179Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>f(1) = 1; f(2) = 2; n&gt;2则f(n) = f(n-1)+f(n-2)</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int coverRect(int n) &#123;</span><br><span class="line">        if (n &lt;&#x3D; 2) &#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int preOne &#x3D; 2, preTwo &#x3D; 1, result &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            result &#x3D; preOne + preTwo;</span><br><span class="line">            preTwo &#x3D; preOne;</span><br><span class="line">            preOne &#x3D; result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="斐波那契" scheme="https://eriecorner.github.io/tags/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/"/>
    
  </entry>
  
</feed>
