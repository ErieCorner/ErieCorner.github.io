<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>紫依卓兰</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://eriecorner.github.io/"/>
  <updated>2020-05-18T14:19:10.311Z</updated>
  <id>https://eriecorner.github.io/</id>
  
  <author>
    <name>紫依卓兰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【LeetCode】152. 乘积最大子数组</title>
    <link href="https://eriecorner.github.io/2020/05/18/suan-fa/leetcode/152.cheng-ji-zui-da-zi-shu-zu/"/>
    <id>https://eriecorner.github.io/2020/05/18/suan-fa/leetcode/152.cheng-ji-zui-da-zi-shu-zu/</id>
    <published>2020-05-17T16:00:00.000Z</published>
    <updated>2020-05-18T14:19:10.311Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li><p>题目来源： <a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">LeetCode</a></p></li><li><p>题目描述： 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</p></li><li><p>示例</p></li></ul><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-2,-9,-6]</span><br><span class="line">输出: 108</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2></li></ul><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度<code>$O()$</code>：</li><li>空间复杂度<code>$O()$</code>：</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/maxim
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】53. 最大子序和</title>
    <link href="https://eriecorner.github.io/2020/05/18/suan-fa/leetcode/53.zui-da-zi-xu-he/"/>
    <id>https://eriecorner.github.io/2020/05/18/suan-fa/leetcode/53.zui-da-zi-xu-he/</id>
    <published>2020-05-17T16:00:00.000Z</published>
    <updated>2020-05-18T14:20:14.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li><p>题目来源： <a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">LeetCode</a></p></li><li><p>题目描述： 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p></li><li><p>示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2></li></ul><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度<code>$O()$</code>：</li><li>空间复杂度<code>$O()$</code>：</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/maxim
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp源码解析（Kotlin版）</title>
    <link href="https://eriecorner.github.io/2020/05/17/san-fang-kuang-jia-yuan-ma-jie-xi/okhttp-kotlin-ban-yuan-ma-jie-xi/"/>
    <id>https://eriecorner.github.io/2020/05/17/san-fang-kuang-jia-yuan-ma-jie-xi/okhttp-kotlin-ban-yuan-ma-jie-xi/</id>
    <published>2020-05-17T13:34:27.475Z</published>
    <updated>2020-05-18T13:26:55.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OkHttp 是一款非常优秀的网络请求框架，随着Kotlin语言的不断完善，OkHttp 自 4.0 版本开始使用Kotlin编写，对于巩固Kotlin语法知识及实践，研读OkHttp 4.0及以上版本的源码是一个不错的选择。</p><p>首先列出一些前置知识点：</p><ol><li><a href="https://www.kotlincn.net/docs/reference/android-overview.html" target="_blank" rel="noopener">Kotlin基础知识</a></li><li><a href="https://developer.android.google.cn/kotlin/learn" target="_blank" rel="noopener">Kotlin学习平台</a></li><li><a href="https://www.cnblogs.com/xiaomage666/p/11918864.html" target="_blank" rel="noopener">网络请求响应码含义</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1xx：信息，请求收到，继续处理</span><br><span class="line">2xx：成功，行为被成功地接受、理解和采纳</span><br><span class="line">3xx：重定向，为了完成请求，必须进一步执行的动作</span><br><span class="line">4xx：客户端错误，请求包含语法错误或者请求无法实现</span><br><span class="line">5xx：服务器错误，服务器不能实现一种明显无效的请求</span><br></pre></td></tr></table></figure></li><li><a href="https://www.cnblogs.com/ranyonsue/p/8918908.html" target="_blank" rel="noopener">Http缓存机制</a></li></ol><h2 id="OkHttp的基本使用"><a href="#OkHttp的基本使用" class="headerlink" title="OkHttp的基本使用"></a>OkHttp的基本使用</h2><ul><li>首先添加依赖库（去官网找最新的或想要的版本）</li><li>Http 请求有多种类型，常用的分为 Get 和 Post，而 POST 又分为 Form 和 Multiple 等，下面我们以Get请求为例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.创建OkHttpClient 对象，</span><br><span class="line">&#x2F;&#x2F; var client &#x3D; OkHttpClient();&#x2F;&#x2F;方式一</span><br><span class="line"> &#x2F;&#x2F;方式二：</span><br><span class="line"> val client &#x3D; OkHttpClient.Builder().readTimeout(5, TimeUnit.SECONDS).build()</span><br><span class="line"> &#x2F;&#x2F;2.创建请求对象并添加请求参数信息</span><br><span class="line"> val request &#x3D; Request.Builder().url(&quot;&quot;).build()</span><br><span class="line"> &#x2F;&#x2F;3.构建进行请求操作的call对象</span><br><span class="line"> val call &#x3D; client.newCall(request)</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;同步请求 Call （RealCall）—&gt;execute() 返回response</span><br><span class="line"> &#x2F;&#x2F; val response &#x3D; client.newCall(request).execute()</span><br><span class="line"> &#x2F;&#x2F;异步请求 Call （RealCall）—&gt;enqueue()</span><br><span class="line"> call.enqueue(</span><br><span class="line">         object : Callback &#123;</span><br><span class="line">             override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line">                 println(e.stackTrace.toString())</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             @Throws(IOException::class)</span><br><span class="line">             override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">                 println(response.body.toString())</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;)</span><br></pre></td></tr></table></figure></li><li>首先使用OkHttpClint的构造<code>OkHttpClient()</code>或者Build模式构建一个OkHttpClint的对象实例；</li><li>使用构建者模式构建一个Request对象，通过OkHttpClient和Request对象，构建出Call对象；</li><li>执行call的<code>enqueue()</code>或者<code>execute()</code>。</li></ul><p><strong>注意</strong>：在实际开发中建议将OkHttpClint对象的创建封装成单列， 因为每个 OkHttpClient 对象都管理自己独有的线程池和连接池，复用连接池和线程池能够减少延迟、节省内存。</p><h2 id="OkHttp-源码分析"><a href="#OkHttp-源码分析" class="headerlink" title="OkHttp 源码分析"></a>OkHttp 源码分析</h2><h4 id="一-OkHttpClient"><a href="#一-OkHttpClient" class="headerlink" title="一. OkHttpClient"></a>一. OkHttpClient</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">constructor() : this(Builder())</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;这里是默认的参数设置</span><br><span class="line">class Builder constructor() &#123;</span><br><span class="line">   internal var dispatcher: Dispatcher &#x3D; Dispatcher()&#x2F;&#x2F;调度器，通过双端队列保存Calls（同步&amp;异步Call）</span><br><span class="line">   internal var connectionPool: ConnectionPool &#x3D; ConnectionPool()&#x2F;&#x2F;链接池</span><br><span class="line">   internal val interceptors: MutableList&lt;Interceptor&gt; &#x3D; mutableListOf()&#x2F;&#x2F;拦截器</span><br><span class="line">   internal val networkInterceptors: MutableList&lt;Interceptor&gt; &#x3D; mutableListOf()&#x2F;&#x2F;网络拦截器</span><br><span class="line">   internal var eventListenerFactory: EventListener.Factory &#x3D; EventListener.NONE.asFactory()&#x2F;&#x2F;一个Call的状态监听器</span><br><span class="line">   internal var retryOnConnectionFailure &#x3D; true</span><br><span class="line">   internal var authenticator: Authenticator &#x3D; Authenticator.NONE</span><br><span class="line">   internal var followRedirects &#x3D; true</span><br><span class="line">   internal var followSslRedirects &#x3D; true</span><br><span class="line">   internal var cookieJar: CookieJar &#x3D; CookieJar.NO_COOKIES&#x2F;&#x2F;默认没有Cookie</span><br><span class="line">   internal var cache: Cache? &#x3D; null</span><br><span class="line">   internal var dns: Dns &#x3D; Dns.SYSTEM&#x2F;&#x2F;域名解析系统 domain name -&gt; ip address</span><br><span class="line">   internal var proxy: Proxy? &#x3D; null</span><br><span class="line">   internal var proxySelector: ProxySelector? &#x3D; null&#x2F;&#x2F;使用默认的代理选择器</span><br><span class="line">   internal var proxyAuthenticator: Authenticator &#x3D; Authenticator.NONE</span><br><span class="line">   internal var socketFactory: SocketFactory &#x3D; SocketFactory.getDefault()&#x2F;&#x2F;默认的Socket 工厂生产Socket </span><br><span class="line">   internal var sslSocketFactoryOrNull: SSLSocketFactory? &#x3D; null</span><br><span class="line">   internal var x509TrustManagerOrNull: X509TrustManager? &#x3D; null</span><br><span class="line">   internal var connectionSpecs: List&lt;ConnectionSpec&gt; &#x3D; DEFAULT_CONNECTION_SPECS&#x2F;&#x2F;OKHttp连接（Connection）配置</span><br><span class="line">   internal var protocols: List&lt;Protocol&gt; &#x3D; DEFAULT_PROTOCOLS</span><br><span class="line">   internal var hostnameVerifier: HostnameVerifier &#x3D; OkHostnameVerifier</span><br><span class="line">   internal var certificatePinner: CertificatePinner &#x3D; CertificatePinner.DEFAULT</span><br><span class="line">   internal var certificateChainCleaner: CertificateChainCleaner? &#x3D; null</span><br><span class="line">   internal var callTimeout &#x3D; 0</span><br><span class="line">   internal var connectTimeout &#x3D; 10_000</span><br><span class="line">   internal var readTimeout &#x3D; 10_000</span><br><span class="line">   internal var writeTimeout &#x3D; 10_000</span><br><span class="line">   internal var pingInterval &#x3D; 0&#x2F;&#x2F;和WebSocket有关,为了保持长连接，我们必须间隔一段时间发送一个ping指令进行保活</span><br><span class="line">   internal var minWebSocketMessageToCompress &#x3D; RealWebSocket.DEFAULT_MINIMUM_DEFLATE_SIZE</span><br><span class="line">   internal var routeDatabase: RouteDatabase? &#x3D; null</span><br></pre></td></tr></table></figure><p><strong>connectionSpecs：</strong>   OKHttp连接（Connection）配置 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">companion object &#123;</span><br><span class="line">    internal val DEFAULT_PROTOCOLS &#x3D; immutableListOf(HTTP_2, HTTP_1_1)</span><br><span class="line"></span><br><span class="line">    internal val DEFAULT_CONNECTION_SPECS &#x3D; immutableListOf(</span><br><span class="line">        ConnectionSpec.MODERN_TLS, ConnectionSpec.CLEARTEXT)</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">   &#x2F;**</span><br><span class="line">     * A modern TLS configuration that works on most client platforms and can connect to most servers.</span><br><span class="line">     * This is OkHttp&#39;s default configuration.</span><br><span class="line">     *&#x2F;</span><br><span class="line">     &#x2F;&#x2F;针对TLS的， 是OkHttp 的默认配置</span><br><span class="line">   @JvmField</span><br><span class="line">    val MODERN_TLS &#x3D; Builder(true)</span><br><span class="line">        .cipherSuites(*APPROVED_CIPHER_SUITES)</span><br><span class="line">        .tlsVersions(TlsVersion.TLS_1_3, TlsVersion.TLS_1_2)</span><br><span class="line">        .supportsTlsExtensions(true)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#x2F;** URL的未经加密，未经身份验证的连接 *&#x2F;</span><br><span class="line">    @JvmField</span><br><span class="line">    val CLEARTEXT &#x3D; Builder(false).build()</span><br></pre></td></tr></table></figure><h4 id="二-同步请求流程分析"><a href="#二-同步请求流程分析" class="headerlink" title="二. 同步请求流程分析"></a>二. 同步请求流程分析</h4><p>以下代码为同步请求流程中的核心代码，按照调用次序呈现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F;  1.</span><br><span class="line">  val response &#x3D; client.newCall(request).execute()</span><br><span class="line">  &#x2F;&#x2F;  2.</span><br><span class="line">   &#x2F;** Prepares the [request] to be executed at some point in the future. *&#x2F;</span><br><span class="line">  override fun newCall(request: Request): Call &#x3D; RealCall(this, request, forWebSocket &#x3D; false)</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;RealCall的execute()</span><br><span class="line">  &#x2F;&#x2F;  3. 真正执行请求的是在call的实现类 RealCall的execute()中</span><br><span class="line">   override fun execute(): Response &#123;</span><br><span class="line">   &#x2F;&#x2F;标记请求执行状态：一个请求只能执行一次</span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">      check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">      executed &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">    timeout.enter()</span><br><span class="line">    callStart()</span><br><span class="line">    try &#123;</span><br><span class="line">     &#x2F;&#x2F; 4. 通知dispatcher已经进入执行状态</span><br><span class="line">      client.dispatcher.executed(this)</span><br><span class="line">      &#x2F;&#x2F; 5. 通过连接器的链式调用进行请求处理并返回最终响应结果</span><br><span class="line">      return getResponseWithInterceptorChain()</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; 6. 通知dispatcher自己已执行完毕</span><br><span class="line">      client.dispatcher.finished(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   &#x2F;&#x2F;4 . dispatcher.executed()</span><br><span class="line">  &#x2F;** Used by &#96;Call#execute&#96; to signal it is in-flight. *&#x2F;</span><br><span class="line">  @Synchronized internal fun executed(call: RealCall) &#123;</span><br><span class="line">    runningSyncCalls.add(call)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;Dispatcher中维护的ArrayDeque</span><br><span class="line">   &#x2F;** 准备执行的异步请求队列. *&#x2F;</span><br><span class="line">  private val readyAsyncCalls &#x3D; ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line">  &#x2F;** 正在执行的异步请求队列 *&#x2F;</span><br><span class="line">  private val runningAsyncCalls &#x3D; ArrayDeque&lt;AsyncCall&gt;()</span><br><span class="line"></span><br><span class="line">  &#x2F;** 正在执行的同步请求队列 *&#x2F;</span><br><span class="line">  private val runningSyncCalls &#x3D; ArrayDeque&lt;RealCall&gt;()</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F;5 .RealCall的getResponseWithInterceptorChain()</span><br><span class="line">  @Throws(IOException::class)</span><br><span class="line">  internal fun getResponseWithInterceptorChain(): Response &#123;</span><br><span class="line">    &#x2F;&#x2F; Build a full stack of interceptors.</span><br><span class="line">    val interceptors &#x3D; mutableListOf&lt;Interceptor&gt;()</span><br><span class="line">    interceptors +&#x3D; client.interceptors&#x2F;&#x2F;用户在构建OkHttpClient是配置的连接器</span><br><span class="line">    interceptors +&#x3D; RetryAndFollowUpInterceptor(client)&#x2F;&#x2F;负责请求失败后的重试和重定向</span><br><span class="line">    interceptors +&#x3D; BridgeInterceptor(client.cookieJar)&#x2F;&#x2F;对请求和响应的参数进行必要的处理</span><br><span class="line">    interceptors +&#x3D; CacheInterceptor(client.cache)&#x2F;&#x2F;读取缓存数据返回、更新缓存</span><br><span class="line">    interceptors +&#x3D; ConnectInterceptor&#x2F;&#x2F;负责跟服务器的链接操作</span><br><span class="line">    if (!forWebSocket) &#123;</span><br><span class="line">    &#x2F;&#x2F;创建OkHttpClient时设置的networkInterceptor</span><br><span class="line">      interceptors +&#x3D; client.networkInterceptors</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;向服务器发送请求数据，读取响应数据</span><br><span class="line">    interceptors +&#x3D; CallServerInterceptor(forWebSocket)</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;将请求对象及OkHttpClient的一些配置封装在RealInterceptorChain中</span><br><span class="line">    val chain &#x3D; RealInterceptorChain(</span><br><span class="line">        call &#x3D; this,</span><br><span class="line">        interceptors &#x3D; interceptors,</span><br><span class="line">        index &#x3D; 0,</span><br><span class="line">        exchange &#x3D; null,</span><br><span class="line">        request &#x3D; originalRequest,</span><br><span class="line">        connectTimeoutMillis &#x3D; client.connectTimeoutMillis,</span><br><span class="line">        readTimeoutMillis &#x3D; client.readTimeoutMillis,</span><br><span class="line">        writeTimeoutMillis &#x3D; client.writeTimeoutMillis</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    var calledNoMoreExchanges &#x3D; false</span><br><span class="line">    try &#123;</span><br><span class="line">    &#x2F;&#x2F;开启链式调用</span><br><span class="line">      val response &#x3D; chain.proceed(originalRequest)</span><br><span class="line">      if (isCanceled()) &#123;</span><br><span class="line">        response.closeQuietly()</span><br><span class="line">        throw IOException(&quot;Canceled&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      return response</span><br><span class="line">    &#125; catch (e: IOException) &#123;</span><br><span class="line">      calledNoMoreExchanges &#x3D; true</span><br><span class="line">      throw noMoreExchanges(e) as Throwable</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (!calledNoMoreExchanges) &#123;</span><br><span class="line">        noMoreExchanges(null)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;7. RealInterceptorChain的proceed()</span><br><span class="line">@Throws(IOException::class)</span><br><span class="line">  override fun proceed(request: Request): Response &#123;</span><br><span class="line">    check(index &lt; interceptors.size)</span><br><span class="line"></span><br><span class="line">    calls++</span><br><span class="line"></span><br><span class="line">    if (exchange !&#x3D; null) &#123;</span><br><span class="line">      check(exchange.finder.sameHostAndPort(request.url)) &#123;</span><br><span class="line">        &quot;network interceptor $&#123;interceptors[index - 1]&#125; must retain the same host and port&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      check(calls &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &quot;network interceptor $&#123;interceptors[index - 1]&#125; must call proceed() exactly once&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Call the next interceptor in the chain. 实例化下一个拦截器</span><br><span class="line">    val next &#x3D; copy(index &#x3D; index + 1, request &#x3D; request)</span><br><span class="line">    &#x2F;&#x2F;获取当前拦截器</span><br><span class="line">    val interceptor &#x3D; interceptors[index]</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;调用当前拦截器的intercept(),并将下一个拦截器的RealIterceptorChain对象传递下去,最后返回响应结果</span><br><span class="line">    @Suppress(&quot;USELESS_ELVIS&quot;)</span><br><span class="line">    val response &#x3D; interceptor.intercept(next) ?: throw NullPointerException(</span><br><span class="line">        &quot;interceptor $interceptor returned null&quot;)</span><br><span class="line"></span><br><span class="line">    if (exchange !&#x3D; null) &#123;</span><br><span class="line">      check(index + 1 &gt;&#x3D; interceptors.size || next.calls &#x3D;&#x3D; 1) &#123;</span><br><span class="line">        &quot;network interceptor $interceptor must call proceed() exactly once&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    check(response.body !&#x3D; null) &#123; &quot;interceptor $interceptor returned a response with no body&quot; &#125;</span><br><span class="line"></span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="三-异步请求流程分析"><a href="#三-异步请求流程分析" class="headerlink" title="三. 异步请求流程分析"></a>三. 异步请求流程分析</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F;1. 异步请求 Call （RealCall）—&gt;enqueue()</span><br><span class="line">    client.newCall(request).enqueue(</span><br><span class="line">       object : Callback &#123;</span><br><span class="line">       override fun onFailure(call: Call, e: IOException) &#123;</span><br><span class="line">            println(e.stackTrace.toString())</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">          @Throws(IOException::class)</span><br><span class="line">             override fun onResponse(call: Call, response: Response) &#123;</span><br><span class="line">               println(response.body.toString())</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;)</span><br><span class="line">               </span><br><span class="line">    &#x2F;&#x2F;2. RealCall 的enqueue()     </span><br><span class="line">   override fun enqueue(responseCallback: Callback) &#123;</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">     check(!executed) &#123; &quot;Already Executed&quot; &#125;</span><br><span class="line">     executed &#x3D; true</span><br><span class="line">   &#125;</span><br><span class="line">   callStart()</span><br><span class="line">   client.dispatcher.enqueue(AsyncCall(responseCallback))</span><br><span class="line"> &#125;   </span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;3. dispatcher 的enqueue()</span><br><span class="line"> internal fun enqueue(call: AsyncCall) &#123;</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">   &#x2F;&#x2F;将请求添加到等待执行的异步请求队列中</span><br><span class="line">     readyAsyncCalls.add(call)</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F; Mutate the AsyncCall so that it shares the AtomicInteger of an existing running call to</span><br><span class="line">     &#x2F;&#x2F; the same host.</span><br><span class="line">     if (!call.call.forWebSocket) &#123;</span><br><span class="line">       val existingCall &#x3D; findExistingCallWithHost(call.host)</span><br><span class="line">       if (existingCall !&#x3D; null) call.reuseCallsPerHostFrom(existingCall)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   promoteAndExecute()</span><br><span class="line"> &#125;         </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">  * Promotes eligible calls from [readyAsyncCalls] to [runningAsyncCalls] and runs them on the</span><br><span class="line">  * executor service. Must not be called with synchronization because executing calls can call</span><br><span class="line">  * into user code.</span><br><span class="line">  *</span><br><span class="line">  * @return true if the dispatcher is currently running calls.</span><br><span class="line">  *&#x2F;</span><br><span class="line">  &#x2F;&#x2F;4. 不断从readyAsyncCalls中取出要执行的请求放到runningAsyncCalls中，并将readyAsyncCalls中的移除</span><br><span class="line"> private fun promoteAndExecute(): Boolean &#123;</span><br><span class="line">   this.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">   val executableCalls &#x3D; mutableListOf&lt;AsyncCall&gt;()</span><br><span class="line">   val isRunning: Boolean</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">     val i &#x3D; readyAsyncCalls.iterator()</span><br><span class="line">     while (i.hasNext()) &#123;</span><br><span class="line">       val asyncCall &#x3D; i.next()</span><br><span class="line">       </span><br><span class="line">    &#x2F;&#x2F; 如果其中的runningAsynCalls不满，且call占用的host小于最大数量，则将call加入到runningAsyncCalls中执行，</span><br><span class="line">  </span><br><span class="line">       if (runningAsyncCalls.size &gt;&#x3D; this.maxRequests) break &#x2F;&#x2F; Max capacity.</span><br><span class="line">       if (asyncCall.callsPerHost.get() &gt;&#x3D; this.maxRequestsPerHost) continue &#x2F;&#x2F; Host max capacity.</span><br><span class="line"></span><br><span class="line">       i.remove()</span><br><span class="line">       asyncCall.callsPerHost.incrementAndGet()</span><br><span class="line">       executableCalls.add(asyncCall)</span><br><span class="line">       runningAsyncCalls.add(asyncCall)</span><br><span class="line">     &#125;</span><br><span class="line">     isRunning &#x3D; runningCallsCount() &gt; 0</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   for (i in 0 until executableCalls.size) &#123;</span><br><span class="line">     val asyncCall &#x3D; executableCalls[i]</span><br><span class="line">      &#x2F;&#x2F; 利用线程池执行call</span><br><span class="line">     asyncCall.executeOn(executorService)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return isRunning</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>异步请求的dispatcher.enqueue(AsyncCall)中传入是call 是一个AsyncCall，接下来看AsyncCall的实现.它是RealCall的内部类，实际是一个Runnable。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">internal inner class AsyncCall(</span><br><span class="line">  private val responseCallback: Callback</span><br><span class="line">) : Runnable &#123;</span><br><span class="line">  @Volatile var callsPerHost &#x3D; AtomicInteger(0)</span><br><span class="line">    private set</span><br><span class="line"></span><br><span class="line">  fun reuseCallsPerHostFrom(other: AsyncCall) &#123;</span><br><span class="line">    this.callsPerHost &#x3D; other.callsPerHost</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val host: String</span><br><span class="line">    get() &#x3D; originalRequest.url.host</span><br><span class="line"></span><br><span class="line">  val request: Request</span><br><span class="line">      get() &#x3D; originalRequest</span><br><span class="line"></span><br><span class="line">  val call: RealCall</span><br><span class="line">      get() &#x3D; this@RealCall</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Attempt to enqueue this async call on [executorService]. This will attempt to clean up</span><br><span class="line">   * if the executor has been shut down by reporting the call as failed.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  fun executeOn(executorService: ExecutorService) &#123;</span><br><span class="line">    client.dispatcher.assertThreadDoesntHoldLock()</span><br><span class="line"></span><br><span class="line">    var success &#x3D; false</span><br><span class="line">    try &#123;</span><br><span class="line">    &#x2F;&#x2F;在线程迟中执行</span><br><span class="line">      executorService.execute(this)</span><br><span class="line">      success &#x3D; true</span><br><span class="line">    &#125; catch (e: RejectedExecutionException) &#123;</span><br><span class="line">      val ioException &#x3D; InterruptedIOException(&quot;executor rejected&quot;)</span><br><span class="line">      ioException.initCause(e)</span><br><span class="line">      noMoreExchanges(ioException)</span><br><span class="line">      responseCallback.onFailure(this@RealCall, ioException)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      if (!success) &#123;</span><br><span class="line">        client.dispatcher.finished(this) &#x2F;&#x2F; This call is no longer running!</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override fun run() &#123;</span><br><span class="line">    threadName(&quot;OkHttp $&#123;redactedUrl()&#125;&quot;) &#123;</span><br><span class="line">      var signalledCallback &#x3D; false</span><br><span class="line">      timeout.enter()</span><br><span class="line">      try &#123;</span><br><span class="line">      &#x2F;&#x2F;最终进行拦截器的链式调用来处理请求并返回最终的响应结果</span><br><span class="line">        val response &#x3D; getResponseWithInterceptorChain()</span><br><span class="line">        signalledCallback &#x3D; true</span><br><span class="line">        responseCallback.onResponse(this@RealCall, response)</span><br><span class="line">      &#125; catch (e: IOException) &#123;</span><br><span class="line">        if (signalledCallback) &#123;</span><br><span class="line">          &#x2F;&#x2F; Do not signal the callback twice!</span><br><span class="line">          Platform.get().log(&quot;Callback failure for $&#123;toLoggableString()&#125;&quot;, Platform.INFO, e)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          responseCallback.onFailure(this@RealCall, e)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch (t: Throwable) &#123;</span><br><span class="line">        cancel()</span><br><span class="line">        if (!signalledCallback) &#123;</span><br><span class="line">          val canceledException &#x3D; IOException(&quot;canceled due to $t&quot;)</span><br><span class="line">          canceledException.addSuppressed(t)</span><br><span class="line">          responseCallback.onFailure(this@RealCall, canceledException)</span><br><span class="line">        &#125;</span><br><span class="line">        throw t</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        client.dispatcher.finished(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过源码看到Dispatcher维护了三个ArrayDeque，一个保存了正在执行的同步任务；一个保存异步正在执行的请求，另一个是异步等待执行的请求，异步右两个ArrayDeque是因为Dispatcher默认支持最大的并发请求是64个，单个Host最多执行5个并发请求，如果超过，则Call会先被放入到readyAsyncCall中，当出现空闲的线程时，再将readyAsyncCall中的线程移入到runningAsynCalls中，执行请求。</p></li><li><p>通过拦截器链处理，得到响应结果后执行finally中的代码<code>dispatcher.finished(this)</code>，<br>现在来看下这个方法，走到这，一个请求流程就结束了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** Used by [AsyncCall.run] to signal completion. *&#x2F;</span><br><span class="line">&#x2F;&#x2F;异步请求时调用</span><br><span class="line"> internal fun finished(call: AsyncCall) &#123;</span><br><span class="line">   call.callsPerHost.decrementAndGet()</span><br><span class="line">   finished(runningAsyncCalls, call)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> &#x2F;** Used by [Call.execute] to signal completion. *&#x2F;</span><br><span class="line"> &#x2F;&#x2F;同步请求时调用</span><br><span class="line"> internal fun finished(call: RealCall) &#123;</span><br><span class="line">   finished(runningSyncCalls, call)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F;最终都调用这个方法</span><br><span class="line"> private fun &lt;T&gt; finished(calls: Deque&lt;T&gt;, call: T) &#123;</span><br><span class="line">   val idleCallback: Runnable?</span><br><span class="line">   synchronized(this) &#123;</span><br><span class="line">   &#x2F;&#x2F;将当前call从其队列中移除</span><br><span class="line">     if (!calls.remove(call)) throw AssertionError(&quot;Call wasn&#39;t in-flight!&quot;)</span><br><span class="line">     idleCallback &#x3D; this.idleCallback</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   val isRunning &#x3D; promoteAndExecute()</span><br><span class="line"></span><br><span class="line">   if (!isRunning &amp;&amp; idleCallback !&#x3D; null) &#123;</span><br><span class="line">     idleCallback.run()</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>总结</strong>：网络请求是从<code>OkHttpClient().newCall(request)</code>开始的，通过创建的OkHttpClient对象和Request对象，构建出一个RealCall对象来执行网络请求，同步请求是在<code>RealCall</code>的<code>execute()</code>方法中，异步请求是在<code>enqueue()</code>中，在这两个方法中都用<code>OkHttpClient</code>对象的<code>dispatcher</code>执行对应的请求方法。对于同步请求，<code>dispatcher</code>的<code>execute()</code>就是将请求加入到<code>runningSyncCalls</code>这个双端队列中；对于异步请求，<code>dispatcher</code>进行请求的分发执行。在<code>dispatcher</code>将请求分发后调用<code>getResponseWithInterceptorChain()</code>方法，在这里，==依次==将<code>client.interceptorsRetryAndFollowUpInterceptor、BridgeInterceptor、CacheInterceptor、ConnectInterceptor、client.networkInterceptors和CallServerInterceptor</code>添加到一个集合中，并创建出一个拦截器链<code>RealInterceptorChain</code>，通过<code>RealInterceptorChain.proceed()</code>使每一个拦截器执行完毕之后会调用下一个拦截器或者不调用并返回结果。显然，我们最终拿到的响应就是这个链条执行之后返回的结果。</p><ul><li>整体的请求流程图如下：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgkr.cn-bj.ufileos.com/3b02ef84-73e7-45e1-8d74-109685d48deb.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h4 id="四-OkHttp内置拦截器源码分析"><a href="#四-OkHttp内置拦截器源码分析" class="headerlink" title="四.OkHttp内置拦截器源码分析"></a>四.OkHttp内置拦截器源码分析</h4><h4 id="1-RetryAndFollowUpInterceptor"><a href="#1-RetryAndFollowUpInterceptor" class="headerlink" title="1. RetryAndFollowUpInterceptor"></a>1. RetryAndFollowUpInterceptor</h4><p>这个拦截器负责重试和重定向，当一个请求由于各种原因失败了，如果是路由或者连接异常，则尝试恢复，否则，根据响应码（ResponseCode）,followup方法会对Request进行再处理以得到新的Request，然后沿着拦截器链继续新的Request；当尝试次数超过最大次数就抛出异常。代码逻辑相对比较简单，这里就不贴出来了。</p><h4 id="2-BridgeInterceptor"><a href="#2-BridgeInterceptor" class="headerlink" title="2. BridgeInterceptor"></a>2. BridgeInterceptor</h4><p>负责将用户请求转换为网络请求，也就是根据 Request 信息组建请求 Header 以及设置响应数据，包括设置 Cookie 以及gzip。源码就不贴出来了。</p><h4 id="3-CacheInterceptor"><a href="#3-CacheInterceptor" class="headerlink" title="3. CacheInterceptor"></a>3. CacheInterceptor</h4><p>负责根据请求的信息和缓存的响应的信息来判断是否存在可用的缓存，读取缓存直接返回、否则就继续使用责任链模式来从服务器中获取响应。当获取到响应的时候，更新缓存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line">@Throws(IOException::class)</span><br><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line"> &#x2F;&#x2F;从缓存中获取</span><br><span class="line">  val cacheCandidate &#x3D; cache?.get(chain.request())</span><br><span class="line"></span><br><span class="line">  val now &#x3D; System.currentTimeMillis()</span><br><span class="line"> &#x2F;&#x2F;缓存策略，决定使用缓存还是从网络获取</span><br><span class="line">  val strategy &#x3D; CacheStrategy.Factory(now, chain.request(), cacheCandidate).compute()</span><br><span class="line">  val networkRequest &#x3D; strategy.networkRequest</span><br><span class="line">  val cacheResponse &#x3D; strategy.cacheResponse</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;根据缓存策略，更新统计指标：请求次数、使用网络请求次数、使用缓存次数</span><br><span class="line">  cache?.trackResponse(strategy)</span><br><span class="line">   &#x2F;&#x2F;若缓存不可用，关闭</span><br><span class="line">  if (cacheCandidate !&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">    &#x2F;&#x2F; The cache candidate wasn&#39;t applicable. Close it.</span><br><span class="line">    cacheCandidate.body?.closeQuietly()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If we&#39;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">  &#x2F;&#x2F;如果既无网络请求可用，又没有缓存，则返回504错误</span><br><span class="line">  if (networkRequest &#x3D;&#x3D; null &amp;&amp; cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(HTTP_GATEWAY_TIMEOUT)</span><br><span class="line">        .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">        .body(EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-1L)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If we don&#39;t need the network, we&#39;re done.</span><br><span class="line">  &#x2F;&#x2F;缓存可用，则返回缓存中数据</span><br><span class="line">  if (networkRequest &#x3D;&#x3D; null) &#123;</span><br><span class="line">    return cacheResponse!!.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var networkResponse: Response? &#x3D; null</span><br><span class="line">  try &#123;</span><br><span class="line">  &#x2F;&#x2F;进行网络请求，返回请求结果</span><br><span class="line">    networkResponse &#x3D; chain.proceed(networkRequest)</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; If we&#39;re crashing on I&#x2F;O or otherwise, don&#39;t leak the cache body.</span><br><span class="line">    if (networkResponse &#x3D;&#x3D; null &amp;&amp; cacheCandidate !&#x3D; null) &#123;</span><br><span class="line">      cacheCandidate.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; If we have a cache response too, then we&#39;re doing a conditional get.</span><br><span class="line">  &#x2F;&#x2F;HTTP_NOT_MODIFIED缓存有效，合并网络请求和缓存</span><br><span class="line">  if (cacheResponse !&#x3D; null) &#123;</span><br><span class="line">    if (networkResponse?.code &#x3D;&#x3D; HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      val response &#x3D; cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers, networkResponse.headers))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis)</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis)</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build()</span><br><span class="line"></span><br><span class="line">      networkResponse.body!!.close()</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; Update the cache after combining headers but before stripping the</span><br><span class="line">      &#x2F;&#x2F; Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">      cache!!.trackConditionalCacheHit()</span><br><span class="line">      cache.update(cacheResponse, response)&#x2F;&#x2F;更新缓存</span><br><span class="line">      return response</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      cacheResponse.body?.closeQuietly()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  val response &#x3D; networkResponse!!.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build()</span><br><span class="line">  &#x2F;&#x2F;允许缓存且请求结果不为空，则写入缓存</span><br><span class="line">  if (cache !&#x3D; null) &#123;</span><br><span class="line">    if (response.promisesBody() &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      &#x2F;&#x2F; Offer this request to the cache.</span><br><span class="line">      val cacheRequest &#x3D; cache.put(response)</span><br><span class="line">      return cacheWritingResponse(cacheRequest, response)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cache.remove(networkRequest)</span><br><span class="line">      &#125; catch (_: IOException) &#123;</span><br><span class="line">        &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &#x2F;&#x2F;  CacheStrategy中的核心方法 computeCandidate()</span><br><span class="line">   </span><br><span class="line">  &#x2F;** Returns a strategy to use assuming the request can use the network. *&#x2F;</span><br><span class="line">  private fun computeCandidate(): CacheStrategy &#123;</span><br><span class="line">    &#x2F;&#x2F; No cached response. 没有缓存，直接进行网络请求</span><br><span class="line">    if (cacheResponse &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Drop the cached response if it&#39;s missing a required handshake. 是https请求，但是没有握手，进行网络请求</span><br><span class="line">    if (request.isHttps &amp;&amp; cacheResponse.handshake &#x3D;&#x3D; null) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If this response shouldn&#39;t have been stored, it should never be used as a response source.</span><br><span class="line">    &#x2F;&#x2F; This check should be redundant as long as the persistence store is well-behaved and the</span><br><span class="line">    &#x2F;&#x2F; rules are constant.</span><br><span class="line">    &#x2F;&#x2F;不能进行缓存</span><br><span class="line">    if (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val requestCaching &#x3D; request.cacheControl</span><br><span class="line">      &#x2F;&#x2F;请求头nocache或者请求头包含If-Modified-Since或者If-None-Match(意味着本地缓存过期，需要服务器验证本地缓存是不是还能继续使用)</span><br><span class="line">    if (requestCaching.noCache || hasConditions(request)) &#123;</span><br><span class="line">      return CacheStrategy(request, null)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val responseCaching &#x3D; cacheResponse.cacheControl</span><br><span class="line"></span><br><span class="line">    val ageMillis &#x3D; cacheResponseAge()</span><br><span class="line">    var freshMillis &#x3D; computeFreshnessLifetime()</span><br><span class="line"></span><br><span class="line">    if (requestCaching.maxAgeSeconds !&#x3D; -1) &#123;</span><br><span class="line">      freshMillis &#x3D; minOf(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds.toLong()))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var minFreshMillis: Long &#x3D; 0</span><br><span class="line">    if (requestCaching.minFreshSeconds !&#x3D; -1) &#123;</span><br><span class="line">      minFreshMillis &#x3D; SECONDS.toMillis(requestCaching.minFreshSeconds.toLong())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var maxStaleMillis: Long &#x3D; 0</span><br><span class="line">    if (!responseCaching.mustRevalidate &amp;&amp; requestCaching.maxStaleSeconds !&#x3D; -1) &#123;</span><br><span class="line">      maxStaleMillis &#x3D; SECONDS.toMillis(requestCaching.maxStaleSeconds.toLong())</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;缓存过期了，但仍然可用，给相应头中添加了Warning，使用缓存</span><br><span class="line">    if (!responseCaching.noCache &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">      val builder &#x3D; cacheResponse.newBuilder()</span><br><span class="line">      if (ageMillis + minFreshMillis &gt;&#x3D; freshMillis) &#123;</span><br><span class="line">        builder.addHeader(&quot;Warning&quot;, &quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      val oneDayMillis &#x3D; 24 * 60 * 60 * 1000L</span><br><span class="line">      if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">        builder.addHeader(&quot;Warning&quot;, &quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">      return CacheStrategy(null, builder.build())&#x2F;&#x2F;使用缓存</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Find a condition to add to the request. If the condition is satisfied, the response body</span><br><span class="line">    &#x2F;&#x2F; will not be transmitted.</span><br><span class="line">    val conditionName: String</span><br><span class="line">    val conditionValue: String?</span><br><span class="line">    &#x2F;&#x2F;流程走到这，说明缓存已经过期了</span><br><span class="line">    &#x2F;&#x2F;添加请求头：If-Modified-Since或者If-None-Match</span><br><span class="line">    &#x2F;&#x2F;etag与If-None-Match配合使用</span><br><span class="line">    &#x2F;&#x2F;lastModified与If-Modified-Since配合使用</span><br><span class="line">    &#x2F;&#x2F;前者和后者的值是相同的</span><br><span class="line">    &#x2F;&#x2F;区别在于前者是响应头，后者是请求头。</span><br><span class="line">    &#x2F;&#x2F;后者用于服务器进行资源比对，看看是资源是否改变了。</span><br><span class="line">    &#x2F;&#x2F; 如果没有，则本地的资源虽过期还是可以用的</span><br><span class="line">    when &#123;</span><br><span class="line">      etag !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-None-Match&quot;</span><br><span class="line">        conditionValue &#x3D; etag</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      lastModified !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-Modified-Since&quot;</span><br><span class="line">        conditionValue &#x3D; lastModifiedString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      servedDate !&#x3D; null -&gt; &#123;</span><br><span class="line">        conditionName &#x3D; &quot;If-Modified-Since&quot;</span><br><span class="line">        conditionValue &#x3D; servedDateString</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      else -&gt; return CacheStrategy(request, null) &#x2F;&#x2F; No condition! Make a regular request.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val conditionalRequestHeaders &#x3D; request.headers.newBuilder()</span><br><span class="line">    conditionalRequestHeaders.addLenient(conditionName, conditionValue!!)</span><br><span class="line"></span><br><span class="line">    val conditionalRequest &#x3D; request.newBuilder()</span><br><span class="line">        .headers(conditionalRequestHeaders.build())</span><br><span class="line">        .build()</span><br><span class="line">    return CacheStrategy(conditionalRequest, cacheResponse)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上述CatchStragety.computeCandidate()方法可知，缓存策略如下：</p><pre><code>1. 没有缓存，直接网络请求；2. 如果是Https，没有进行握手，则进行网络请求；3. 设置了不可缓存，则进行网络请求；4. 请求头nocache或者请求头包含If-Modified-Since或者If-None-Match，则需要服务器验证本地缓存是不是还能继续使用，进行网络请求；5. 可以缓存，并且缓存过期过期了但是还可以使用，这时给响应头添加Warning后，使用缓存；6. 缓存已经过期，添加请求头：If-Modified-Since或者If-None-Match，进行网络请求；</code></pre><p>整个CatcheIncepter的执行依靠CatchStragety的缓存策略，代码中添加了注释，这里整理下流程如下：</p><pre><code>1. 如果网络不可用并且无可用的有效缓存，则返回504错误；2. 如果禁止了网络请求，则直接使用缓存；3. 如果没有缓存且网络请求可用，则进行网络请求；4. 如果此时有缓存，并且网络请求返回HTTP_NOT_MODIFIED（304），说明缓存还是有效的，则合并网络响应和缓存结果。同时更新缓存；5. 如果没有缓存，则将请求回来的结果写入新的缓存中；6. 返回响应数据。</code></pre><p>可以看到，缓存的获取、添加、更新等操作都是在Catche中初始化了一个DiskLruCache来完成的，具体方法如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取缓存</span><br><span class="line"> internal fun get(request: Request): Response? &#123;</span><br><span class="line">    val key &#x3D; key(request.url)</span><br><span class="line">    val snapshot: DiskLruCache.Snapshot &#x3D; try &#123;</span><br><span class="line">      cache[key] ?: return null</span><br><span class="line">    &#125; catch (_: IOException) &#123;</span><br><span class="line">      return null &#x2F;&#x2F; Give up because the cache cannot be read.</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val entry: Entry &#x3D; try &#123;</span><br><span class="line">      Entry(snapshot.getSource(ENTRY_METADATA))</span><br><span class="line">    &#125; catch (_: IOException) &#123;</span><br><span class="line">      snapshot.closeQuietly()</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val response &#x3D; entry.response(snapshot)</span><br><span class="line">    if (!entry.matches(request, response)) &#123;</span><br><span class="line">      response.body?.closeQuietly()</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加缓存</span><br><span class="line"> internal fun put(response: Response): CacheRequest? &#123;</span><br><span class="line">    val requestMethod &#x3D; response.request.method</span><br><span class="line"></span><br><span class="line">    if (HttpMethod.invalidatesCache(response.request.method)) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        remove(response.request)</span><br><span class="line">      &#125; catch (_: IOException) &#123;</span><br><span class="line">        &#x2F;&#x2F; The cache cannot be written.</span><br><span class="line">      &#125;</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (requestMethod !&#x3D; &quot;GET&quot;) &#123;</span><br><span class="line">      &#x2F;&#x2F; Don&#39;t cache non-GET responses. We&#39;re technically allowed to cache HEAD requests and some</span><br><span class="line">      &#x2F;&#x2F; POST requests, but the complexity of doing so is high and the benefit is low.</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (response.hasVaryAll()) &#123;</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val entry &#x3D; Entry(response)</span><br><span class="line">    var editor: DiskLruCache.Editor? &#x3D; null</span><br><span class="line">    try &#123;</span><br><span class="line">      editor &#x3D; cache.edit(key(response.request.url)) ?: return null</span><br><span class="line">      entry.writeTo(editor)</span><br><span class="line">      return RealCacheRequest(editor)</span><br><span class="line">    &#125; catch (_: IOException) &#123;</span><br><span class="line">      abortQuietly(editor)</span><br><span class="line">      return null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;更新缓存</span><br><span class="line"> internal fun update(cached: Response, network: Response) &#123;</span><br><span class="line">    val entry &#x3D; Entry(network)</span><br><span class="line">    val snapshot &#x3D; (cached.body as CacheResponseBody).snapshot</span><br><span class="line">    var editor: DiskLruCache.Editor? &#x3D; null</span><br><span class="line">    try &#123;</span><br><span class="line">      editor &#x3D; snapshot.edit() ?: return &#x2F;&#x2F; edit() returns null if snapshot is not current.</span><br><span class="line">      entry.writeTo(editor)</span><br><span class="line">      editor.commit()</span><br><span class="line">    &#125; catch (_: IOException) &#123;</span><br><span class="line">      abortQuietly(editor)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="4-ConnectInterceptor"><a href="#4-ConnectInterceptor" class="headerlink" title="4. ConnectInterceptor"></a>4. ConnectInterceptor</h4><p>这个拦截器打开与目标服务器的链接并进入下一个拦截器。<br>通过<code>RealCall</code>的<code>initExchange(chain)</code>创建一个<code>Exchange</code>对象，并调用 <code>Chain.proceed()</code>方法。<br><code>initExchange（）</code>方法中会先通过 <code>ExchangeFinder</code> 尝试去 <code>RealConnectionPool</code> 中寻找已存在的连接，未找到则会重新创建一个<code>RealConnection</code> 并开始连接，然后将其存入<code>RealConnectionPool</code>，现在已经准备好了<code>RealConnection</code> 对象，然后通过请求协议创建不同的<code>ExchangeCodec</code> 并返回，返回的<code>ExchangeCodec</code>正是创建Exchange对象的一个参数。</p><ul><li>下面说一下在建立连接过程中涉及到的几个重要类：</li></ul><h5 id="Route"><a href="#Route" class="headerlink" title="Route:"></a>Route:</h5><p>是连接到服务器的具体路由。其中包含了 IP 地址、端口、代理等参数。<br>由于存在代理或者 DNS 可能返回多个 IP 地址的情况，所以同一个接口地址可能会对应多个 <code>route</code>。<br>在创建 Connection 时将会使用 Route 而不是直接用 IP 地址。</p><h5 id="RouteSelector："><a href="#RouteSelector：" class="headerlink" title="RouteSelector："></a>RouteSelector：</h5><p>路由选择器，其中存储了所有可用的 <code>route</code>，在准备连接时时会通过 <code>RouteSelector.next()</code> 方法获取下一个 <code>Route</code>。<br>值得注意的是，<code>RouteSelector</code>中包含了一个 <code>routeDatabase</code> 对象，其中存放着连接失败的<code>Route</code>，<code>RouteSelector</code> 会将其中存储的上次连接失败的<code>route</code> 放在最后，以此提高连接速度。</p><h5 id="RealConnection"><a href="#RealConnection" class="headerlink" title="RealConnection:"></a>RealConnection:</h5><p><code>RealConnection</code> 实现了 <code>Connection</code>接口，其中使用 <code>Socket</code>建立<code>HTTP/HTTPS</code>连接,并且获取 I/O 流，同一个 <code>Connection</code> 可能会承载多个 HTTP 的请求与响应。</p><h5 id="RealConnectionPool"><a href="#RealConnectionPool" class="headerlink" title="RealConnectionPool:"></a>RealConnectionPool:</h5><p>这是用来存储 <code>RealConnection</code> 的池子，内部使用一个双端队列来进行存储。<br>在 OkHttp 中，一个连接（RealConnection）用完后不会立马被关闭并释放掉，而且是会存储到连接池（RealConnectionPool）中。<br>除了缓存连接外，缓存池还负责定期清理过期的连接，在 RealConnection 中会维护一个用来描述该连接空闲时间的字段，每添加一个新的连接到连接池中时都会进行一次检测，遍历所有的连接，找出当前未被使用且空闲时间最长的那个连接，如果该连接空闲时长超出阈值，或者连接池已满，将会关闭该连接。</p><h5 id="ExchangeCodec："><a href="#ExchangeCodec：" class="headerlink" title="ExchangeCodec："></a>ExchangeCodec：</h5><p><code>ExchangeCodec</code> 负责对<code>Request</code> 编码及解码 <code>Response</code>，也就是写入请求及读取响应，我们的请求及响应数据都通过它来读写。其实现类有两个：<code>Http1ExchangeCodec</code> 及 <code>Http2ExchangeCodec</code>，分别对应两种协议版本。</p><h5 id="Exchange："><a href="#Exchange：" class="headerlink" title="Exchange："></a>Exchange：</h5><p>功能类似 <code>ExchangeCodec</code>，但它是对应的是单个请求，其在 <code>ExchangeCodec</code> 基础上担负了一些连接管理及事件分发的作用。<br>具体而言，<code>Exchange</code> 与 <code>Request</code> 一一对应，新建一个请求时就会创建一个 <code>Exchange</code>，该 <code>Exchange</code> 负责将这个请求发送出去并读取到响应数据，而发送与接收数据使用的是 <code>ExchangeCodec</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">override fun intercept(chain: Interceptor.Chain): Response &#123;</span><br><span class="line">   val realChain &#x3D; chain as RealInterceptorChain</span><br><span class="line">   val exchange &#x3D; realChain.call.initExchange(chain)</span><br><span class="line">   val connectedChain &#x3D; realChain.copy(exchange &#x3D; exchange)</span><br><span class="line">   return connectedChain.proceed(realChain.request)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;RealCall 中的initExchange（）初始化Exchange对象</span><br><span class="line"> &#x2F;** Finds a new or pooled connection to carry a forthcoming request and response. *&#x2F;</span><br><span class="line"> internal fun initExchange(chain: RealInterceptorChain): Exchange &#123;</span><br><span class="line">   synchronized(connectionPool) &#123;</span><br><span class="line">     check(!noMoreExchanges) &#123; &quot;released&quot; &#125;</span><br><span class="line">     check(exchange &#x3D;&#x3D; null)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   val codec &#x3D; exchangeFinder!!.find(client, chain)</span><br><span class="line">   val result &#x3D; Exchange(this, eventListener, exchangeFinder!!, codec)</span><br><span class="line">   this.interceptorScopedExchange &#x3D; result</span><br><span class="line"></span><br><span class="line">   synchronized(connectionPool) &#123;</span><br><span class="line">     this.exchange &#x3D; result</span><br><span class="line">     this.exchangeRequestDone &#x3D; false</span><br><span class="line">     this.exchangeResponseDone &#x3D; false</span><br><span class="line">     return result</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;找到可用的resultConnection后根据协议创建ExchangeCodec并返回</span><br><span class="line"> fun find(</span><br><span class="line">   client: OkHttpClient,</span><br><span class="line">   chain: RealInterceptorChain</span><br><span class="line"> ): ExchangeCodec &#123;</span><br><span class="line">   try &#123;</span><br><span class="line">     val resultConnection &#x3D; findHealthyConnection(</span><br><span class="line">         connectTimeout &#x3D; chain.connectTimeoutMillis,</span><br><span class="line">         readTimeout &#x3D; chain.readTimeoutMillis,</span><br><span class="line">         writeTimeout &#x3D; chain.writeTimeoutMillis,</span><br><span class="line">         pingIntervalMillis &#x3D; client.pingIntervalMillis,</span><br><span class="line">         connectionRetryEnabled &#x3D; client.retryOnConnectionFailure,</span><br><span class="line">         doExtensiveHealthChecks &#x3D; chain.request.method !&#x3D; &quot;GET&quot;</span><br><span class="line">     )</span><br><span class="line">     return resultConnection.newCodec(client, chain)</span><br><span class="line">   &#125; catch (e: RouteException) &#123;</span><br><span class="line">     trackFailure(e.lastConnectException)</span><br><span class="line">     throw e</span><br><span class="line">   &#125; catch (e: IOException) &#123;</span><br><span class="line">     trackFailure(e)</span><br><span class="line">     throw RouteException(e)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> &#x2F;&#x2F;ExchangeFinder的findConnection方法中找已经存在的可用的链接</span><br><span class="line"></span><br><span class="line"> &#x2F;**</span><br><span class="line">  * Returns a connection to host a new stream. This prefers the existing connection if it exists,</span><br><span class="line">  * then the pool, finally building a new connection.</span><br><span class="line">  *&#x2F;</span><br><span class="line"> @Throws(IOException::class)</span><br><span class="line"> private fun findConnection(</span><br><span class="line">   connectTimeout: Int,</span><br><span class="line">   readTimeout: Int,</span><br><span class="line">   writeTimeout: Int,</span><br><span class="line">   pingIntervalMillis: Int,</span><br><span class="line">   connectionRetryEnabled: Boolean</span><br><span class="line"> ): RealConnection &#123;</span><br><span class="line">   var foundPooledConnection &#x3D; false</span><br><span class="line">   var result: RealConnection? &#x3D; null</span><br><span class="line">   var selectedRoute: Route? &#x3D; null</span><br><span class="line">   var releasedConnection: RealConnection?</span><br><span class="line">   val toClose: Socket?</span><br><span class="line">   synchronized(connectionPool) &#123;</span><br><span class="line">   </span><br><span class="line">      …………</span><br><span class="line">      </span><br><span class="line">       &#x2F;&#x2F; Attempt to get a connection from the pool.</span><br><span class="line">       &#x2F;&#x2F;从connectPool中找可用的链接并返回</span><br><span class="line">       if (connectionPool.callAcquirePooledConnection(address, call, null, false)) &#123;</span><br><span class="line">         foundPooledConnection &#x3D; true</span><br><span class="line">         result &#x3D; call.connection</span><br><span class="line">       &#125; else if (nextRouteToTry !&#x3D; null) &#123;</span><br><span class="line">         selectedRoute &#x3D; nextRouteToTry</span><br><span class="line">         nextRouteToTry &#x3D; null</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   toClose?.closeQuietly()</span><br><span class="line"></span><br><span class="line">   if (releasedConnection !&#x3D; null) &#123;</span><br><span class="line">     eventListener.connectionReleased(call, releasedConnection!!)</span><br><span class="line">   &#125;</span><br><span class="line">   if (foundPooledConnection) &#123;</span><br><span class="line">     eventListener.connectionAcquired(call, result!!)</span><br><span class="line">   &#125;</span><br><span class="line">   if (result !&#x3D; null) &#123;</span><br><span class="line">     &#x2F;&#x2F; If we found an already-allocated or pooled connection, we&#39;re done.</span><br><span class="line">     return result!!</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">     …………</span><br><span class="line">     </span><br><span class="line">   &#x2F;&#x2F; Create a connection and assign it to this allocation immediately. This makes it possible</span><br><span class="line">       &#x2F;&#x2F; for an asynchronous cancel() to interrupt the handshake we&#39;re about to do.</span><br><span class="line">       &#x2F;&#x2F;创建一个新的RealConnection</span><br><span class="line">       result &#x3D; RealConnection(connectionPool, selectedRoute!!)</span><br><span class="line">       connectingConnection &#x3D; result</span><br><span class="line">       </span><br><span class="line">  var socket: Socket? &#x3D; null</span><br><span class="line">   synchronized(connectionPool) &#123;</span><br><span class="line">     connectingConnection &#x3D; null</span><br><span class="line">     &#x2F;&#x2F; Last attempt at connection coalescing, which only occurs if we attempted multiple</span><br><span class="line">     &#x2F;&#x2F; concurrent connections to the same host.</span><br><span class="line">     if (connectionPool.callAcquirePooledConnection(address, call, routes, true)) &#123;</span><br><span class="line">       &#x2F;&#x2F; We lost the race! Close the connection we created and return the pooled connection.</span><br><span class="line">       result!!.noNewExchanges &#x3D; true</span><br><span class="line">       socket &#x3D; result!!.socket()</span><br><span class="line">       result &#x3D; call.connection</span><br><span class="line"></span><br><span class="line">       &#x2F;&#x2F; It&#39;s possible for us to obtain a coalesced connection that is immediately unhealthy. In</span><br><span class="line">       &#x2F;&#x2F; that case we will retry the route we just successfully connected with.</span><br><span class="line">       nextRouteToTry &#x3D; selectedRoute</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       connectionPool.put(result!!)&#x2F;&#x2F;将新创建的RealConnection添加到connectPool中</span><br><span class="line">       call.acquireConnectionNoEvents(result!!)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   socket?.closeQuietly()</span><br><span class="line"></span><br><span class="line">   eventListener.connectionAcquired(call, result!!)</span><br><span class="line">   </span><br><span class="line">   return result!!</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="5-CallServerInterceptor"><a href="#5-CallServerInterceptor" class="headerlink" title="5. CallServerInterceptor"></a>5. CallServerInterceptor</h4><p>这是OkHttp 的连接器链中的最后一个拦截器，负责利用exchange把Request中的数据发送给服务端，并获取到数据写入到Response中。</p><p>到这里，OkHttp框架的核心逻辑已经梳理完了，回顾一下整体的架构实现，用到的设计模式有：Builder模式（OKHttpClient的构建）、工厂方法模式（Call接口提供了内部接口Factory、责任链模式（拦截器链）、享元模式（在Dispatcher的线程池）、策略模式（CacheInterceptor中数据选择等。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>OkHttp 4.6源码</li><li><a href="https://blog.csdn.net/json_it/article/details/78404010" target="_blank" rel="noopener">okhttp源码解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/104813091" target="_blank" rel="noopener">OkHttp 源码分析</a></li><li>感谢您阅读这篇文章，若有不正确的地方，欢迎指正!</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;OkHttp 是一款非常优秀的网络请求框架，随着Kotlin语言的不断完善，OkHttp 自 4.0 版本开始使用Kotlin编写，对于巩固
      
    
    </summary>
    
    
      <category term="Android进阶" scheme="https://eriecorner.github.io/categories/Android%E8%BF%9B%E9%98%B6/"/>
    
    
      <category term="三方框架源码解析" scheme="https://eriecorner.github.io/tags/%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】236. 二叉树的最近公共祖先</title>
    <link href="https://eriecorner.github.io/2020/05/17/suan-fa/leetcode/236.er-cha-shu-de-zui-jin-gong-gong-zu-xian/"/>
    <id>https://eriecorner.github.io/2020/05/17/suan-fa/leetcode/236.er-cha-shu-de-zui-jin-gong-gong-zu-xian/</id>
    <published>2020-05-16T16:00:00.000Z</published>
    <updated>2020-05-18T14:19:33.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="">LeetCode</a></li><li>题目描述： 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</li></ul><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉树:  root = [3,5,1,6,2,0,8,null,null,7,4]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     3</span><br><span class="line">   &#x2F;    \</span><br><span class="line">  5      1</span><br><span class="line"> &#x2F;  \   &#x2F;  \</span><br><span class="line">6    2   8</span><br><span class="line">    &#x2F;  \   </span><br><span class="line">   7    4</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>所有节点的值都是唯一的。</li><li>p、q 为不同节点且均存在于给定的二叉树中。</li></ol><ul><li>示例</li></ul><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1</span><br><span class="line">输出: 3</span><br><span class="line">解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4</span><br><span class="line">输出: 5</span><br><span class="line">解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>我们可以用哈希表存储所有节点的父节点，然后我们就可以利用节点的父节点信息从 p 结点开始不断往上跳，并记录已经访问过的节点，再从 q 节点开始不断往上跳，如果碰到已经访问过的节点，那么这个节点就是我们要找的最近公共祖先。</li><li>从根节点开始遍历整棵二叉树，用哈希表记录每个节点的父节点指针。</li><li>从 p 节点开始不断往它的祖先移动，并用数据结构记录已经访问过的祖先节点。</li><li>同样，我们再从 q 节点开始不断往它的祖先移动，如果有祖先已经被访问过，即意味着这是 p 和 q 的深度最深的公共祖先，即 LCA 节点。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     Map&lt;Integer, TreeNode&gt; parent &#x3D; new HashMap&lt;Integer, TreeNode&gt;();</span><br><span class="line">    Set&lt;Integer&gt; visited &#x3D; new HashSet&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">public void addParentNode(TreeNode node)&#123;</span><br><span class="line">    if(node.left!&#x3D;null)&#123;</span><br><span class="line">        parent.put(node.left.val,node);</span><br><span class="line">        addParentNode(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    if(node.right!&#x3D;null)&#123;</span><br><span class="line">        parent.put(node.right.val,node);</span><br><span class="line">        addParentNode(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        addParentNode(root);</span><br><span class="line">        while(p!&#x3D;null)&#123;</span><br><span class="line">            visited.add(p.val);</span><br><span class="line">            p &#x3D; parent.get(p.val);</span><br><span class="line">        &#125;</span><br><span class="line">        while(q!&#x3D;null)&#123;</span><br><span class="line">            if(visited.contains(q.val))&#123;</span><br><span class="line">                return q;</span><br><span class="line">            &#125;</span><br><span class="line">            q &#x3D; parent.get(q.val);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">       var parent: MutableMap&lt;Int, TreeNode?&gt; &#x3D; HashMap()</span><br><span class="line">       var visited: MutableSet&lt;Int&gt; &#x3D; HashSet()</span><br><span class="line">       fun addParentNode(node: TreeNode?) &#123;</span><br><span class="line">           if (node!!.left !&#x3D; null) &#123;</span><br><span class="line">               parent[node.left.&#96;val&#96;] &#x3D; node</span><br><span class="line">               addParentNode(node.left)</span><br><span class="line">           &#125;</span><br><span class="line">           if (node.right !&#x3D; null) &#123;</span><br><span class="line">               parent[node.right.&#96;val&#96;] &#x3D; node</span><br><span class="line">               addParentNode(node.right)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       fun lowestCommonAncestor(root: TreeNode?, p: TreeNode?, q: TreeNode?): TreeNode? &#123;</span><br><span class="line">           var p &#x3D; p</span><br><span class="line">           var q &#x3D; q</span><br><span class="line">           addParentNode(root)</span><br><span class="line">           while (p !&#x3D; null) &#123;</span><br><span class="line">               visited.add(p.&#96;val&#96;)</span><br><span class="line">               p &#x3D; parent[p.&#96;val&#96;]</span><br><span class="line">           &#125;</span><br><span class="line">           while (q !&#x3D; null) &#123;</span><br><span class="line">               if (visited.contains(q.&#96;val&#96;)) &#123;</span><br><span class="line">                   return q</span><br><span class="line">               &#125;</span><br><span class="line">               q &#x3D; parent[q.&#96;val&#96;]</span><br><span class="line">           &#125;</span><br><span class="line">           return null</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><p>时间复杂度<code>$O(N)$</code>：其中 NN 是二叉树的节点数。二叉树的所有节点有且只会被访问一次，从 p 和 q 节点往上跳经过的祖先节点个数不会超过 N，因此总的时间复杂度为 O(N)。</p></li><li><p>空间复杂度<code>$O(N$</code>：递归调用的栈深度取决于二叉树的高度，二叉树最坏情况下为一条链，此时高度为 N，因此空间复杂度为 O(N)，哈希表存储每个节点的父节点也需要 O(N) 的空间复杂度，因此最后总的空间复杂度为 O(N)。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;&quot;&gt;LeetCode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;题目描述： 给定一个二叉树, 找到
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】283. 移动零</title>
    <link href="https://eriecorner.github.io/2020/05/17/suan-fa/leetcode/283.yi-dong-ling/"/>
    <id>https://eriecorner.github.io/2020/05/17/suan-fa/leetcode/283.yi-dong-ling/</id>
    <published>2020-05-16T16:00:00.000Z</published>
    <updated>2020-05-18T14:19:23.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述： 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</li></ul><p><strong>说明</strong>:<br>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p><ul><li>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>双指针法，用记录不是0的元素下标，i遍历数组，当nums[i]!=0的时候，将nums[i]的值给nums[j];并把0 给nums[i];</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int j &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(nums[i]!&#x3D;0)&#123;</span><br><span class="line">                if(i!&#x3D;j)&#123;</span><br><span class="line">                nums[j] &#x3D; nums[i];</span><br><span class="line">                nums[i] &#x3D;0;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fun moveZeroes(nums: IntArray) &#123;</span><br><span class="line">    var j &#x3D; 0</span><br><span class="line">    for (i in nums.indices) &#123;</span><br><span class="line">        if (nums[i] !&#x3D; 0) &#123;</span><br><span class="line">            if (i !&#x3D; j) &#123;</span><br><span class="line">                nums[j] &#x3D; nums[i]</span><br><span class="line">                nums[i] &#x3D; 0</span><br><span class="line">            &#125;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度<code>$O(N)$</code>：N是数组的长度，只需要遍历一遍</li><li>空间复杂度<code>$O(1)$</code>：</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/move-zer
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】155. 最小栈</title>
    <link href="https://eriecorner.github.io/2020/05/16/suan-fa/leetcode/155.zui-xiao-zhan/"/>
    <id>https://eriecorner.github.io/2020/05/16/suan-fa/leetcode/155.zui-xiao-zhan/</id>
    <published>2020-05-15T16:00:00.000Z</published>
    <updated>2020-05-18T14:18:55.077Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li><p>题目来源： <a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">LeetCode</a></p></li><li><p>题目描述：<br>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li>push(x) —— 将元素 x 推入栈中。</li><li>pop() —— 删除栈顶的元素。</li><li>top() —— 获取栈顶元素。</li><li>getMin() —— 检索栈中的最小元素。</li></ul></li></ul><p><strong>提示</strong>：</p><p>pop、top 和 getMin 操作总是在 非空栈 上调用。</p><ul><li>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack &#x3D; new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;min-stack</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2></li></ul><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MinStack &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    int min &#x3D; Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    &#x2F;** initialize your data structure here. *&#x2F;</span><br><span class="line">    public MinStack() &#123;</span><br><span class="line">       stack &#x3D; new Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void push(int x) &#123;</span><br><span class="line">        if(x&lt;&#x3D;min)&#123;</span><br><span class="line">            &#x2F;&#x2F;将之前的最小值入栈</span><br><span class="line">            stack.push(min);</span><br><span class="line">            &#x2F;&#x2F;更新最小值</span><br><span class="line">            min &#x3D; x;</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(x);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pop() &#123;</span><br><span class="line">         &#x2F;&#x2F;如果弹出的值是最小值，那么将下一个元素更新为最小值</span><br><span class="line">        if(stack.pop()&#x3D;&#x3D;min)&#123;</span><br><span class="line">            min &#x3D; stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int top() &#123;</span><br><span class="line">       return stack.peek();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getMin() &#123;</span><br><span class="line">        return min;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">internal class MinStack &#123;</span><br><span class="line">       private var stack: Stack&lt;Int&gt; &#x3D; Stack()</span><br><span class="line">       private var min &#x3D; Int.MAX_VALUE</span><br><span class="line"></span><br><span class="line">       fun push(x: Int) &#123;</span><br><span class="line">           if (x &lt;&#x3D; min) &#123; &#x2F;&#x2F;将之前的最小值入栈</span><br><span class="line">               stack.push(min)</span><br><span class="line">               &#x2F;&#x2F;更新最小值</span><br><span class="line">               min &#x3D; x</span><br><span class="line">           &#125;</span><br><span class="line">           stack.push(x)</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       fun pop() &#123; &#x2F;&#x2F;如果弹出的值是最小值，那么将下一个元素更新为最小值</span><br><span class="line">           if (stack.pop() &#x3D;&#x3D;&#x3D; min) &#123;</span><br><span class="line">               min &#x3D; stack.pop()</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       fun top(): Int &#123;</span><br><span class="line">           return stack.peek()</span><br><span class="line">       &#125;</span><br><span class="line">       fun getMin(): Int &#123;</span><br><span class="line">           return min</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度<code>$O(1)$</code>：对于题目中的所有操作，时间复杂度均为 O(1)。因为栈的插入、删除与读取操作都是 O(1)，我们定义的每个操作最多调用栈操作两次。</li></ul><ul><li>空间复杂度<code>$O(1)$</code>：</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/min-s
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="栈" scheme="https://eriecorner.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】560. 和为K的子数组</title>
    <link href="https://eriecorner.github.io/2020/05/16/suan-fa/leetcode/560.he-wei-k-de-zi-shu-zu/"/>
    <id>https://eriecorner.github.io/2020/05/16/suan-fa/leetcode/560.he-wei-k-de-zi-shu-zu/</id>
    <published>2020-05-15T16:00:00.000Z</published>
    <updated>2020-05-18T14:18:01.896Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述： 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。</li></ul><p><strong>说明</strong> :</p><ol><li>数组的长度为 [1, 20,000]。</li><li>数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</li></ol><ul><li>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>我们把前缀和放在 map 中， map.put(preSum,前缀和出现次数) (数组中可能会有负数，所以可能会重复出现)</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int subarraySum(int[] nums, int k) &#123;</span><br><span class="line">       int count &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F;使用hashMap 实现线性查找，map以i以前各项的和作为k，i以前各项的和出现的次数作为value</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        &#x2F;&#x2F; 数组下标为 0，则前面数组为空，所以和为 0，且出现一次  </span><br><span class="line">        map.put(0,1);</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt;nums.length ; i++) &#123;</span><br><span class="line">            sum+&#x3D;nums[i];</span><br><span class="line">            if (map.containsKey(sum-k))&#123;</span><br><span class="line">                count+&#x3D; map.getOrDefault(sum-k,0);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(sum,map.getOrDefault(sum,0)+1);</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun subarraySum(nums: IntArray, k: Int): Int &#123;</span><br><span class="line">       var count &#x3D; 0</span><br><span class="line">       &#x2F;&#x2F;使用hashMap 实现线性查找，map以i以前各项的和作为k，i以前各项的和出现的次数作为value</span><br><span class="line">       val map: HashMap&lt;Int, Int&gt; &#x3D; HashMap()</span><br><span class="line">       map[0] &#x3D; 1</span><br><span class="line">       var sum &#x3D; 0</span><br><span class="line">       for (i in nums.indices) &#123;</span><br><span class="line">           sum +&#x3D; nums[i]</span><br><span class="line">           if (map.containsKey(sum - k)) &#123;</span><br><span class="line">               count +&#x3D; map.getOrDefault(sum - k, 0)</span><br><span class="line">           &#125;</span><br><span class="line">           map[sum] &#x3D; map.getOrDefault(sum, 0) + 1</span><br><span class="line">       &#125;</span><br><span class="line">       return count</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度<code>$O(N)$</code>：其中 nn 为数组的长度。我们遍历数组的时间复杂度为 O(n)，中间利用哈希表查询删除的复杂度均为 O(1)，因此总时间复杂度为 O(n)。</li></ul><ul><li>空间复杂度<code>$O(N)$</code>：其中 nn 为数组的长度。哈希表在最坏情况下可能有 nn 个不同的键值，因此需要 O(n)O(n) 的空间复杂度。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/subarray
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】136. 只出现一次的数字</title>
    <link href="https://eriecorner.github.io/2020/05/15/suan-fa/leetcode/136.zhi-chu-xian-yi-ci-de-shu-zi/"/>
    <id>https://eriecorner.github.io/2020/05/15/suan-fa/leetcode/136.zhi-chu-xian-yi-ci-de-shu-zi/</id>
    <published>2020-05-14T16:00:00.000Z</published>
    <updated>2020-05-18T14:19:45.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/single-number/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述：<br>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</li></ul><p><strong>说明</strong>：</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><ul><li>示例</li></ul><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,1,2,1,2]</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>异或运算<ul><li>任何数和 0 做异或运算，结果仍然是原来的数；</li><li>任何数和其自身做异或运算，结果是 0；</li><li>异或运算满足交换律和结合律。</li></ul></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> public int singleNumber(int[] nums) &#123;</span><br><span class="line">        int singleNumber &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            singleNumber^&#x3D; nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return singleNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> fun singleNumber(nums: IntArray): Int &#123;</span><br><span class="line">        var singleNumber &#x3D; 0 </span><br><span class="line">        for( i in nums.indices)&#123;</span><br><span class="line">           singleNumber &#x3D; singleNumber xor nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">return singleNumber</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度<code>$O(N)$</code>：其中 n 是数组长度。只需要对数组遍历一次。</li><li>空间复杂度<code>$O(1)$</code>：</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/single-n
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】572. 另一个数的子树</title>
    <link href="https://eriecorner.github.io/2020/05/15/suan-fa/leetcode/572.ling-yi-ge-shu-de-zi-shu/"/>
    <id>https://eriecorner.github.io/2020/05/15/suan-fa/leetcode/572.ling-yi-ge-shu-de-zi-shu/</id>
    <published>2020-05-14T16:00:00.000Z</published>
    <updated>2020-05-18T14:17:44.811Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li><p>题目来源： <a href="https://leetcode-cn.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">LeetCode</a></p></li><li><p>题目描述： 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。</p></li><li><p>示例</p></li></ul><p>1.<br>给定的树s：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>给定的树t：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p><p>2.<br>给定的树s：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  4   5</span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br><span class="line">   &#x2F;</span><br><span class="line">  0</span><br></pre></td></tr></table></figure><p>给定的树t：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  4 </span><br><span class="line"> &#x2F; \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>返回 false</p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>递归思想，注意两棵树完全相同也可以看做一棵树是另一棵树的子树。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSubtree(TreeNode s, TreeNode t) &#123;</span><br><span class="line">        if(t&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s&#x3D;&#x3D;null) return false;</span><br><span class="line">        return isSubtree(s.left,t)||isSubtree(s.right,t)||isSameTree(s,t);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;两个树完全相同</span><br><span class="line">    public boolean isSameTree(TreeNode s,TreeNode t)&#123;</span><br><span class="line">        if(s &#x3D;&#x3D; null &amp;&amp; t&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s &#x3D;&#x3D; null||t &#x3D;&#x3D; null)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.val!&#x3D;t.val)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">         return isSameTree(s.left,t.left)&amp;&amp;isSameTree(s.right,t.right);</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun isSubtree(s: TreeNode?, t: TreeNode?): Boolean &#123;</span><br><span class="line">       if (t &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return true</span><br><span class="line">       &#125;</span><br><span class="line">       return if (s &#x3D;&#x3D; null) false else isSubtree(s.left, t) || isSubtree(s.right, t) || isSameTree(s, t)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   fun isSameTree(s: TreeNode?, t: TreeNode?): Boolean &#123;</span><br><span class="line">       if (s &#x3D;&#x3D; null &amp;&amp; t &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return true</span><br><span class="line">       &#125;</span><br><span class="line">       if (s &#x3D;&#x3D; null || t &#x3D;&#x3D; null) &#123;</span><br><span class="line">           return false</span><br><span class="line">       &#125;</span><br><span class="line">       return if (s.&#96;val&#96; !&#x3D;&#x3D; t.&#96;val&#96;) &#123;</span><br><span class="line">           false</span><br><span class="line">       &#125; else isSameTree(s.left, t.left) &amp;&amp; isSameTree(s.right, t.right)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：<code>$O()$</code></li><li>空间复杂度：<code>$O()$</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/subtr
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】102. 二叉树的层序遍历</title>
    <link href="https://eriecorner.github.io/2020/05/14/suan-fa/leetcode/102.er-cha-shu-de-ceng-xu-bian-li/"/>
    <id>https://eriecorner.github.io/2020/05/14/suan-fa/leetcode/102.er-cha-shu-de-ceng-xu-bian-li/</id>
    <published>2020-05-13T16:00:00.000Z</published>
    <updated>2020-05-18T14:19:52.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li><p>题目来源： <a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">LeetCode</a></p></li><li><p>题目描述： 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p></li><li><p>示例</p><p>二叉树：[3,9,20,null,null,15,7],</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回其层次遍历结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>其实就是二叉树的前序遍历，只是每一层装在一个单独的集合中，最后将每一层的子集合都装在一个大集合中。</li><li>通过递归遍历实现。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;</span><br><span class="line">inorderTraverse(root,0);</span><br><span class="line">return result;</span><br><span class="line">    &#125;</span><br><span class="line">     public void inorderTraverse(TreeNode node, int level) &#123;</span><br><span class="line">         if(node!&#x3D;null)&#123;</span><br><span class="line">            if(result.size()&#x3D;&#x3D;level)&#123;</span><br><span class="line">                result.add(new ArrayList&lt;Integer&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            result.get(level).add(node.val);</span><br><span class="line">            inorderTraverse(node.left,level+1);</span><br><span class="line">             inorderTraverse(node.right,level+1);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line"> var result: MutableList&lt;MutableList&lt;Int?&gt;&gt; &#x3D; ArrayList()</span><br><span class="line">    fun levelOrder(root: TreeNode?): List&lt;MutableList&lt;Int?&gt;&gt;? &#123;</span><br><span class="line">        inorderTraverse(root, 0)</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun inorderTraverse(node: TreeNode?, level: Int) &#123;</span><br><span class="line">        if (node !&#x3D; null) &#123;</span><br><span class="line">            if (result.size &#x3D;&#x3D; level) &#123;</span><br><span class="line">                result.add(ArrayList())</span><br><span class="line">            &#125;</span><br><span class="line">            result[level].add(node.&#96;val&#96;)</span><br><span class="line">            inorderTraverse(node.left, level + 1)</span><br><span class="line">            inorderTraverse(node.right, level + 1)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度<code>$O(N)$</code>：N 为二叉树节点的个数</li><li>空间复杂度<code>$O(H)$</code>：H 为二叉树的高度</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/binar
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】98. 验证二叉搜索树</title>
    <link href="https://eriecorner.github.io/2020/05/13/suan-fa/leetcode/98.yan-zheng-er-cha-sou-suo-shu/"/>
    <id>https://eriecorner.github.io/2020/05/13/suan-fa/leetcode/98.yan-zheng-er-cha-sou-suo-shu/</id>
    <published>2020-05-12T16:00:00.000Z</published>
    <updated>2020-05-18T14:20:00.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述：<br>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</li></ul><p>假设一个二叉搜索树具有如下特征：</p><ol><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ol><ul><li>示例</li></ul><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 输入:</span><br><span class="line">    2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   &#x2F; \</span><br><span class="line">  1   4</span><br><span class="line">     &#x2F; \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]。</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4 。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2></li></ol><ul><li>由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。</li><li>所以用递归来判断<code>isChildBST(childNode,left,right)</code>,以childNode为根节点的子树的所有节点是否在（left,right）的区间内，如果 root 节点的值 val 不在 （left,right）的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><ul><li>定义树节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">      int val;</span><br><span class="line">      TreeNode left;</span><br><span class="line">      TreeNode right;</span><br><span class="line">      TreeNode(int x) &#123; val &#x3D; x; &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValidBST(TreeNode root) &#123;</span><br><span class="line">     return isChildBST(root,null,null);</span><br><span class="line">   &#125;</span><br><span class="line">   public boolean isChildBST(TreeNode childNode,Integer left,Integer right)&#123;</span><br><span class="line">       if(childNode&#x3D;&#x3D;null)&#123; </span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line">       if(left!&#x3D;null&amp;&amp;left&gt;&#x3D;childNode.val)return false;</span><br><span class="line">       if(right!&#x3D;null&amp;&amp;right&lt;&#x3D;childNode.val) return false;</span><br><span class="line">       return isChildBST(childNode.left,left,childNode.val)&amp;&amp;isChildBST(childNode.right,childNode.val,right);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><ul><li>定义树节点<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class TreeNode(var &#96;val&#96;: Int) &#123;</span><br><span class="line">      var left: TreeNode? &#x3D; null</span><br><span class="line">      var right: TreeNode? &#x3D; null</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li>核心方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fun isValidBST(root: TreeNode?): Boolean &#123;</span><br><span class="line">      return isChildBST(root,null,null)</span><br><span class="line">    &#125;</span><br><span class="line">    fun isChildBST(childNode:TreeNode?,left:Int?,right:Int?):Boolean&#123;</span><br><span class="line">        if (childNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">        if (left !&#x3D; null &amp;&amp; left &gt;&#x3D; childNode.&#96;val&#96;) return false</span><br><span class="line">        return if (right !&#x3D; null &amp;&amp; right &lt;&#x3D; childNode.&#96;val&#96;) false else isChildBST(childNode.left, left, childNode.&#96;val&#96;) &amp;&amp; isChildBST(childNode.right, childNode.&#96;val&#96;, right)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：<code>$O(n)$</code></li></ul><p>其中 n 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。</p><ul><li>空间复杂度：<code>$O(n)$</code></li></ul><p>其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 O(n) 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/validate
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="二叉树" scheme="https://eriecorner.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】69. X的平方根</title>
    <link href="https://eriecorner.github.io/2020/05/12/suan-fa/leetcode/69.x-de-ping-fang-gen/"/>
    <id>https://eriecorner.github.io/2020/05/12/suan-fa/leetcode/69.x-de-ping-fang-gen/</id>
    <published>2020-05-11T16:00:00.000Z</published>
    <updated>2020-05-18T14:20:06.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述：<br>实现 <code>int sqrt(int x)</code> 函数。</li></ul><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去</p><ul><li>示例</li></ul><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: 8</span><br><span class="line">输出: 2</span><br><span class="line">说明: 8 的平方根是 2.82842..., </span><br><span class="line">     由于返回类型是整数，小数部分将被舍去。</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>由于x的平方跟的整数部分ans是满足<code>$k^2$</code>&lt;=x的，所以，我们可以对K进行二分查找来得到答案；</li><li>二分查找的下限定为0，上限定为x，在查找的过程中，比较mid*mid与x的大小关系，根据结果来调整上下限范围。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int mySqrt(int x) &#123;</span><br><span class="line">       int l &#x3D; 0,r &#x3D; x,result &#x3D; -1;</span><br><span class="line">       while(l&lt;&#x3D;r)&#123;</span><br><span class="line">           int mid &#x3D; l+(r-l)&#x2F;2;</span><br><span class="line">           if((long)mid*mid&lt;&#x3D;x)&#123;</span><br><span class="line">               result &#x3D; mid;</span><br><span class="line">              l &#x3D; mid+1;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               r &#x3D; mid-1;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun mySqrt(x: Int): Int &#123;</span><br><span class="line">        var l &#x3D; 0</span><br><span class="line">        var r &#x3D; x</span><br><span class="line">        var result &#x3D; -1</span><br><span class="line">        while (l &lt;&#x3D; r) &#123;</span><br><span class="line">            val mid &#x3D; l + (r - l) &#x2F; 2</span><br><span class="line">            if (mid.toLong() * mid &lt;&#x3D; x) &#123;</span><br><span class="line">                result &#x3D; mid</span><br><span class="line">                l &#x3D; mid + 1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                r &#x3D; mid - 1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：<code>$O(log x)$</code>：即二分查找需要的次数。</li><li>空间复杂度：<code>$O(1)$</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/sqrtx/&quot; 
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数学" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】50. Pow(x, n)</title>
    <link href="https://eriecorner.github.io/2020/05/11/suan-fa/leetcode/50.pow-x-n/"/>
    <id>https://eriecorner.github.io/2020/05/11/suan-fa/leetcode/50.pow-x-n/</id>
    <published>2020-05-10T16:00:00.000Z</published>
    <updated>2020-05-18T14:20:21.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述： 实现 pow(x, n) ，即计算 x 的 n 次幂函数。</li></ul><p><strong>说明</strong>:</p><ul><li>-100.0 &lt; x &lt; 100.0</li><li>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</li><li>示例</li></ul><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, 10</span><br><span class="line">输出: 1024.00000</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.10000, 3</span><br><span class="line">输出: 9.26100</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 2.00000, -2</span><br><span class="line">输出: 0.25000</span><br><span class="line">解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>当我们要计算<code>$x^n$</code>时,我们可以先递归地计算出 <code>$y =x^(|n|/2) $</code>;</li><li>根据递归计算的结果，如果 n为偶数<code>$x^n = y^2$</code> ,当n为奇数时，<code>$x^n = y^2*x$</code>;</li><li>递归的边界为 n = 0，任意数的 0 次方均为 1;</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public double myPow(double x, int n) &#123;</span><br><span class="line">       return n &gt;&#x3D; 0 ? quickMul(x, n) : 1.0 &#x2F; quickMul(x, -n);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   public double quickMul(double x,int n)&#123;</span><br><span class="line">        if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">           return 1.0;</span><br><span class="line">       &#125;</span><br><span class="line">       double y &#x3D; quickMul(x, n &#x2F; 2);</span><br><span class="line">       return n % 2 &#x3D;&#x3D; 0 ? y * y : y * y * x;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun myPow(x: Double, n: Int): Double &#123;</span><br><span class="line">       return if(n&gt;&#x3D;0) mulPow(x,n)else 1.0&#x2F;mulPow(x,-n)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   fun mulPow(x:Double,n:Int):Double&#123;</span><br><span class="line">       if(n&#x3D;&#x3D;0)&#123;</span><br><span class="line">           return 1.0</span><br><span class="line">       &#125;</span><br><span class="line">       val y &#x3D; mulPow(x,n&#x2F;2);</span><br><span class="line">       return if(n%2&#x3D;&#x3D;0) y*y else y*y*x</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度<code>$O(log n)$</code>：</li><li>空间复杂度<code>$O(1)$</code>：</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/powx-n/&quot;
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数学" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】26. 删除排序数组中的重复项</title>
    <link href="https://eriecorner.github.io/2020/05/10/suan-fa/leetcode/26.shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/"/>
    <id>https://eriecorner.github.io/2020/05/10/suan-fa/leetcode/26.shan-chu-pai-xu-shu-zu-zhong-de-chong-fu-xiang/</id>
    <published>2020-05-09T16:00:00.000Z</published>
    <updated>2020-05-18T14:20:28.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述： 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</li></ul><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p><ul><li>示例</li></ul><ol><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [1,1,2], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。</span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></li></ol><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。只要 nums[i] = nums[j]，我们就增加 j 以跳过重复项。<br>当我们遇到 nums[j]!=nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]）的值复制到 nums[i + 1]。然后递增 i，接着我们将再次重复相同的过程，直到 j 到达数组的末尾为止。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">       if(nums.length&#x3D;&#x3D;0)&#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       int  i &#x3D; 0;</span><br><span class="line">       for(int j&#x3D;1;j&lt;nums.length;j++)&#123;</span><br><span class="line">           if(nums[j]!&#x3D;nums[i])&#123;</span><br><span class="line">              i++;</span><br><span class="line">               nums[i] &#x3D; nums[j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return i+1;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun removeDuplicates(nums: IntArray): Int &#123;</span><br><span class="line">        &#x2F;&#x2F; var nums &#x3D; nums</span><br><span class="line">        if (nums.isEmpty()) &#123;</span><br><span class="line">            return 0</span><br><span class="line">        &#125;</span><br><span class="line">        var j &#x3D; 0</span><br><span class="line">        for(i in 1  until nums.size)&#123;</span><br><span class="line">            if(nums[i]!&#x3D;nums[j])&#123;</span><br><span class="line">                 j++</span><br><span class="line">                nums[j]&#x3D;nums[i]</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return j+1</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：<code>$O(n)$</code><br>假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步</li><li>空间复杂度：<code>$O(1)$</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/remove-d
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】25. K 个一组翻转链表</title>
    <link href="https://eriecorner.github.io/2020/05/09/suan-fa/leetcode/25.k-ge-yi-zu-fan-zhuan-lian-biao/"/>
    <id>https://eriecorner.github.io/2020/05/09/suan-fa/leetcode/25.k-ge-yi-zu-fan-zhuan-lian-biao/</id>
    <published>2020-05-08T16:00:00.000Z</published>
    <updated>2020-05-18T14:20:35.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述：<br>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</li></ul><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p><strong>说明</strong>：<br>你的算法只能使用常数的额外空间。<br>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><ul><li>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5</span><br><span class="line"></span><br><span class="line">当 k &#x3D; 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5</span><br><span class="line"></span><br><span class="line">当 k &#x3D; 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>创建一个tmp节点用来指向链表的头结点（因为在链表翻转的过程中头结点有可能改变）</li><li>对链表以K为单位进行分组，记录每一组的开始位置和结束位置；</li><li>对每一组进行翻转，更新开始位置和结束位置；</li><li>把不满足分组条件的直接链在翻转后的链表后面；</li><li>返回tmp.next;</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseKGroup(ListNode head, int k) &#123;</span><br><span class="line">       ListNode tmp &#x3D;  new ListNode(0);</span><br><span class="line">       tmp.next &#x3D; head;</span><br><span class="line">       ListNode pre &#x3D; tmp;</span><br><span class="line">       ListNode end &#x3D; head;</span><br><span class="line">       int count &#x3D; 0;</span><br><span class="line">       while(end!&#x3D;null)&#123;</span><br><span class="line">           count++;</span><br><span class="line">           if(count%k&#x3D;&#x3D;0)&#123;&#x2F;&#x2F;需要翻转</span><br><span class="line">               ListNode next &#x3D; end.next;&#x2F;&#x2F;保存每一组最后一个节点的下一个节点（下一组的头结点）</span><br><span class="line">               end.next &#x3D; null;&#x2F;&#x2F;按组断开</span><br><span class="line">               ListNode childend &#x3D; pre.next;&#x2F;&#x2F;保存每一组的第一个节点（即翻转后的最后一个节点）</span><br><span class="line">               ListNode childHead &#x3D;  revert(pre.next);&#x2F;&#x2F;翻转后的每一组的头结点</span><br><span class="line">               childend.next &#x3D; next;&#x2F;&#x2F;翻转后链表的尾节点跟原链表的后半部分链接起来</span><br><span class="line">               pre.next &#x3D; childHead;&#x2F;&#x2F;翻转后链表的头结点跟原链表的前半部分链接起来</span><br><span class="line">               &#x2F;&#x2F;指针向后移动开始遍历下一组</span><br><span class="line">               pre &#x3D; childend;</span><br><span class="line">               end &#x3D; next;</span><br><span class="line">           &#125;else&#123;</span><br><span class="line">               &#x2F;&#x2F;不需翻转，则指针向后移动</span><br><span class="line">               end &#x3D; end.next;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">    return tmp.next;</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;**</span><br><span class="line">   * 进行链表翻转，返回翻转后的头指针</span><br><span class="line">   * 头插法</span><br><span class="line">   *&#x2F;</span><br><span class="line">   public ListNode revert(ListNode start)&#123;</span><br><span class="line">       ListNode pre &#x3D; new ListNode(0);</span><br><span class="line">       while(start!&#x3D;null)&#123;</span><br><span class="line">           ListNode next &#x3D; start.next;</span><br><span class="line">           start.next &#x3D;  pre.next ;</span><br><span class="line">           pre.next &#x3D; start;</span><br><span class="line">           start &#x3D; next;</span><br><span class="line">       &#125;</span><br><span class="line">       return pre.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> fun reverseKGroup(head: ListNode?, k: Int): ListNode? &#123;</span><br><span class="line">        var tmp &#x3D; ListNode(-1)</span><br><span class="line">        tmp.next &#x3D; head</span><br><span class="line">        var pre &#x3D; tmp</span><br><span class="line">        var end &#x3D; head</span><br><span class="line">        var count &#x3D; 0</span><br><span class="line">        while(end!&#x3D;null)&#123;</span><br><span class="line">            count++</span><br><span class="line">            if(count%k&#x3D;&#x3D;0)&#123;</span><br><span class="line">                &#x2F;&#x2F;断开节点</span><br><span class="line">               var next &#x3D; end.next</span><br><span class="line">               end.next &#x3D; null</span><br><span class="line">               &#x2F;&#x2F;翻转子链表</span><br><span class="line">               var childEnd &#x3D; pre.next</span><br><span class="line">               var childHead &#x3D; revert(pre.next)</span><br><span class="line">               &#x2F;&#x2F;将子链表和原链表链接</span><br><span class="line">               childEnd.next &#x3D; next</span><br><span class="line">               pre.next &#x3D; childHead</span><br><span class="line">               &#x2F;&#x2F;指向下一个子链表</span><br><span class="line">               pre &#x3D; childEnd</span><br><span class="line">               end &#x3D; next</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                end &#x3D; end.next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">return tmp.next</span><br><span class="line">    &#125;</span><br><span class="line">    fun revert(start:ListNode?):ListNode?&#123;</span><br><span class="line">        var start &#x3D; start</span><br><span class="line">        var tmp &#x3D; ListNode(-1)</span><br><span class="line">        while(start!&#x3D;null)&#123;</span><br><span class="line">            var next &#x3D; start.next</span><br><span class="line">            start.next &#x3D; tmp.next</span><br><span class="line">            tmp.next &#x3D; start</span><br><span class="line">            start &#x3D; next</span><br><span class="line">        &#125;</span><br><span class="line">return tmp.next</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度<code>$O(N)$</code>： N 是链表的长度；</li><li>空间复杂度<code>$O(1)$</code>：</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/reverse-
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】19. 删除链表的倒数第N个节点</title>
    <link href="https://eriecorner.github.io/2020/05/08/suan-fa/leetcode/19.shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/"/>
    <id>https://eriecorner.github.io/2020/05/08/suan-fa/leetcode/19.shan-chu-lian-biao-de-dao-shu-di-n-ge-jie-dian/</id>
    <published>2020-05-07T16:00:00.000Z</published>
    <updated>2020-05-18T14:20:41.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述：<br>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</li></ul><p><strong>说明</strong>：<br>给定的 n 保证是有效的。</p><ul><li>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n &#x3D; 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>使用快慢指针slow和fast，当fast走到第K个节点时，slow也开始走，当fast走到链表尾时，slow就走到了倒数第K+1个节点，这时删除slow的下一个节点。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> public ListNode removeNthFromEnd(ListNode head, int n) &#123;</span><br><span class="line">        if(head&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow &#x3D; new ListNode(-1);</span><br><span class="line">        slow.next &#x3D; head;</span><br><span class="line">        ListNode p &#x3D; slow;</span><br><span class="line">        ListNode fast &#x3D; head;</span><br><span class="line">        for(int i &#x3D; 1;fast!&#x3D;null;i++)&#123;</span><br><span class="line">            fast &#x3D; fast.next;</span><br><span class="line">            if(i&gt;n)&#123;</span><br><span class="line">                slow &#x3D; slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next &#x3D; slow.next.next;</span><br><span class="line"></span><br><span class="line">return p.next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fun removeNthFromEnd(head: ListNode?, n: Int): ListNode? &#123;</span><br><span class="line">        var slow: ListNode? &#x3D; ListNode(-1)</span><br><span class="line">        slow!!.next &#x3D; head</span><br><span class="line">        val p &#x3D; slow</span><br><span class="line">        var fast &#x3D; head</span><br><span class="line">        var i &#x3D; 1</span><br><span class="line">        while (fast !&#x3D; null) &#123;</span><br><span class="line">            fast &#x3D; fast.next</span><br><span class="line">            if (i &gt; n) &#123;</span><br><span class="line">                slow &#x3D; slow!!.next</span><br><span class="line">            &#125;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        slow!!.next &#x3D; slow.next!!.next</span><br><span class="line">        return p.next</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度<code>$O(N)$</code>:N 是链表的节点个数</li><li>空间复杂度<code>$O(1)$</code>:</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/remove-n
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="链表" scheme="https://eriecorner.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】15. 三数之和</title>
    <link href="https://eriecorner.github.io/2020/05/07/suan-fa/leetcode/15.san-shu-zhi-he/"/>
    <id>https://eriecorner.github.io/2020/05/07/suan-fa/leetcode/15.san-shu-zhi-he/</id>
    <published>2020-05-06T16:00:00.000Z</published>
    <updated>2020-05-18T14:20:48.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述：<br>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</li></ul><p>注意：答案中不可以包含重复的三元组。</p><ul><li>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums &#x3D; [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>双指针+排序</li><li>固定 3 个指针中最左（最小）数字的指针 k，双指针 i，j 分设在数组索引 (k, len(nums)) 两端，通过双指针交替向中间移动，记录对于每个固定指针 k 的所有满足 nums[k] + nums[i] + nums[j] == 0 的 i,j 组合：<ol><li>当 nums[k] &gt; 0 时直接break跳出：因为 nums[j] &gt;= nums[i] &gt;= nums[k] &gt; 0，即 3 个数字都大于 0 ，在此固定指针 k 之后不可能再找到结果了。</li><li>当 k &gt; 0且nums[k] == nums[k - 1]时即跳过此元素nums[k]：因为已经将 nums[k - 1] 的所有组合加入到结果中，本次双指针搜索只会得到重复组合。</li><li>i，j 分设在数组索引 (k, len(nums))(k,len(nums)) 两端，当i &lt; j时循环计算s = nums[k] + nums[i] + nums[j]，并按照以下规则执行双指针移动：<ul><li>当s &lt; 0时，i += 1并跳过所有重复的nums[i]；</li><li>当s &gt; 0时，j -= 1并跳过所有重复的nums[j]；</li><li>当s == 0时，记录组合[k, i, j]至res，执行i += 1和j -= 1并跳过所有重复的nums[i]和nums[j]，防止记录到重复组合。</li></ul></li></ol></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">       List&lt;List&lt;Integer&gt;&gt; result &#x3D; new ArrayList();</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       for(int k &#x3D; 0;k&lt;nums.length-2;k++)&#123;</span><br><span class="line">           if(nums[k]&gt;0)&#123;</span><br><span class="line">               break;</span><br><span class="line">           &#125;</span><br><span class="line">           if(k&gt;0&amp;&amp;nums[k]&#x3D;&#x3D;nums[k-1]) &#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line">           int i &#x3D; k+1,j &#x3D; nums.length-1;</span><br><span class="line">           while(i&lt;j)&#123;</span><br><span class="line">               int sum &#x3D; nums[k]+nums[i]+nums[j];</span><br><span class="line">               if(sum&lt;0)&#123;</span><br><span class="line">                   while(i&lt;j&amp;&amp;nums[i]&#x3D;&#x3D;nums[++i]);</span><br><span class="line">               &#125;else if (sum&gt;0)&#123;</span><br><span class="line">                     while(i&lt;j&amp;&amp;nums[j]&#x3D;&#x3D;nums[--j]);</span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                   result.add(new ArrayList&lt;Integer&gt;(Arrays.asList(nums[k],nums[i],nums[j])));</span><br><span class="line">                   while(i&lt;j&amp;&amp;nums[i]&#x3D;&#x3D;nums[++i]);</span><br><span class="line">                   while(i&lt;j&amp;&amp;nums[j]&#x3D;&#x3D;nums[--j]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">fun threeSum(nums: IntArray): List&lt;List&lt;Int&gt;&gt; &#123;</span><br><span class="line">      val result: MutableList&lt;List&lt;Int&gt;&gt; &#x3D; ArrayList()</span><br><span class="line">        Arrays.sort(nums)</span><br><span class="line">        for (k in 0 until nums.size - 2) &#123;</span><br><span class="line">            if (nums[k] &gt; 0) &#123;</span><br><span class="line">                break</span><br><span class="line">            &#125;</span><br><span class="line">            if (k &gt; 0 &amp;&amp; nums[k] &#x3D;&#x3D; nums[k - 1]) &#123;</span><br><span class="line">                continue</span><br><span class="line">            &#125;</span><br><span class="line">            var i &#x3D; k + 1</span><br><span class="line">            var j &#x3D; nums.size - 1</span><br><span class="line">            while (i &lt; j) &#123;</span><br><span class="line">                val sum &#x3D; nums[k] + nums[i] + nums[j]</span><br><span class="line">                when &#123;</span><br><span class="line">                    sum &lt; 0 -&gt; &#123;</span><br><span class="line">                        while (i &lt; j &amp;&amp; nums[i] &#x3D;&#x3D; nums[++i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sum &gt; 0 -&gt; &#123;</span><br><span class="line">                        while (i &lt; j &amp;&amp; nums[j] &#x3D;&#x3D; nums[--j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    else -&gt; &#123;</span><br><span class="line">                       result.add(ArrayList(mutableListOf(nums[k], nums[i], nums[j])))</span><br><span class="line">                        while (i &lt; j &amp;&amp; nums[i] &#x3D;&#x3D; nums[++i]);</span><br><span class="line">                        while (i &lt; j &amp;&amp; nums[j] &#x3D;&#x3D; nums[--j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：<code>$O(NlogN)$</code></li><li>空间复杂度：<code>$O(1)$</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/3sum/&quot; t
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://eriecorner.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】13. 罗马数字转整数</title>
    <link href="https://eriecorner.github.io/2020/05/06/suan-fa/leetcode/13.luo-ma-shu-zi-zhuan-zheng-shu/"/>
    <id>https://eriecorner.github.io/2020/05/06/suan-fa/leetcode/13.luo-ma-shu-zi-zhuan-zheng-shu/</id>
    <published>2020-05-05T16:00:00.000Z</published>
    <updated>2020-05-18T14:20:54.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述： 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</li></ul><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><pre><code>- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。     </code></pre><p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p><ul><li>示例1.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure></li></ul><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>3.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure><p>4.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>分别列出每个字符对应的数字，然后循环遍历比较前后两个数字，若前面的数字比后面的大，则和减去前面的数；否则和加上前面的数。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public int romanToInt(String s) &#123;</span><br><span class="line">        int num &#x3D; getNum(s.charAt(0));</span><br><span class="line">        int sum &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 1;i&lt;s.length();i++)&#123;</span><br><span class="line">            int curr &#x3D; getNum(s.charAt(i));</span><br><span class="line">            if(num&lt;curr)&#123;</span><br><span class="line">                sum-&#x3D;num;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                sum+&#x3D; num;</span><br><span class="line">            &#125;</span><br><span class="line">            num &#x3D; curr;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return sum+&#x3D; num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public int getNum(char str)&#123;</span><br><span class="line">        switch(str)&#123;</span><br><span class="line">            case &#39;I&#39;:</span><br><span class="line">            return 1;</span><br><span class="line">            case &#39;V&#39;:</span><br><span class="line">            return 5;</span><br><span class="line">            case &#39;X&#39;:</span><br><span class="line">            return 10;</span><br><span class="line">            case &#39;L&#39;:</span><br><span class="line">            return 50;</span><br><span class="line">            case &#39;C&#39;:</span><br><span class="line">            return 100;</span><br><span class="line">            case &#39;D&#39;:</span><br><span class="line">            return 500;</span><br><span class="line">            case &#39;M&#39;:</span><br><span class="line">            return 1000;</span><br><span class="line">            default:return 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">fun romanToInt(s: String): Int &#123;</span><br><span class="line">      var num &#x3D; getNum(s[0])</span><br><span class="line">      var sum &#x3D; 0</span><br><span class="line">      for (i in 1 until s.length) &#123;</span><br><span class="line">          val curr &#x3D; getNum(s[i])</span><br><span class="line">          if (num &lt; curr) &#123;</span><br><span class="line">              sum -&#x3D; num</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              sum +&#x3D; num</span><br><span class="line">          &#125;</span><br><span class="line">          num &#x3D; curr</span><br><span class="line">      &#125;</span><br><span class="line">      return num.let &#123; sum +&#x3D; it; sum &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fun getNum(str: Char): Int &#123;</span><br><span class="line">      return when (str) &#123;</span><br><span class="line">          &#39;I&#39; -&gt; 1</span><br><span class="line">          &#39;V&#39; -&gt; 5</span><br><span class="line">          &#39;X&#39; -&gt; 10</span><br><span class="line">          &#39;L&#39; -&gt; 50</span><br><span class="line">          &#39;C&#39; -&gt; 100</span><br><span class="line">          &#39;D&#39; -&gt; 500</span><br><span class="line">          &#39;M&#39; -&gt; 1000</span><br><span class="line">          else -&gt; 0</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：<code>$O(N)$</code>：N 是字符串的长度</li><li>空间复杂度：<code>$O(1)$</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/roman-to
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数学" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】12. 整数转罗马数字</title>
    <link href="https://eriecorner.github.io/2020/05/06/suan-fa/leetcode/12.zheng-shu-zhuan-luo-ma-shu-zi/"/>
    <id>https://eriecorner.github.io/2020/05/06/suan-fa/leetcode/12.zheng-shu-zhuan-luo-ma-shu-zi/</id>
    <published>2020-05-05T16:00:00.000Z</published>
    <updated>2020-05-18T14:21:00.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述：<br>罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</li></ul><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><pre><code>- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 - C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。     </code></pre><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><ul><li>示例</li></ul><p>1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure><p>3.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L &#x3D; 50, V &#x3D; 5, III &#x3D; 3.</span><br></pre></td></tr></table></figure><p>4.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M &#x3D; 1000, CM &#x3D; 900, XC &#x3D; 90, IV &#x3D; 4.</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>由题意可知：罗马数字由十三个元素组成，我们可以将其和对应的数字按照对应顺序分别存入两个数组中；</li><li>然后循环遍历这个数组，当给定的数字大于等于数组当前的值时，就将该值对应的罗马字符添加到目标字符串上，并将给定数字减去当前数字后继续跟当前数字进行比较。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public String intToRoman(int num) &#123;</span><br><span class="line">    &#x2F;&#x2F; 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中</span><br><span class="line">    &#x2F;&#x2F; 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想</span><br><span class="line">       int[] nums &#x3D;&#123;1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1&#125;;</span><br><span class="line">       String[] strs &#x3D; &#123;&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;&#125;;</span><br><span class="line">       int size &#x3D; nums.length;</span><br><span class="line">       StringBuilder result &#x3D; new StringBuilder();</span><br><span class="line">       for(int i &#x3D; 0;i&lt;size;i++)&#123;</span><br><span class="line">       &#x2F;&#x2F; 注意：这里是等于号，表示尽量使用大的&quot;面值&quot;</span><br><span class="line">       while(num&gt;&#x3D;nums[i])&#123;</span><br><span class="line">           result.append(strs[i]);</span><br><span class="line">           num-&#x3D;nums[i];</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       return result.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">fun intToRoman(num: Int): String &#123;</span><br><span class="line">        var num &#x3D; num</span><br><span class="line">        val nums &#x3D; intArrayOf(1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1)</span><br><span class="line">        val strs &#x3D; arrayOf(&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;)</span><br><span class="line">        var result:String &#x3D; &quot;&quot;</span><br><span class="line">        for (i in 0 until nums.size) &#123; </span><br><span class="line">            &#x2F;&#x2F; 注意：这里是等于号，表示尽量使用大的&quot;面值&quot;</span><br><span class="line">            while (num &gt;&#x3D; nums[i]) &#123;</span><br><span class="line">                result+&#x3D;(strs[i])</span><br><span class="line">                num -&#x3D; nums[i]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：<code>$O(1)$</code>：虽然看起来是两层循环，但是外层循环的次数最多 12，内层循环的此时其实也是有限次的，综合一下，时间复杂度是 O(1)。</li><li>空间复杂度：<code>$O(1)$</code>:这里使用了两个辅助数字，空间都为 13，还有常数个变量，故空间复杂度是 O(1)。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/integer-
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数学" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>【LeetCode】11. 盛最多水的容器</title>
    <link href="https://eriecorner.github.io/2020/05/05/suan-fa/leetcode/11.sheng-zui-duo-shui-de-rong-qi/"/>
    <id>https://eriecorner.github.io/2020/05/05/suan-fa/leetcode/11.sheng-zui-duo-shui-de-rong-qi/</id>
    <published>2020-05-04T16:00:00.000Z</published>
    <updated>2020-05-18T14:21:06.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目简介"><a href="#题目简介" class="headerlink" title="题目简介"></a>题目简介</h2><ul><li>题目来源： <a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">LeetCode</a></li><li>题目描述：<br>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</li></ul><p>说明：你不能倾斜容器，且 n 的值至少为 2。</p><ul><li>示例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49</span><br></pre></td></tr></table></figure></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ul><li>要求与X轴共同构成的容器可以容纳的最多的水，也就是求构成的这个矩形尽可能大的面积，当然是长和宽都尽可能的大。构成的这个矩形中高取决于左右两条边中的最小值，宽就是左右两条边的横坐标之差。</li><li>那就定义两个指针i，j分别指向给定数组的第一个位置height[0]和最后一个位置height[length-1]，在这两个指针不重合的前提下判断这两个位置的值大小，当height[i]&lt;height[j],将i向右移动一个位置；当height[i]&lt;height[j],将j向左移动一位，得到高度后，宽等于j-i+1,循环遍历，计算出高*宽的最大值。</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="JAVA实现"><a href="#JAVA实现" class="headerlink" title="JAVA实现"></a>JAVA实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public int maxArea(int[] height) &#123;</span><br><span class="line">        int max &#x3D; 0;</span><br><span class="line">        for(int i &#x3D; 0,j&#x3D;height.length-1;i&lt;j;)&#123;</span><br><span class="line">            int minHeight &#x3D; height[i]&lt;height[j]?height[i++]:height[j--];</span><br><span class="line">            max &#x3D; Math.max(max,(j-i+1)*minHeight);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="kotlin实现"><a href="#kotlin实现" class="headerlink" title="kotlin实现"></a>kotlin实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fun maxArea(height: IntArray): Int &#123;</span><br><span class="line">        var max &#x3D; 0</span><br><span class="line">        var i &#x3D; 0;</span><br><span class="line">        var j &#x3D; height.size-1;</span><br><span class="line">        while(i&lt;j)&#123;</span><br><span class="line">            val minHeight &#x3D; if(height[i]&lt;height[j]) height[i++] else height[j--]</span><br><span class="line">            max &#x3D; Math.max(max,(j-i+1)*minHeight)</span><br><span class="line">        &#125;</span><br><span class="line">return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度<code>$O(N)$</code>：双指针遍历一次底边宽度 NN 。</li><li>空间复杂度<code>$O(1)$</code>：指针使用常数额外空间。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目简介&quot;&gt;&lt;a href=&quot;#题目简介&quot; class=&quot;headerlink&quot; title=&quot;题目简介&quot;&gt;&lt;/a&gt;题目简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;题目来源： &lt;a href=&quot;https://leetcode-cn.com/problems/containe
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数组" scheme="https://eriecorner.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="双指针" scheme="https://eriecorner.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
</feed>
