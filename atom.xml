<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>紫依卓兰</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://eriecorner.github.io/"/>
  <updated>2020-04-21T03:50:53.250Z</updated>
  <id>https://eriecorner.github.io/</id>
  
  <author>
    <name>紫依卓兰</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>9. 两个栈实现一个队列</title>
    <link href="https://eriecorner.github.io/2020/04/18/9.%20%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/"/>
    <id>https://eriecorner.github.io/2020/04/18/9.%20%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%98%9F%E5%88%97/</id>
    <published>2020-04-17T16:00:00.000Z</published>
    <updated>2020-04-21T03:50:53.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>栈是先进后出，队列是先进先出。即一序列元素入栈后，出站顺序被翻转，则一个栈（暂且称为inStack）中的元素出站时先放入另一个栈(暂且称为outStack)），然后outStack栈的出站顺序和inStack的入栈顺序一致，就是队列的入队出队顺序。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h4><ul><li><p>定义队列及其入队出队的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Queue &#123;</span><br><span class="line">       private Stack&lt;Integer&gt; inStack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">       private Stack&lt;Integer&gt; outStack &#x3D; new Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * @param node</span><br><span class="line">        * 进栈操作</span><br><span class="line">        *&#x2F;</span><br><span class="line">       public void push(int node) &#123;</span><br><span class="line">           inStack.push(node);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * @return 队列中是否有元素</span><br><span class="line">        *&#x2F;</span><br><span class="line">       public boolean hasElement() &#123;</span><br><span class="line">           if (outStack.isEmpty() &amp;&amp; inStack.isEmpty()) &#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">           return true;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#x2F;**</span><br><span class="line">        * @return 出栈操作</span><br><span class="line">        * @throws Exception</span><br><span class="line">        *&#x2F;</span><br><span class="line">       public int pop() throws Exception &#123;</span><br><span class="line">           if (outStack.isEmpty()) &#123;</span><br><span class="line">               while (!inStack.isEmpty()) &#123;</span><br><span class="line">                   outStack.push(inStack.pop());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (outStack.isEmpty()) &#123;</span><br><span class="line">               throw new Exception(&quot;queue is empty&quot;);</span><br><span class="line">           &#125;</span><br><span class="line">           return outStack.pop();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> @Test</span><br><span class="line"> public void getResult() throws Exception &#123;</span><br><span class="line">        Queue queue &#x3D; new Queue();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">            queue.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while (queue.hasElement()) &#123;</span><br><span class="line">            System.out.println(queue.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;输出01234</span><br></pre></td></tr></table></figure><h4 id="Kotlin-实现"><a href="#Kotlin-实现" class="headerlink" title="Kotlin 实现"></a>Kotlin 实现</h4></li><li><p>构造队列并实现入队出队操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Queue &#123;</span><br><span class="line">        val inStack &#x3D; Stack&lt;Int&gt;();</span><br><span class="line">        val outStack &#x3D; Stack&lt;Int&gt;();</span><br><span class="line">        &#x2F;&#x2F;入栈操作</span><br><span class="line">        fun push(node: Int) &#123;</span><br><span class="line">            inStack.push(node)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;出站操作</span><br><span class="line">        fun pop(): Int &#123;</span><br><span class="line">            if (outStack.isEmpty()) &#123;</span><br><span class="line">                while (!inStack.isEmpty()) &#123;</span><br><span class="line">                    outStack.push(inStack.pop())</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (outStack.isEmpty()) &#123;</span><br><span class="line">                throw Exception(&quot;queue is empty!&quot;)</span><br><span class="line">            &#125;</span><br><span class="line">            return outStack.pop()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fun hasElement(): Boolean &#123;</span><br><span class="line">            if (inStack.isEmpty() &amp;&amp; outStack.isEmpty()) &#123;</span><br><span class="line">                return false</span><br><span class="line">            &#125;</span><br><span class="line">            return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">   fun getResult() &#123;</span><br><span class="line">      val queue &#x3D; Queue()</span><br><span class="line">       for (i:Int in 0..4)&#123;</span><br><span class="line">           queue.push(i)</span><br><span class="line">       &#125;</span><br><span class="line">       while (queue.hasElement())&#123;</span><br><span class="line">           print(queue.pop())</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;输出 01234</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;/p&gt;
&lt;h2 id=&quot;题解&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="队列" scheme="https://eriecorner.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
      <category term="栈" scheme="https://eriecorner.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>1.1 斐波那契数列</title>
    <link href="https://eriecorner.github.io/2020/04/14/%201.1%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://eriecorner.github.io/2020/04/14/%201.1%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-04-21T03:46:44.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。n&lt;=39</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>斐波那契数列如：1,1,2,3,5,8,13…；所以得知F(1)=1，F(2)=1, F(n)=F(n - 1)+F(n - 2)（n ≥ 3，n ∈ N*）。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><ol><li>递归实现 —— 时间复杂度O(2^n）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public long fibonacci(int n) &#123;</span><br><span class="line">       if (n &lt; 0) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">           return 1;</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>顺序求法——时间复杂度O(n）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public long fibonacci2(int n) &#123;</span><br><span class="line">       long result &#x3D; 0;</span><br><span class="line">       long preOne &#x3D; 1;</span><br><span class="line">       long preTwo &#x3D; 1;</span><br><span class="line">       if (n &lt; 0) &#123;</span><br><span class="line">           return 0;</span><br><span class="line">       &#125;</span><br><span class="line">       if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">           return 1;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">           result &#x3D; preOne + preTwo;</span><br><span class="line">           preTwo &#x3D; preOne;</span><br><span class="line">           preOne &#x3D; result;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li>状态矩阵相乘法——时间复杂度O(log n）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> public long fibonacci3(int n) &#123;</span><br><span class="line">        if (n &lt; 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125; else if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;状态矩阵</span><br><span class="line">        int[][] base &#x3D; &#123;&#123;1, 1&#125;, &#123;1, 0&#125;&#125;;</span><br><span class="line">        &#x2F;&#x2F;最后的结果需要求矩阵的n-2次</span><br><span class="line">        int[][] res &#x3D; matrixPower(base, n - 2);</span><br><span class="line">        return res[0][0] + res[1][0];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;求矩阵m的p次幂的值</span><br><span class="line">    private int[][] matrixPower(int[][] m, int p) &#123;</span><br><span class="line">        int[][] res &#x3D; new int[m.length][m[0].length];</span><br><span class="line">        &#x2F;&#x2F;先把res设为单位矩阵，相当于整数中的1</span><br><span class="line">        for (int i &#x3D; 0; i &lt; res.length; i++) &#123;</span><br><span class="line">            res[i][i] &#x3D; 1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;临时矩阵</span><br><span class="line">        int[][] tmp &#x3D; m;</span><br><span class="line">        for (; p !&#x3D; 0; p &gt;&gt;&#x3D; 1) &#123;</span><br><span class="line">            if ((p &amp; 1) !&#x3D; 0) &#123;</span><br><span class="line">&#x2F;&#x2F;按位与操作，其实也就是位置为1的乘把这个矩阵乘一下</span><br><span class="line">                res &#x3D; muliMatrix(res, tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;</span><br><span class="line">            &#x2F;&#x2F;等于0 的时候我临时矩阵自己乘一下</span><br><span class="line">            tmp &#x3D; muliMatrix(tmp, tmp);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private int[][] muliMatrix(int[][] m1, int[][] m2) &#123;</span><br><span class="line">        &#x2F;&#x2F;构造出一个m1行和m2列的矩阵（矩阵相乘规则）</span><br><span class="line">        int[][] res &#x3D; new int[m1.length][m2[0].length];</span><br><span class="line">        &#x2F;&#x2F;给我们要得到的矩阵的每一个元素的值进行赋值操作</span><br><span class="line">        for (int i &#x3D; 0; i &lt; m1.length; i++) &#123;</span><br><span class="line">            for (int j &#x3D; 0; j &lt; m2[0].length; j++) &#123;</span><br><span class="line">                for (int k &#x3D; 0; k &lt; m2.length; k++) &#123;</span><br><span class="line">&#x2F;&#x2F;i，j位置元素的值就是i行元素和j行元素乘积的加和</span><br><span class="line">                    res[i][j] +&#x3D; m1[i][k] * m2[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项。n&amp;lt;=39&lt;/p&gt;
&lt;h2 id=&quot;题解：&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/"/>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>1.2 矩形覆盖问题</title>
    <link href="https://eriecorner.github.io/2020/04/14/1.2%20%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/"/>
    <id>https://eriecorner.github.io/2020/04/14/1.2%20%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-13T16:00:00.000Z</published>
    <updated>2020-04-21T03:50:47.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>我们可以用 2<em>1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2</em>1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？</p><h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>f(1) = 1; f(2) = 2; n&gt;2则f(n) = f(n-1)+f(n-2)</p><h2 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int coverRect(int n) &#123;</span><br><span class="line">        if (n &lt;&#x3D; 2) &#123;</span><br><span class="line">            return n;</span><br><span class="line">        &#125;</span><br><span class="line">        int preOne &#x3D; 2, preTwo &#x3D; 1, result &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            result &#x3D; preOne + preTwo;</span><br><span class="line">            preTwo &#x3D; preOne;</span><br><span class="line">            preOne &#x3D; result;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目描述：&quot;&gt;&lt;a href=&quot;#题目描述：&quot; class=&quot;headerlink&quot; title=&quot;题目描述：&quot;&gt;&lt;/a&gt;题目描述：&lt;/h2&gt;&lt;p&gt;我们可以用 2&lt;em&gt;1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2&lt;/em&gt;1 的小矩形无重叠地覆盖
      
    
    </summary>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="递归" scheme="https://eriecorner.github.io/categories/%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92/"/>
    
    
      <category term="算法" scheme="https://eriecorner.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World11111</title>
    <link href="https://eriecorner.github.io/2020/01/01/hello-world/"/>
    <id>https://eriecorner.github.io/2020/01/01/hello-world/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2020-04-20T13:04:53.653Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="Android" scheme="https://eriecorner.github.io/categories/Android/"/>
    
      <category term="View" scheme="https://eriecorner.github.io/categories/Android/View/"/>
    
    
      <category term="hexo" scheme="https://eriecorner.github.io/tags/hexo/"/>
    
      <category term="hello" scheme="https://eriecorner.github.io/tags/hello/"/>
    
  </entry>
  
</feed>
